{"version":3,"sources":["webpack:////home/85suraj/.npm/lib/node_modules/lwc-services/node_modules/@lwc/engine/dist/engine.cjs.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AACa;;AAEb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,qBAAqB;AAC5B,OAAO,UAAU;AACjB,OAAO,8DAA8D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,iLAAiL;AACxL,OAAO,qBAAqB;AAC5B,OAAO,wOAAwO;AAC/O,OAAO,mCAAmC;AAC1C,OAAO,4GAA4G;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU,GAAG,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;;AAEA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;;AAEA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK,EAAE;AACP;AACA;;AAEA,4BAA4B;;AAE5B;AACA,GAAG,aAAa;AAChB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D,UAAU,GAAG,IAAI;AAC5E;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA,gDAAgD;;AAEhD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;;AAEpC;AACA,aAAa,IAAI,IAAI,sBAAsB;AAC3C;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,iCAAiC;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB,KAAK;AAC7B,CAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB,oBAAoB,aAAa;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;;AAEA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,KAAK,KAAK,KAAK;AAC1C;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;;AAEA,KAAK;AACL,GAAG;AACH;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA,4CAA4C,KAAK,0BAA0B,oBAAoB;AAC/F;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wDAAwD,SAAS;;AAEjE;AACA;AACA,SAAS;AACT,iEAAiE,UAAU;AAC3E;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA,SAAS;;AAET;AACA,iDAAiD,SAAS;AAC1D;AACA;;AAEA,KAAK;AACL,GAAG;AACH;AACA,CAAC;AACD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD,kBAAkB;;AAElB;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK,QAAQ;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,QAAQ;;AAEb,kIAAkI;;AAElI;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,QAAQ;;AAEb;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,QAAQ;;AAEb;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,8EAA8E,kCAAkC;AAChH;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iFAAiF;;AAEjF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU,SAAoB;AAC9B;AACA;AACA,SAAS;AACT,wEAAwE,eAAe,MAAM,eAAe;AAC5G;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,uDAAuD,eAAe,QAAQ,eAAe,MAAM,eAAe;AAClH;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,0DAA0D,eAAe,QAAQ,eAAe,MAAM,eAAe;AACrH;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,8EAA8E,eAAe,MAAM,eAAe;AAClH;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,uEAAuE,eAAe,MAAM,eAAe;AAC3G;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,kEAAkE,eAAe,QAAQ,eAAe,MAAM,eAAe;AAC7H;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI,SAAoB;AACxB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAiE;AACjE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mFAAmF;;AAEnF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;AACA,8EAA8E;;AAE9E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B,6FAA6F,SAAS;AACtG;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,6FAA6F,SAAS;AACtG;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,SAAoB;AAChC,8CAA8C,SAAS;AACvD;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,iDAAiD,gBAAgB,oDAAoD,GAAG,GAAG,SAAS;AACpI,iFAAiF,gBAAgB,+EAA+E,GAAG,GAAG,SAAS;AAC/L,yEAAyE,oBAAoB;AAC7F,0FAA0F,SAAS,SAAS,SAAS,OAAO,GAAG;AAC/H;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,SAAS;;;AAGT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B,gLAAgL,GAAG;AACnL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;;AAGH,kEAAkE;;AAElE;AACA;AACA,uBAAuB;;AAEvB,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,oCAAoC,KAAK;AAC/J,0EAA0E,gBAAgB,oCAAoC,GAAG,oCAAoC,KAAK;AAC1K,2GAA2G,GAAG,cAAc,KAAK,4CAA4C,SAAS;AACtL;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B,uEAAuE,oBAAoB;AAC3F;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B,uEAAuE,oBAAoB;AAC3F;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B,sJAAsJ,oBAAoB;AAC1K;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B,0IAA0I,oBAAoB;AAC9J;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B,6IAA6I,oBAAoB;AACjK;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B,iJAAiJ,oBAAoB;AACrK;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B,mJAAmJ,oBAAoB;AACvK;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,QAAQ,SAAoB;AAC5B;AACA;AACA,sEAAsE,GAAG;AACzE;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,sBAAsB,YAAY;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,IAAI,SAAoB;AACxB;AACA,CAAC;;;AAGD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,iDAAiD,gBAAgB,oDAAoD,GAAG,GAAG,gBAAgB;AAC3I,4EAA4E,gBAAgB,oCAAoC,GAAG,GAAG,gBAAgB;AACtJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK,EAAE;AACP;AACA;;AAEA,4BAA4B;;AAE5B;AACA,GAAG,aAAa;AAChB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA,qDAAqD;AACrD;;AAEA;AACA;;AAEA;AACA,gDAAgD,MAAM,kCAAkC,KAAK;;AAE7F,QAAQ,SAAoB;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,MAAM,kCAAkC,KAAK;AAC1F;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,gDAAgD,MAAM,kCAAkC,KAAK,MAAM,KAAK,yCAAyC,aAAa;AAC9J;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,SAAoB;AAChC,yDAAyD,gBAAgB;AACzE;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,iDAAiD,gBAAgB,oDAAoD,GAAG,GAAG,gBAAgB;AAC3I,4EAA4E,gBAAgB,oCAAoC,GAAG,GAAG,gBAAgB;AACtJ;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,uCAAuC;AACvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B,2FAA2F,gBAAgB;AAC3G;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,SAAoB;AAC9B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,iDAAiD,gBAAgB,oDAAoD,GAAG,GAAG,gBAAgB;AAC3I,4EAA4E,gBAAgB,oCAAoC,GAAG,GAAG,gBAAgB;AACtJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO,UAAU,SAAoB;AACrC,yEAAyE,gBAAgB,MAAM,GAAG;AAClG;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;AAE7B;AACA,MAAM,SAAoB;AAC1B;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,wDAAwD,UAAU;AAClE,KAAK;AACL,mGAAmG,sBAAsB,0BAA0B,KAAK;AACxJ,KAAK;AACL,wDAAwD,UAAU;AAClE;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,YAAY,SAAoB;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,YAAY,SAAoB;AAChC,uDAAuD,kBAAkB;AACzE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,YAAY,SAAoB;AAChC,sDAAsD,kBAAkB;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,OAAO;AAC7C;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,qCAAqC;;AAErC,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL,yBAAyB;;AAEzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;;AAGA,0BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;;AAGA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D,UAAU;AACtE,GAAG;;;AAGH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,mEAAmE,UAAU;AAC7E;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,+BAA+B;AAC/B,wDAAwD,eAAe,8DAA8D,SAAS;;AAE9I,iDAAiD,SAAS,gBAAgB,SAAS;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;AACA;;;AAGA;;AAEA;AACA;AACA,wEAAwE;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG,qEAAqE;;;AAGxE;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,KAAK;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;;;AAGA;AACA,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,gCAAgC;;AAEjC;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,KAAK,iBAAiB;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;;AAEA;AACA,UAAU,SAAoB;AAC9B;AACA,OAAO;AACP;;;AAGA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,UAAU,SAAoB;AAC9B,yDAAyD,GAAG;AAC5D;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,qCAAqC;;AAErC;AACA,wCAAwC,OAAO;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,wCAAwC,IAAI,8CAA8C,gBAAgB,qDAAqD;;AAE/J;AACA;;AAEA;AACA,uDAAuD,IAAI;AAC3D;;AAEA;AACA;AACA,wLAAwL,WAAW;AACnM;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;;AAEA;AACA,2CAA2C,kBAAkB,qBAAqB,gBAAgB;AAClG;AACA;;AAEA;AACA,CAAC;;AAED;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,8GAA8G;;AAE9G;AACA;;AAEA;AACA,uDAAuD,IAAI;AAC3D;;AAEA;AACA;AACA;AACA,0LAA0L,WAAW;AACrM;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,wDAAwD,qBAAqB,OAAO,gBAAgB;AACpG;;AAEA;AACA;;AAEA,MAAM,SAAoB;AAC1B,wGAAwG,qBAAqB,QAAQ,gBAAgB;AACrJ;;AAEA;;AAEA,MAAM,SAAoB;AAC1B,+FAA+F,qBAAqB,OAAO,gBAAgB;AAC3I;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,yEAAyE,eAAe,QAAQ,gBAAgB,mBAAmB,EAAE,sBAAsB,eAAe;AAC1K;;AAEA;AACA,WAAW;AACX,mEAAmE,eAAe,QAAQ,gBAAgB,mBAAmB,EAAE;AAC/H;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA,uBAAuB;;AAEvB;;AAEA,iBAAiB,SAAS;AAC1B;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,SAAoB;AAC9B,4CAA4C,IAAI,OAAO,qBAAqB;AAC5E;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,oCAAoC,GAAG;AACvC;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA,YAAY,GAAG,GAAG,oBAAoB;AACtC,CAAC;;AAED;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA,cAAc,IAAI,GAAG,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA,+CAA+C,iBAAiB,uBAAuB,IAAI;AAC3F;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA,mBAAmB,IAAI,GAAG,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;;AAEA;AACA;AACA,KAAK;AACL,UAAU,SAAoB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA,+CAA+C,qBAAqB;AACpE,iDAAiD,uBAAuB;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,wDAAwD,GAAG;AAC5D;;;AAGA;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB,KAAK,MAAM,KAAK,OAAO;AACvD;;AAEA;AACA,YAAY,oBAAoB,KAAK,MAAM;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;;AAEnC;;AAEA;AACA;AACA;AACA,CAAC,sBAAsB;;AAEvB;AACA;AACA;AACA;;AAEA,IAAI,SAAoB;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,mCAAmC;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA,0GAA0G,+BAA+B,aAAa,SAAS,OAAO,GAAG;;AAEzK;AACA;AACA;AACA,uDAAuD,SAAS,OAAO,GAAG;AAC1E;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,sHAAsH,iBAAiB,GAAG;AAC1I;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT;AACA,qFAAqF,GAAG,qEAAqE,YAAY,uCAAuC,iBAAiB;AACjO;;AAEA,8BAA8B;;AAE9B,0CAA0C;;AAE1C;AACA;AACA,SAAS;AACT;;;AAGA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,gCAAgC;;AAEhC;AACA,OAAO;AACP;;;AAGA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC;;AAExC,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,GAAG,EAAE;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,QAAQ,SAAoB;AAC5B,4EAA4E,WAAW,OAAO,GAAG;AACjG;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,MAAM,SAAoB;AAC1B,sCAAsC,GAAG;AACzC;;AAEA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B,6CAA6C,GAAG,+DAA+D,OAAO;AACtH;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA,+DAA+D,GAAG;AAClE,qEAAqE,GAAG,wCAAwC,gBAAgB;AAChI,uEAAuE,GAAG,+CAA+C,gBAAgB;AACzI;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,yEAAyE,QAAQ;AACjF;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH,mCAAmC,SAAS;AAC5C,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK,MAAM;;AAEX,gBAAgB;;AAEhB;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B,4FAA4F,GAAG;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA,2BAA2B,SAAS,IAAI,OAAO;AAC/C;AACA,GAAG;;;AAGH,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,MAAM;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,MAAM,SAAoB;AAC1B,+JAA+J,eAAe;AAC9K;;AAEA;AACA,sBAAsB;;AAEtB,mCAAmC,SAAS;AAC5C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;;AAGP,yDAAyD;AACzD;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,WAAW;AACX;;AAEA,+BAA+B;;AAE/B;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,0DAA0D,GAAG;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,MAAM;AACT;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA,KAAK,+BAA+B;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;AAGA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,iEAAiE;AACjE;AACA;AACA;;AAEA;AACA,sBAAsB,SAAS,GAAG,UAAU;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA,0BAA0B;;AAE1B;AACA;AACA,OAAO;;;AAGP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,+BAA+B;;AAE/B;AACA;AACA,8BAA8B;;AAE9B;AACA,iCAAiC;;AAEjC,mBAAmB;;AAEnB;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA,yDAAyD;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,MAAM;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,GAAG,4EAA4E;;AAE/E;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,YAAY,SAAoB;AAChC;AACA;AACA,wDAAwD,IAAI,gBAAgB,aAAa,2DAA2D,6BAA6B;AACjL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,OAAO,uDAAuD;AAC9D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA,4GAA4G,kBAAkB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"lwc~main.app.js","sourcesContent":["/* proxy-compat-disable */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect() {\n    // Don't apply polyfill when ProxyCompat is enabled.\n    if ('getKey' in Proxy) {\n        return false;\n    }\n    const proxy = new Proxy([3, 4], {});\n    const res = [1, 2].concat(proxy);\n    return res.length !== 4;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { isConcatSpreadable } = Symbol;\nconst { isArray } = Array;\nconst { slice: ArraySlice, unshift: ArrayUnshift, shift: ArrayShift } = Array.prototype;\nfunction isObject(O) {\n    return typeof O === 'object' ? O !== null : typeof O === 'function';\n}\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable\nfunction isSpreadable(O) {\n    if (!isObject(O)) {\n        return false;\n    }\n    const spreadable = O[isConcatSpreadable];\n    return spreadable !== undefined ? Boolean(spreadable) : isArray(O);\n}\n// https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat\nfunction ArrayConcatPolyfill(..._args) {\n    const O = Object(this);\n    const A = [];\n    let N = 0;\n    const items = ArraySlice.call(arguments);\n    ArrayUnshift.call(items, O);\n    while (items.length) {\n        const E = ArrayShift.call(items);\n        if (isSpreadable(E)) {\n            let k = 0;\n            const length = E.length;\n            for (k; k < length; k += 1, N += 1) {\n                if (k in E) {\n                    const subElement = E[k];\n                    A[N] = subElement;\n                }\n            }\n        }\n        else {\n            A[N] = E;\n            N += 1;\n        }\n    }\n    return A;\n}\nfunction apply() {\n    // eslint-disable-next-line no-extend-native\n    Array.prototype.concat = ArrayConcatPolyfill;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect()) {\n    apply();\n}\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction invariant(value, msg) {\n    if (!value) {\n        throw new Error(`Invariant Violation: ${msg}`);\n    }\n}\nfunction isTrue(value, msg) {\n    if (!value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\nfunction isFalse(value, msg) {\n    if (value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\nfunction fail(msg) {\n    throw new Error(msg);\n}\n\nvar assert = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    invariant: invariant,\n    isTrue: isTrue,\n    isFalse: isFalse,\n    fail: fail\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { assign, create, defineProperties, defineProperty, freeze, getOwnPropertyDescriptor, getOwnPropertyNames, getPrototypeOf, hasOwnProperty, isFrozen, keys, seal, setPrototypeOf, } = Object;\nconst { isArray: isArray$1 } = Array;\nconst { filter: ArrayFilter, find: ArrayFind, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, push: ArrayPush, reduce: ArrayReduce, reverse: ArrayReverse, slice: ArraySlice$1, splice: ArraySplice, unshift: ArrayUnshift$1, forEach, } = Array.prototype;\nconst { fromCharCode: StringFromCharCode } = String;\nconst { charCodeAt: StringCharCodeAt, replace: StringReplace, slice: StringSlice, toLowerCase: StringToLowerCase, } = String.prototype;\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isFalse$1(obj) {\n    return obj === false;\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nfunction isObject$1(obj) {\n    return typeof obj === 'object';\n}\nconst OtS = {}.toString;\nfunction toString(obj) {\n    if (obj && obj.toString) {\n        // Arrays might hold objects with \"null\" prototype So using\n        // Array.prototype.toString directly will cause an error Iterate through\n        // all the items and handle individually.\n        if (isArray$1(obj)) {\n            return ArrayJoin.call(ArrayMap.call(obj, toString), ',');\n        }\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS.call(obj);\n    }\n    else {\n        return obj + emptyString;\n    }\n}\nconst emptyString = '';\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and\n * ariaGrabbed) are deprecated:\n * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes\n *\n * The above list of 46 aria attributes is consistent with the following resources:\n * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060\n * https://wicg.github.io/aom/spec/aria-reflection.html\n */\nconst AriaPropertyNames = [\n    'ariaActiveDescendant',\n    'ariaAtomic',\n    'ariaAutoComplete',\n    'ariaBusy',\n    'ariaChecked',\n    'ariaColCount',\n    'ariaColIndex',\n    'ariaColSpan',\n    'ariaControls',\n    'ariaCurrent',\n    'ariaDescribedBy',\n    'ariaDetails',\n    'ariaDisabled',\n    'ariaErrorMessage',\n    'ariaExpanded',\n    'ariaFlowTo',\n    'ariaHasPopup',\n    'ariaHidden',\n    'ariaInvalid',\n    'ariaKeyShortcuts',\n    'ariaLabel',\n    'ariaLabelledBy',\n    'ariaLevel',\n    'ariaLive',\n    'ariaModal',\n    'ariaMultiLine',\n    'ariaMultiSelectable',\n    'ariaOrientation',\n    'ariaOwns',\n    'ariaPlaceholder',\n    'ariaPosInSet',\n    'ariaPressed',\n    'ariaReadOnly',\n    'ariaRelevant',\n    'ariaRequired',\n    'ariaRoleDescription',\n    'ariaRowCount',\n    'ariaRowIndex',\n    'ariaRowSpan',\n    'ariaSelected',\n    'ariaSetSize',\n    'ariaSort',\n    'ariaValueMax',\n    'ariaValueMin',\n    'ariaValueNow',\n    'ariaValueText',\n    'role',\n];\nconst AttrNameToPropNameMap = create(null);\nconst PropNameToAttrNameMap = create(null);\n// Synthetic creation of all AOM property descriptors for Custom Elements\nforEach.call(AriaPropertyNames, (propName) => {\n    // Typescript infers the wrong function type for this particular overloaded method:\n    // https://github.com/Microsoft/TypeScript/issues/27972\n    // @ts-ignore type-mismatch\n    const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, 'aria-'));\n    AttrNameToPropNameMap[attrName] = propName;\n    PropNameToAttrNameMap[propName] = attrName;\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Inspired from: https://mathiasbynens.be/notes/globalthis\nconst _globalThis = (function () {\n    // On recent browsers, `globalThis` is already defined. In this case return it directly.\n    if (typeof globalThis === 'object') {\n        return globalThis;\n    }\n    let _globalThis;\n    try {\n        // eslint-disable-next-line no-extend-native\n        Object.defineProperty(Object.prototype, '__magic__', {\n            get: function () {\n                return this;\n            },\n            configurable: true,\n        });\n        // __magic__ is undefined in Safari 10 and IE10 and older.\n        // @ts-ignore\n        // eslint-disable-next-line no-undef\n        _globalThis = __magic__;\n        // @ts-ignore\n        delete Object.prototype.__magic__;\n    }\n    catch (ex) {\n        // In IE8, Object.defineProperty only works on DOM objects.\n    }\n    finally {\n        // If the magic above fails for some reason we assume that we are in a legacy browser.\n        // Assume `window` exists in this case.\n        if (typeof _globalThis === 'undefined') {\n            // @ts-ignore\n            _globalThis = window;\n        }\n    }\n    return _globalThis;\n})();\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// We use this to detect symbol support in order to avoid the expensive symbol polyfill. Note that\n// we can't use typeof since it will fail when transpiling.\nconst hasNativeSymbolSupport = Symbol('x').toString() === 'Symbol(x)';\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// This method abstracts the creation of symbols, so we can fallback to strings when native symbols\n// are not supported.\nfunction createHiddenField(key, namespace) {\n    return (hasNativeSymbolSupport ? Symbol(key) : `$$lwc-${namespace}-${key}$$`);\n}\nconst hiddenFieldsMap = new WeakMap();\nfunction setHiddenField(o, field, value) {\n    let valuesByField = hiddenFieldsMap.get(o);\n    if (isUndefined(valuesByField)) {\n        valuesByField = create(null);\n        hiddenFieldsMap.set(o, valuesByField);\n    }\n    valuesByField[field] = value;\n}\nfunction getHiddenField(o, field) {\n    const valuesByField = hiddenFieldsMap.get(o);\n    if (!isUndefined(valuesByField)) {\n        return valuesByField[field];\n    }\n}\n/**\n * Map composed of properties to attributes not following the HTML property to attribute mapping\n * convention.\n */\nconst NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING = new Map([\n    ['accessKey', 'accesskey'],\n    ['readOnly', 'readonly'],\n    ['tabIndex', 'tabindex'],\n    ['bgColor', 'bgcolor'],\n    ['colSpan', 'colspan'],\n    ['rowSpan', 'rowspan'],\n    ['contentEditable', 'contenteditable'],\n    ['crossOrigin', 'crossorigin'],\n    ['dateTime', 'datetime'],\n    ['formAction', 'formaction'],\n    ['isMap', 'ismap'],\n    ['maxLength', 'maxlength'],\n    ['minLength', 'minlength'],\n    ['noValidate', 'novalidate'],\n    ['useMap', 'usemap'],\n    ['htmlFor', 'for'],\n]);\n/**\n * Map associating previously transformed HTML property into HTML attribute.\n */\nconst CACHED_PROPERTY_ATTRIBUTE_MAPPING = new Map();\nfunction htmlPropertyToAttribute(propName) {\n    const ariaAttributeName = PropNameToAttrNameMap[propName];\n    if (!isUndefined(ariaAttributeName)) {\n        return ariaAttributeName;\n    }\n    const specialAttributeName = NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.get(propName);\n    if (!isUndefined(specialAttributeName)) {\n        return specialAttributeName;\n    }\n    const cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING.get(propName);\n    if (!isUndefined(cachedAttributeName)) {\n        return cachedAttributeName;\n    }\n    let attributeName = '';\n    for (let i = 0, len = propName.length; i < len; i++) {\n        const code = StringCharCodeAt.call(propName, i);\n        if (code >= 65 && // \"A\"\n            code <= 90 // \"Z\"\n        ) {\n            attributeName += '-' + StringFromCharCode(code + 32);\n        }\n        else {\n            attributeName += StringFromCharCode(code);\n        }\n    }\n    CACHED_PROPERTY_ATTRIBUTE_MAPPING.set(propName, attributeName);\n    return attributeName;\n}\n/** version: 1.9.7 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$1(propName) {\n    return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst nodeToAriaPropertyValuesMap = new WeakMap();\nfunction getAriaPropertyMap(elm) {\n    let map = nodeToAriaPropertyValuesMap.get(elm);\n    if (map === undefined) {\n        map = {};\n        nodeToAriaPropertyValuesMap.set(elm, map);\n    }\n    return map;\n}\nfunction getNormalizedAriaPropertyValue(value) {\n    return value == null ? null : String(value);\n}\nfunction createAriaPropertyPropertyDescriptor(propName, attrName) {\n    return {\n        get() {\n            const map = getAriaPropertyMap(this);\n            if (hasOwnProperty.call(map, propName)) {\n                return map[propName];\n            }\n            // otherwise just reflect what's in the attribute\n            return this.hasAttribute(attrName) ? this.getAttribute(attrName) : null;\n        },\n        set(newValue) {\n            const normalizedValue = getNormalizedAriaPropertyValue(newValue);\n            const map = getAriaPropertyMap(this);\n            map[propName] = normalizedValue;\n            // reflect into the corresponding attribute\n            if (newValue === null) {\n                this.removeAttribute(attrName);\n            }\n            else {\n                this.setAttribute(attrName, newValue);\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    };\n}\nfunction patch(propName) {\n    // Typescript is inferring the wrong function type for this particular\n    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n    // @ts-ignore type-mismatch\n    const attrName = PropNameToAttrNameMap[propName];\n    const descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);\n    Object.defineProperty(Element.prototype, propName, descriptor);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ElementPrototypeAriaPropertyNames = keys(PropNameToAttrNameMap);\nfor (let i = 0, len = ElementPrototypeAriaPropertyNames.length; i < len; i += 1) {\n    const propName = ElementPrototypeAriaPropertyNames[i];\n    if (detect$1(propName)) {\n        patch(propName);\n    }\n}\n\n/* proxy-compat-disable */\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction invariant$1(value, msg) {\n  if (!value) {\n    throw new Error(`Invariant Violation: ${msg}`);\n  }\n}\n\nfunction isTrue$1(value, msg) {\n  if (!value) {\n    throw new Error(`Assert Violation: ${msg}`);\n  }\n}\n\nfunction isFalse$2(value, msg) {\n  if (value) {\n    throw new Error(`Assert Violation: ${msg}`);\n  }\n}\n\nfunction fail$1(msg) {\n  throw new Error(msg);\n}\n\nvar assert$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  invariant: invariant$1,\n  isTrue: isTrue$1,\n  isFalse: isFalse$2,\n  fail: fail$1\n});\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst {\n  assign: assign$1,\n  create: create$1,\n  defineProperties: defineProperties$1,\n  defineProperty: defineProperty$1,\n  freeze: freeze$1,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor$1,\n  getOwnPropertyNames: getOwnPropertyNames$1,\n  getPrototypeOf: getPrototypeOf$1,\n  hasOwnProperty: hasOwnProperty$1,\n  isFrozen: isFrozen$1,\n  keys: keys$1,\n  seal: seal$1,\n  setPrototypeOf: setPrototypeOf$1\n} = Object;\nconst {\n  isArray: isArray$2\n} = Array;\nconst {\n  filter: ArrayFilter$1,\n  find: ArrayFind$1,\n  indexOf: ArrayIndexOf$1,\n  join: ArrayJoin$1,\n  map: ArrayMap$1,\n  push: ArrayPush$1,\n  reduce: ArrayReduce$1,\n  reverse: ArrayReverse$1,\n  slice: ArraySlice$2,\n  splice: ArraySplice$1,\n  unshift: ArrayUnshift$2,\n  forEach: forEach$1\n} = Array.prototype;\nconst {\n  fromCharCode: StringFromCharCode$1\n} = String;\nconst {\n  charCodeAt: StringCharCodeAt$1,\n  replace: StringReplace$1,\n  slice: StringSlice$1,\n  toLowerCase: StringToLowerCase$1\n} = String.prototype;\n\nfunction isUndefined$1(obj) {\n  return obj === undefined;\n}\n\nfunction isNull$1(obj) {\n  return obj === null;\n}\n\nfunction isTrue$1$1(obj) {\n  return obj === true;\n}\n\nfunction isFalse$1$1(obj) {\n  return obj === false;\n}\n\nfunction isFunction$1(obj) {\n  return typeof obj === 'function';\n}\n\nfunction isObject$2(obj) {\n  return typeof obj === 'object';\n}\n\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n\nconst OtS$1 = {}.toString;\n\nfunction toString$1(obj) {\n  if (obj && obj.toString) {\n    // Arrays might hold objects with \"null\" prototype So using\n    // Array.prototype.toString directly will cause an error Iterate through\n    // all the items and handle individually.\n    if (isArray$2(obj)) {\n      return ArrayJoin$1.call(ArrayMap$1.call(obj, toString$1), ',');\n    }\n\n    return obj.toString();\n  } else if (typeof obj === 'object') {\n    return OtS$1.call(obj);\n  } else {\n    return obj + emptyString$1;\n  }\n}\n\nfunction getPropertyDescriptor(o, p) {\n  do {\n    const d = getOwnPropertyDescriptor$1(o, p);\n\n    if (!isUndefined$1(d)) {\n      return d;\n    }\n\n    o = getPrototypeOf$1(o);\n  } while (o !== null);\n}\n\nconst emptyString$1 = '';\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/**\n * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and\n * ariaGrabbed) are deprecated:\n * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes\n *\n * The above list of 46 aria attributes is consistent with the following resources:\n * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060\n * https://wicg.github.io/aom/spec/aria-reflection.html\n */\n\nconst AriaPropertyNames$1 = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];\nconst AttrNameToPropNameMap$1 = create$1(null);\nconst PropNameToAttrNameMap$1 = create$1(null); // Synthetic creation of all AOM property descriptors for Custom Elements\n\nforEach$1.call(AriaPropertyNames$1, propName => {\n  // Typescript infers the wrong function type for this particular overloaded method:\n  // https://github.com/Microsoft/TypeScript/issues/27972\n  // @ts-ignore type-mismatch\n  const attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, 'aria-'));\n  AttrNameToPropNameMap$1[attrName] = propName;\n  PropNameToAttrNameMap$1[propName] = attrName;\n});\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Inspired from: https://mathiasbynens.be/notes/globalthis\n\n\nconst _globalThis$1 = function () {\n  // On recent browsers, `globalThis` is already defined. In this case return it directly.\n  if (typeof globalThis === 'object') {\n    return globalThis;\n  }\n\n  let _globalThis;\n\n  try {\n    // eslint-disable-next-line no-extend-native\n    Object.defineProperty(Object.prototype, '__magic__', {\n      get: function () {\n        return this;\n      },\n      configurable: true\n    }); // __magic__ is undefined in Safari 10 and IE10 and older.\n    // @ts-ignore\n    // eslint-disable-next-line no-undef\n\n    _globalThis = __magic__; // @ts-ignore\n\n    delete Object.prototype.__magic__;\n  } catch (ex) {// In IE8, Object.defineProperty only works on DOM objects.\n  } finally {\n    // If the magic above fails for some reason we assume that we are in a legacy browser.\n    // Assume `window` exists in this case.\n    if (typeof _globalThis === 'undefined') {\n      // @ts-ignore\n      _globalThis = window;\n    }\n  }\n\n  return _globalThis;\n}();\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// We use this to detect symbol support in order to avoid the expensive symbol polyfill. Note that\n// we can't use typeof since it will fail when transpiling.\n\n\nconst hasNativeSymbolSupport$1 = Symbol('x').toString() === 'Symbol(x)';\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// This method abstracts the creation of symbols, so we can fallback to strings when native symbols\n// are not supported.\n\nfunction createHiddenField$1(key, namespace) {\n  return hasNativeSymbolSupport$1 ? Symbol(key) : `$$lwc-${namespace}-${key}$$`;\n}\n\nconst hiddenFieldsMap$1 = new WeakMap();\n\nfunction setHiddenField$1(o, field, value) {\n  let valuesByField = hiddenFieldsMap$1.get(o);\n\n  if (isUndefined$1(valuesByField)) {\n    valuesByField = create$1(null);\n    hiddenFieldsMap$1.set(o, valuesByField);\n  }\n\n  valuesByField[field] = value;\n}\n\nfunction getHiddenField$1(o, field) {\n  const valuesByField = hiddenFieldsMap$1.get(o);\n\n  if (!isUndefined$1(valuesByField)) {\n    return valuesByField[field];\n  }\n}\n/**\n * Map composed of properties to attributes not following the HTML property to attribute mapping\n * convention.\n */\n\n\nconst NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING$1 = new Map([['accessKey', 'accesskey'], ['readOnly', 'readonly'], ['tabIndex', 'tabindex'], ['bgColor', 'bgcolor'], ['colSpan', 'colspan'], ['rowSpan', 'rowspan'], ['contentEditable', 'contenteditable'], ['crossOrigin', 'crossorigin'], ['dateTime', 'datetime'], ['formAction', 'formaction'], ['isMap', 'ismap'], ['maxLength', 'maxlength'], ['minLength', 'minlength'], ['noValidate', 'novalidate'], ['useMap', 'usemap'], ['htmlFor', 'for']]);\n/**\n * Map associating previously transformed HTML property into HTML attribute.\n */\n\nconst CACHED_PROPERTY_ATTRIBUTE_MAPPING$1 = new Map();\n\nfunction htmlPropertyToAttribute$1(propName) {\n  const ariaAttributeName = PropNameToAttrNameMap$1[propName];\n\n  if (!isUndefined$1(ariaAttributeName)) {\n    return ariaAttributeName;\n  }\n\n  const specialAttributeName = NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING$1.get(propName);\n\n  if (!isUndefined$1(specialAttributeName)) {\n    return specialAttributeName;\n  }\n\n  const cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING$1.get(propName);\n\n  if (!isUndefined$1(cachedAttributeName)) {\n    return cachedAttributeName;\n  }\n\n  let attributeName = '';\n\n  for (let i = 0, len = propName.length; i < len; i++) {\n    const code = StringCharCodeAt$1.call(propName, i);\n\n    if (code >= 65 && // \"A\"\n    code <= 90 // \"Z\"\n    ) {\n        attributeName += '-' + StringFromCharCode$1(code + 32);\n      } else {\n      attributeName += StringFromCharCode$1(code);\n    }\n  }\n\n  CACHED_PROPERTY_ATTRIBUTE_MAPPING$1.set(propName, attributeName);\n  return attributeName;\n}\n/** version: 1.9.7 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet nextTickCallbackQueue = [];\nconst SPACE_CHAR = 32;\nconst EmptyObject = seal$1(create$1(null));\nconst EmptyArray = seal$1([]);\n\nfunction flushCallbackQueue() {\n  if (process.env.NODE_ENV !== 'production') {\n    if (nextTickCallbackQueue.length === 0) {\n      throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);\n    }\n  }\n\n  const callbacks = nextTickCallbackQueue;\n  nextTickCallbackQueue = []; // reset to a new queue\n\n  for (let i = 0, len = callbacks.length; i < len; i += 1) {\n    callbacks[i]();\n  }\n}\n\nfunction addCallbackToNextTick(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isFunction$1(callback)) {\n      throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);\n    }\n  }\n\n  if (nextTickCallbackQueue.length === 0) {\n    Promise.resolve().then(flushCallbackQueue);\n  }\n\n  ArrayPush$1.call(nextTickCallbackQueue, callback);\n}\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\n/*\n * Copyright (c) 2019, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  create: create$1$1\n} = Object;\nconst {\n  splice: ArraySplice$1$1,\n  indexOf: ArrayIndexOf$1$1,\n  push: ArrayPush$1$1\n} = Array.prototype;\nconst TargetToReactiveRecordMap = new WeakMap();\n\nfunction isUndefined$1$1(obj) {\n  return obj === undefined;\n}\n\nfunction getReactiveRecord(target) {\n  let reactiveRecord = TargetToReactiveRecordMap.get(target);\n\n  if (isUndefined$1$1(reactiveRecord)) {\n    const newRecord = create$1$1(null);\n    reactiveRecord = newRecord;\n    TargetToReactiveRecordMap.set(target, newRecord);\n  }\n\n  return reactiveRecord;\n}\n\nlet currentReactiveObserver = null;\nfunction valueMutated(target, key) {\n  const reactiveRecord = TargetToReactiveRecordMap.get(target);\n\n  if (!isUndefined$1$1(reactiveRecord)) {\n    const reactiveObservers = reactiveRecord[key];\n\n    if (!isUndefined$1$1(reactiveObservers)) {\n      for (let i = 0, len = reactiveObservers.length; i < len; i += 1) {\n        const ro = reactiveObservers[i];\n        ro.notify();\n      }\n    }\n  }\n}\nfunction valueObserved(target, key) {\n  // We should determine if an active Observing Record is present to track mutations.\n  if (currentReactiveObserver === null) {\n    return;\n  }\n\n  const ro = currentReactiveObserver;\n  const reactiveRecord = getReactiveRecord(target);\n  let reactiveObservers = reactiveRecord[key];\n\n  if (isUndefined$1$1(reactiveObservers)) {\n    reactiveObservers = [];\n    reactiveRecord[key] = reactiveObservers;\n  } else if (reactiveObservers[0] === ro) {\n    return; // perf optimization considering that most subscriptions will come from the same record\n  }\n\n  if (ArrayIndexOf$1$1.call(reactiveObservers, ro) === -1) {\n    ro.link(reactiveObservers);\n  }\n}\nclass ReactiveObserver {\n  constructor(callback) {\n    this.listeners = [];\n    this.callback = callback;\n  }\n\n  observe(job) {\n    const inceptionReactiveRecord = currentReactiveObserver;\n    currentReactiveObserver = this;\n    let error;\n\n    try {\n      job();\n    } catch (e) {\n      error = Object(e);\n    } finally {\n      currentReactiveObserver = inceptionReactiveRecord;\n\n      if (error !== undefined) {\n        throw error; // eslint-disable-line no-unsafe-finally\n      }\n    }\n  }\n  /**\n   * This method is responsible for disconnecting the Reactive Observer\n   * from any Reactive Record that has a reference to it, to prevent future\n   * notifications about previously recorded access.\n   */\n\n\n  reset() {\n    const {\n      listeners\n    } = this;\n    const len = listeners.length;\n\n    if (len > 0) {\n      for (let i = 0; i < len; i += 1) {\n        const set = listeners[i];\n        const pos = ArrayIndexOf$1$1.call(listeners[i], this);\n        ArraySplice$1$1.call(set, pos, 1);\n      }\n\n      listeners.length = 0;\n    }\n  } // friend methods\n\n\n  notify() {\n    this.callback.call(undefined, this);\n  }\n\n  link(reactiveObservers) {\n    ArrayPush$1$1.call(reactiveObservers, this); // we keep track of observing records where the observing record was added to so we can do some clean up later on\n\n    ArrayPush$1$1.call(this.listeners, reactiveObservers);\n  }\n\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction componentValueMutated(vm, key) {\n  valueMutated(vm.component, key);\n}\nfunction componentValueObserved(vm, key) {\n  valueObserved(vm.component, key);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getComponentTag(vm) {\n  return `<${StringToLowerCase$1.call(vm.tagName)}>`;\n} // TODO [#1695]: Unify getComponentStack and getErrorComponentStack\n\nfunction getComponentStack(vm) {\n  const stack = [];\n  let prefix = '';\n\n  while (!isNull$1(vm.owner)) {\n    ArrayPush$1.call(stack, prefix + getComponentTag(vm));\n    vm = vm.owner;\n    prefix += '\\t';\n  }\n\n  return ArrayJoin$1.call(stack, '\\n');\n}\nfunction getErrorComponentStack(vm) {\n  const wcStack = [];\n  let currentVm = vm;\n\n  while (!isNull$1(currentVm)) {\n    ArrayPush$1.call(wcStack, getComponentTag(currentVm));\n    currentVm = currentVm.owner;\n  }\n\n  return wcStack.reverse().join('\\n\\t');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction logError(message, vm) {\n  let msg = `[LWC error]: ${message}`;\n\n  if (!isUndefined$1(vm)) {\n    msg = `${msg}\\n${getComponentStack(vm)}`;\n  }\n\n  if (process.env.NODE_ENV === 'test') {\n    /* eslint-disable-next-line no-console */\n    console.error(msg);\n    return;\n  }\n\n  try {\n    throw new Error(msg);\n  } catch (e) {\n    /* eslint-disable-next-line no-console */\n    console.error(e);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction handleEvent(event, vnode) {\n  const {\n    type\n  } = event;\n  const {\n    data: {\n      on\n    }\n  } = vnode;\n  const handler = on && on[type]; // call event handler if exists\n\n  if (handler) {\n    handler.call(undefined, event);\n  }\n}\n\nfunction createListener() {\n  return function handler(event) {\n    handleEvent(event, handler.vnode);\n  };\n}\n\nfunction updateAllEventListeners(oldVnode, vnode) {\n  if (isUndefined$1(oldVnode.listener)) {\n    createAllEventListeners(vnode);\n  } else {\n    vnode.listener = oldVnode.listener;\n    vnode.listener.vnode = vnode;\n  }\n}\n\nfunction createAllEventListeners(vnode) {\n  const {\n    elm,\n    data: {\n      on\n    },\n    owner: {\n      renderer\n    }\n  } = vnode;\n\n  if (isUndefined$1(on)) {\n    return;\n  }\n\n  const listener = vnode.listener = createListener();\n  listener.vnode = vnode;\n  let name;\n\n  for (name in on) {\n    renderer.addEventListener(elm, name, listener);\n  }\n}\n\nvar modEvents = {\n  update: updateAllEventListeners,\n  create: createAllEventListeners\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst defaultDefHTMLPropertyNames = ['accessKey', 'dir', 'draggable', 'hidden', 'id', 'lang', 'spellcheck', 'tabIndex', 'title'];\n\nfunction offsetPropertyErrorMessage(name) {\n  return `Using the \\`${name}\\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \\`getBoundingClientRect\\` method to obtain fractional values for the size of an element and its position relative to the viewport.`;\n} // Global HTML Attributes & Properties\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n\n\nconst globalHTMLProperties = assign$1(create$1(null), {\n  accessKey: {\n    attribute: 'accesskey'\n  },\n  accessKeyLabel: {\n    readOnly: true\n  },\n  className: {\n    attribute: 'class',\n    error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.'\n  },\n  contentEditable: {\n    attribute: 'contenteditable'\n  },\n  dataset: {\n    readOnly: true,\n    error: \"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead.\"\n  },\n  dir: {\n    attribute: 'dir'\n  },\n  draggable: {\n    attribute: 'draggable'\n  },\n  dropzone: {\n    attribute: 'dropzone',\n    readOnly: true\n  },\n  hidden: {\n    attribute: 'hidden'\n  },\n  id: {\n    attribute: 'id'\n  },\n  inputMode: {\n    attribute: 'inputmode'\n  },\n  lang: {\n    attribute: 'lang'\n  },\n  slot: {\n    attribute: 'slot',\n    error: 'Using the `slot` property is an anti-pattern.'\n  },\n  spellcheck: {\n    attribute: 'spellcheck'\n  },\n  style: {\n    attribute: 'style'\n  },\n  tabIndex: {\n    attribute: 'tabindex'\n  },\n  title: {\n    attribute: 'title'\n  },\n  translate: {\n    attribute: 'translate'\n  },\n  // additional \"global attributes\" that are not present in the link above.\n  isContentEditable: {\n    readOnly: true\n  },\n  offsetHeight: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetHeight')\n  },\n  offsetLeft: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetLeft')\n  },\n  offsetParent: {\n    readOnly: true\n  },\n  offsetTop: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetTop')\n  },\n  offsetWidth: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetWidth')\n  },\n  role: {\n    attribute: 'role'\n  }\n});\nlet controlledElement = null;\nlet controlledAttributeName;\nfunction isAttributeLocked(elm, attrName) {\n  return elm !== controlledElement || attrName !== controlledAttributeName;\n}\nfunction lockAttribute(_elm, _key) {\n  controlledElement = null;\n  controlledAttributeName = undefined;\n}\nfunction unlockAttribute(elm, key) {\n  controlledElement = elm;\n  controlledAttributeName = key;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace';\nconst ColonCharCode = 58;\n\nfunction updateAttrs(oldVnode, vnode) {\n  const {\n    data: {\n      attrs\n    },\n    owner: {\n      renderer\n    }\n  } = vnode;\n\n  if (isUndefined$1(attrs)) {\n    return;\n  }\n\n  let {\n    data: {\n      attrs: oldAttrs\n    }\n  } = oldVnode;\n\n  if (oldAttrs === attrs) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.invariant(isUndefined$1(oldAttrs) || keys$1(oldAttrs).join(',') === keys$1(attrs).join(','), `vnode.data.attrs cannot change shape.`);\n  }\n\n  const elm = vnode.elm;\n  const {\n    setAttribute,\n    removeAttribute\n  } = renderer;\n  let key;\n  oldAttrs = isUndefined$1(oldAttrs) ? EmptyObject : oldAttrs; // update modified attributes, add new attributes\n  // this routine is only useful for data-* attributes in all kind of elements\n  // and aria-* in standard elements (custom elements will use props for these)\n\n  for (key in attrs) {\n    const cur = attrs[key];\n    const old = oldAttrs[key];\n\n    if (old !== cur) {\n      unlockAttribute(elm, key);\n\n      if (StringCharCodeAt$1.call(key, 3) === ColonCharCode) {\n        // Assume xml namespace\n        setAttribute(elm, key, cur, xmlNS);\n      } else if (StringCharCodeAt$1.call(key, 5) === ColonCharCode) {\n        // Assume xlink namespace\n        setAttribute(elm, key, cur, xlinkNS);\n      } else if (isNull$1(cur)) {\n        removeAttribute(elm, key);\n      } else {\n        setAttribute(elm, key, cur);\n      }\n\n      lockAttribute();\n    }\n  }\n}\n\nconst emptyVNode = {\n  data: {}\n};\nvar modAttrs = {\n  create: vnode => updateAttrs(emptyVNode, vnode),\n  update: updateAttrs\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction isLiveBindingProp(sel, key) {\n  // For properties with live bindings, we read values from the DOM element\n  // instead of relying on internally tracked values.\n  return sel === 'input' && (key === 'value' || key === 'checked');\n}\n\nfunction update(oldVnode, vnode) {\n  const props = vnode.data.props;\n\n  if (isUndefined$1(props)) {\n    return;\n  }\n\n  const oldProps = oldVnode.data.props;\n\n  if (oldProps === props) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.invariant(isUndefined$1(oldProps) || keys$1(oldProps).join(',') === keys$1(props).join(','), 'vnode.data.props cannot change shape.');\n  }\n\n  const isFirstPatch = isUndefined$1(oldProps);\n  const {\n    elm,\n    sel,\n    owner: {\n      renderer\n    }\n  } = vnode;\n\n  for (const key in props) {\n    const cur = props[key]; // if it is the first time this element is patched, or the current value is different to the previous value...\n\n    if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? renderer.getProperty(elm, key) : oldProps[key])) {\n      renderer.setProperty(elm, key, cur);\n    }\n  }\n}\n\nconst emptyVNode$1 = {\n  data: {}\n};\nvar modProps = {\n  create: vnode => update(emptyVNode$1, vnode),\n  update\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst classNameToClassMap = create$1(null);\n\nfunction getMapFromClassName(className) {\n  // Intentionally using == to match undefined and null values from computed style attribute\n  if (className == null) {\n    return EmptyObject;\n  } // computed class names must be string\n\n\n  className = isString(className) ? className : className + '';\n  let map = classNameToClassMap[className];\n\n  if (map) {\n    return map;\n  }\n\n  map = create$1(null);\n  let start = 0;\n  let o;\n  const len = className.length;\n\n  for (o = 0; o < len; o++) {\n    if (StringCharCodeAt$1.call(className, o) === SPACE_CHAR) {\n      if (o > start) {\n        map[StringSlice$1.call(className, start, o)] = true;\n      }\n\n      start = o + 1;\n    }\n  }\n\n  if (o > start) {\n    map[StringSlice$1.call(className, start, o)] = true;\n  }\n\n  classNameToClassMap[className] = map;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // just to make sure that this object never changes as part of the diffing algo\n    freeze$1(map);\n  }\n\n  return map;\n}\n\nfunction updateClassAttribute(oldVnode, vnode) {\n  const {\n    elm,\n    data: {\n      className: newClass\n    },\n    owner: {\n      renderer\n    }\n  } = vnode;\n  const {\n    data: {\n      className: oldClass\n    }\n  } = oldVnode;\n\n  if (oldClass === newClass) {\n    return;\n  }\n\n  const classList = renderer.getClassList(elm);\n  const newClassMap = getMapFromClassName(newClass);\n  const oldClassMap = getMapFromClassName(oldClass);\n  let name;\n\n  for (name in oldClassMap) {\n    // remove only if it is not in the new class collection and it is not set from within the instance\n    if (isUndefined$1(newClassMap[name])) {\n      classList.remove(name);\n    }\n  }\n\n  for (name in newClassMap) {\n    if (isUndefined$1(oldClassMap[name])) {\n      classList.add(name);\n    }\n  }\n}\n\nconst emptyVNode$2 = {\n  data: {}\n};\nvar modComputedClassName = {\n  create: vnode => updateClassAttribute(emptyVNode$2, vnode),\n  update: updateClassAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction updateStyleAttribute(oldVnode, vnode) {\n  const {\n    elm,\n    data: {\n      style: newStyle\n    },\n    owner: {\n      renderer\n    }\n  } = vnode;\n  const {\n    getStyleDeclaration,\n    removeAttribute\n  } = renderer;\n\n  if (oldVnode.data.style === newStyle) {\n    return;\n  }\n\n  const style = getStyleDeclaration(elm);\n\n  if (!isString(newStyle) || newStyle === '') {\n    removeAttribute(elm, 'style');\n  } else {\n    style.cssText = newStyle;\n  }\n}\n\nconst emptyVNode$3 = {\n  data: {}\n};\nvar modComputedStyle = {\n  create: vnode => updateStyleAttribute(emptyVNode$3, vnode),\n  update: updateStyleAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The compiler takes care of transforming the inline classnames into an object. It's faster to set the\n// different classnames properties individually instead of via a string.\n\nfunction createClassAttribute(vnode) {\n  const {\n    elm,\n    data: {\n      classMap\n    },\n    owner: {\n      renderer\n    }\n  } = vnode;\n\n  if (isUndefined$1(classMap)) {\n    return;\n  }\n\n  const classList = renderer.getClassList(elm);\n\n  for (const name in classMap) {\n    classList.add(name);\n  }\n}\n\nvar modStaticClassName = {\n  create: createClassAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The compiler takes care of transforming the inline style into an object. It's faster to set the\n// different style properties individually instead of via a string.\n\nfunction createStyleAttribute(vnode) {\n  const {\n    elm,\n    data: {\n      styleMap\n    },\n    owner: {\n      renderer\n    }\n  } = vnode;\n\n  if (isUndefined$1(styleMap)) {\n    return;\n  }\n\n  const style = renderer.getStyleDeclaration(elm);\n\n  for (const name in styleMap) {\n    style[name] = styleMap[name];\n  }\n}\n\nvar modStaticStyle = {\n  create: createStyleAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/**\n@license\nCopyright (c) 2015 Simon Friis Vindum.\nThis code may only be used under the MIT License found at\nhttps://github.com/snabbdom/snabbdom/blob/master/LICENSE\nCode distributed by Snabbdom as part of the Snabbdom project at\nhttps://github.com/snabbdom/snabbdom/\n*/\nfunction isUndef(s) {\n  return s === undefined;\n}\n\nfunction sameVnode(vnode1, vnode2) {\n  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\n\nfunction isVNode(vnode) {\n  return vnode != null;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  const map = {};\n  let j, key, ch; // TODO [#1637]: simplify this by assuming that all vnodes has keys\n\n  for (j = beginIdx; j <= endIdx; ++j) {\n    ch = children[j];\n\n    if (isVNode(ch)) {\n      key = ch.key;\n\n      if (key !== undefined) {\n        map[key] = j;\n      }\n    }\n  }\n\n  return map;\n}\n\nfunction addVnodes(parentElm, before, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx];\n\n    if (isVNode(ch)) {\n      ch.hook.create(ch);\n      ch.hook.insert(ch, parentElm, before);\n    }\n  }\n}\n\nfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx]; // text nodes do not have logic associated to them\n\n    if (isVNode(ch)) {\n      ch.hook.remove(ch, parentElm);\n    }\n  }\n}\n\nfunction updateDynamicChildren(parentElm, oldCh, newCh) {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  const newChEnd = newCh.length - 1;\n  let newEndIdx = newChEnd;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let oldKeyToIdx;\n  let idxInOld;\n  let elmToMove;\n  let before;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (!isVNode(oldStartVnode)) {\n      oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n    } else if (!isVNode(oldEndVnode)) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (!isVNode(newStartVnode)) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (!isVNode(newEndVnode)) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n      // Vnode moved right\n      patchVnode(oldStartVnode, newEndVnode);\n      newEndVnode.hook.move(oldStartVnode, parentElm, oldEndVnode.owner.renderer.nextSibling(oldEndVnode.elm));\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n      // Vnode moved left\n      patchVnode(oldEndVnode, newStartVnode);\n      newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      if (oldKeyToIdx === undefined) {\n        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n      }\n\n      idxInOld = oldKeyToIdx[newStartVnode.key];\n\n      if (isUndef(idxInOld)) {\n        // New element\n        newStartVnode.hook.create(newStartVnode);\n        newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        elmToMove = oldCh[idxInOld];\n\n        if (isVNode(elmToMove)) {\n          if (elmToMove.sel !== newStartVnode.sel) {\n            // New element\n            newStartVnode.hook.create(newStartVnode);\n            newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n          } else {\n            patchVnode(elmToMove, newStartVnode);\n            oldCh[idxInOld] = undefined;\n            newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);\n          }\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n  }\n\n  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n    if (oldStartIdx > oldEndIdx) {\n      // There's some cases in which the sub array of vnodes to be inserted is followed by null(s) and an\n      // already processed vnode, in such cases the vnodes to be inserted should be before that processed vnode.\n      let i = newEndIdx;\n      let n;\n\n      do {\n        n = newCh[++i];\n      } while (!isVNode(n) && i < newChEnd);\n\n      before = isVNode(n) ? n.elm : null;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);\n    } else {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n}\nfunction updateStaticChildren(parentElm, oldCh, newCh) {\n  const oldChLength = oldCh.length;\n  const newChLength = newCh.length;\n\n  if (oldChLength === 0) {\n    // the old list is empty, we can directly insert anything new\n    addVnodes(parentElm, null, newCh, 0, newChLength);\n    return;\n  }\n\n  if (newChLength === 0) {\n    // the old list is nonempty and the new list is empty so we can directly remove all old nodes\n    // this is the case in which the dynamic children of an if-directive should be removed\n    removeVnodes(parentElm, oldCh, 0, oldChLength);\n    return;\n  } // if the old list is not empty, the new list MUST have the same\n  // amount of nodes, that's why we call this static children\n\n\n  let referenceElm = null;\n\n  for (let i = newChLength - 1; i >= 0; i -= 1) {\n    const vnode = newCh[i];\n    const oldVNode = oldCh[i];\n\n    if (vnode !== oldVNode) {\n      if (isVNode(oldVNode)) {\n        if (isVNode(vnode)) {\n          // both vnodes must be equivalent, and se just need to patch them\n          patchVnode(oldVNode, vnode);\n          referenceElm = vnode.elm;\n        } else {\n          // removing the old vnode since the new one is null\n          oldVNode.hook.remove(oldVNode, parentElm);\n        }\n      } else if (isVNode(vnode)) {\n        // this condition is unnecessary\n        vnode.hook.create(vnode); // insert the new node one since the old one is null\n\n        vnode.hook.insert(vnode, parentElm, referenceElm);\n        referenceElm = vnode.elm;\n      }\n    }\n  }\n}\n\nfunction patchVnode(oldVnode, vnode) {\n  if (oldVnode !== vnode) {\n    vnode.elm = oldVnode.elm;\n    vnode.hook.update(oldVnode, vnode);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction generateDataDescriptor(options) {\n  return assign$1({\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }, options);\n}\n\nfunction generateAccessorDescriptor(options) {\n  return assign$1({\n    configurable: true,\n    enumerable: true\n  }, options);\n}\n\nlet isDomMutationAllowed = false;\nfunction unlockDomMutation() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  isDomMutationAllowed = true;\n}\nfunction lockDomMutation() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  isDomMutationAllowed = false;\n}\n\nfunction logMissingPortalError(name, type) {\n  return logError(`The \\`${name}\\` ${type} is available only on elements that use the \\`lwc:dom=\"manual\"\\` directive.`);\n}\n\nfunction patchElementWithRestrictions(elm, options) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n  const descriptors = {\n    outerHTML: generateAccessorDescriptor({\n      get() {\n        return originalOuterHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set outerHTML on Element.`);\n      }\n\n    })\n  }; // Apply extra restriction related to DOM manipulation if the element is not a portal.\n\n  if (isFalse$1$1(options.isPortal)) {\n    const {\n      appendChild,\n      insertBefore,\n      removeChild,\n      replaceChild\n    } = elm;\n    const originalNodeValueDescriptor = getPropertyDescriptor(elm, 'nodeValue');\n    const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n    const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n    assign$1(descriptors, {\n      appendChild: generateDataDescriptor({\n        value(aChild) {\n          logMissingPortalError('appendChild', 'method');\n          return appendChild.call(this, aChild);\n        }\n\n      }),\n      insertBefore: generateDataDescriptor({\n        value(newNode, referenceNode) {\n          if (!isDomMutationAllowed) {\n            logMissingPortalError('insertBefore', 'method');\n          }\n\n          return insertBefore.call(this, newNode, referenceNode);\n        }\n\n      }),\n      removeChild: generateDataDescriptor({\n        value(aChild) {\n          if (!isDomMutationAllowed) {\n            logMissingPortalError('removeChild', 'method');\n          }\n\n          return removeChild.call(this, aChild);\n        }\n\n      }),\n      replaceChild: generateDataDescriptor({\n        value(newChild, oldChild) {\n          logMissingPortalError('replaceChild', 'method');\n          return replaceChild.call(this, newChild, oldChild);\n        }\n\n      }),\n      nodeValue: generateAccessorDescriptor({\n        get() {\n          return originalNodeValueDescriptor.get.call(this);\n        },\n\n        set(value) {\n          if (!isDomMutationAllowed) {\n            logMissingPortalError('nodeValue', 'property');\n          }\n\n          originalNodeValueDescriptor.set.call(this, value);\n        }\n\n      }),\n      textContent: generateAccessorDescriptor({\n        get() {\n          return originalTextContentDescriptor.get.call(this);\n        },\n\n        set(value) {\n          logMissingPortalError('textContent', 'property');\n          originalTextContentDescriptor.set.call(this, value);\n        }\n\n      }),\n      innerHTML: generateAccessorDescriptor({\n        get() {\n          return originalInnerHTMLDescriptor.get.call(this);\n        },\n\n        set(value) {\n          logMissingPortalError('innerHTML', 'property');\n          return originalInnerHTMLDescriptor.set.call(this, value);\n        }\n\n      })\n    });\n  }\n\n  defineProperties$1(elm, descriptors);\n}\nconst BLOCKED_SHADOW_ROOT_METHODS = ['cloneNode', 'getElementById', 'getSelection', 'elementsFromPoint', 'dispatchEvent'];\n\nfunction getShadowRootRestrictionsDescriptors(sr) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  } // Disallowing properties in dev mode only to avoid people doing the wrong\n  // thing when using the real shadow root, because if that's the case,\n  // the component will not work when running with synthetic shadow.\n\n\n  const originalAddEventListener = sr.addEventListener;\n  const originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');\n  const originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');\n  const descriptors = {\n    innerHTML: generateAccessorDescriptor({\n      get() {\n        return originalInnerHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set innerHTML on ShadowRoot.`);\n      }\n\n    }),\n    textContent: generateAccessorDescriptor({\n      get() {\n        return originalTextContentDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set textContent on ShadowRoot.`);\n      }\n\n    }),\n    addEventListener: generateDataDescriptor({\n      value(type, listener, options) {\n        // TODO [#420]: this is triggered when the component author attempts to add a listener\n        // programmatically into its Component's shadow root\n        if (!isUndefined$1(options)) {\n          logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalAddEventListener.apply(this, arguments);\n      }\n\n    })\n  };\n  forEach$1.call(BLOCKED_SHADOW_ROOT_METHODS, methodName => {\n    descriptors[methodName] = generateAccessorDescriptor({\n      get() {\n        throw new Error(`Disallowed method \"${methodName}\" in ShadowRoot.`);\n      }\n\n    });\n  });\n  return descriptors;\n} // Custom Elements Restrictions:\n// -----------------------------\n\n\nfunction getCustomElementRestrictionsDescriptors(elm) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const originalAddEventListener = elm.addEventListener;\n  const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n  const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n  const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n  return {\n    innerHTML: generateAccessorDescriptor({\n      get() {\n        return originalInnerHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set innerHTML on HTMLElement.`);\n      }\n\n    }),\n    outerHTML: generateAccessorDescriptor({\n      get() {\n        return originalOuterHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set outerHTML on HTMLElement.`);\n      }\n\n    }),\n    textContent: generateAccessorDescriptor({\n      get() {\n        return originalTextContentDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set textContent on HTMLElement.`);\n      }\n\n    }),\n    addEventListener: generateDataDescriptor({\n      value(type, listener, options) {\n        // TODO [#420]: this is triggered when the component author attempts to add a listener\n        // programmatically into a lighting element node\n        if (!isUndefined$1(options)) {\n          logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalAddEventListener.apply(this, arguments);\n      }\n\n    })\n  };\n}\n\nfunction getComponentRestrictionsDescriptors() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  return {\n    tagName: generateAccessorDescriptor({\n      get() {\n        throw new Error(`Usage of property \\`tagName\\` is disallowed because the component itself does` + ` not know which tagName will be used to create the element, therefore writing` + ` code that check for that value is error prone.`);\n      },\n\n      configurable: true,\n      enumerable: false\n    })\n  };\n}\n\nfunction getLightningElementPrototypeRestrictionsDescriptors(proto) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const originalDispatchEvent = proto.dispatchEvent;\n  const descriptors = {\n    dispatchEvent: generateDataDescriptor({\n      value(event) {\n        const vm = getAssociatedVM(this);\n\n        if (!isNull$1(event) && isObject$2(event)) {\n          const {\n            type\n          } = event;\n\n          if (!/^[a-z][a-z0-9_]*$/.test(type)) {\n            logError(`Invalid event type \"${type}\" dispatched in element ${getComponentTag(vm)}.` + ` Event name must start with a lowercase letter and followed only lowercase` + ` letters, numbers, and underscores`, vm);\n          }\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalDispatchEvent.apply(this, arguments);\n      }\n\n    })\n  };\n  forEach$1.call(getOwnPropertyNames$1(globalHTMLProperties), propName => {\n    if (propName in proto) {\n      return; // no need to redefine something that we are already exposing\n    }\n\n    descriptors[propName] = generateAccessorDescriptor({\n      get() {\n        const {\n          error,\n          attribute\n        } = globalHTMLProperties[propName];\n        const msg = [];\n        msg.push(`Accessing the global HTML property \"${propName}\" is disabled.`);\n\n        if (error) {\n          msg.push(error);\n        } else if (attribute) {\n          msg.push(`Instead access it via \\`this.getAttribute(\"${attribute}\")\\`.`);\n        }\n\n        logError(msg.join('\\n'), getAssociatedVM(this));\n      },\n\n      set() {\n        const {\n          readOnly\n        } = globalHTMLProperties[propName];\n\n        if (readOnly) {\n          logError(`The global HTML property \\`${propName}\\` is read-only.`, getAssociatedVM(this));\n        }\n      }\n\n    });\n  });\n  return descriptors;\n} // This routine will prevent access to certain properties on a shadow root instance to guarantee\n// that all components will work fine in IE11 and other browsers without shadow dom support.\n\n\nfunction patchShadowRootWithRestrictions(sr) {\n  defineProperties$1(sr, getShadowRootRestrictionsDescriptors(sr));\n}\nfunction patchCustomElementWithRestrictions(elm) {\n  const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm);\n  const elmProto = getPrototypeOf$1(elm);\n  setPrototypeOf$1(elm, create$1(elmProto, restrictionsDescriptors));\n}\nfunction patchComponentWithRestrictions(cmp) {\n  defineProperties$1(cmp, getComponentRestrictionsDescriptors());\n}\nfunction patchLightningElementPrototypeWithRestrictions(proto) {\n  defineProperties$1(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having\n// to inject at runtime.\nconst HTMLElementConstructor = typeof HTMLElement !== 'undefined' ? HTMLElement : function () {};\nconst HTMLElementPrototype = HTMLElementConstructor.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This is a descriptor map that contains\n * all standard properties that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base HTML Element and\n * Base Lightning Element should support.\n */\n\nconst HTMLElementOriginalDescriptors = create$1(null);\nforEach$1.call(keys$1(PropNameToAttrNameMap$1), propName => {\n  // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n  // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.\n  const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);\n\n  if (!isUndefined$1(descriptor)) {\n    HTMLElementOriginalDescriptors[propName] = descriptor;\n  }\n});\nforEach$1.call(defaultDefHTMLPropertyNames, propName => {\n  // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n  // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into\n  // this category, so, better to be sure.\n  const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);\n\n  if (!isUndefined$1(descriptor)) {\n    HTMLElementOriginalDescriptors[propName] = descriptor;\n  }\n});\n\n/**\n * Copyright (C) 2017 salesforce.com, inc.\n */\nconst {\n  isArray: isArray$1$1\n} = Array;\nconst {\n  getPrototypeOf: getPrototypeOf$1$1,\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  defineProperties: ObjectDefineProperties,\n  isExtensible,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor$1$1,\n  getOwnPropertyNames: getOwnPropertyNames$1$1,\n  getOwnPropertySymbols,\n  preventExtensions,\n  hasOwnProperty: hasOwnProperty$1$1\n} = Object;\nconst {\n  push: ArrayPush$2,\n  concat: ArrayConcat,\n  map: ArrayMap$1$1\n} = Array.prototype;\nconst OtS$1$1 = {}.toString;\n\nfunction toString$1$1(obj) {\n  if (obj && obj.toString) {\n    return obj.toString();\n  } else if (typeof obj === 'object') {\n    return OtS$1$1.call(obj);\n  } else {\n    return obj + '';\n  }\n}\n\nfunction isUndefined$2(obj) {\n  return obj === undefined;\n}\n\nfunction isFunction$1$1(obj) {\n  return typeof obj === 'function';\n}\n\nconst proxyToValueMap = new WeakMap();\n\nfunction registerProxy(proxy, value) {\n  proxyToValueMap.set(proxy, value);\n}\n\nconst unwrap = replicaOrAny => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\nclass BaseProxyHandler {\n  constructor(membrane, value) {\n    this.originalTarget = value;\n    this.membrane = membrane;\n  } // Shared utility methods\n\n\n  wrapDescriptor(descriptor) {\n    if (hasOwnProperty$1$1.call(descriptor, 'value')) {\n      descriptor.value = this.wrapValue(descriptor.value);\n    } else {\n      const {\n        set: originalSet,\n        get: originalGet\n      } = descriptor;\n\n      if (!isUndefined$2(originalGet)) {\n        descriptor.get = this.wrapGetter(originalGet);\n      }\n\n      if (!isUndefined$2(originalSet)) {\n        descriptor.set = this.wrapSetter(originalSet);\n      }\n    }\n\n    return descriptor;\n  }\n\n  copyDescriptorIntoShadowTarget(shadowTarget, key) {\n    const {\n      originalTarget\n    } = this; // Note: a property might get defined multiple times in the shadowTarget\n    //       but it will always be compatible with the previous descriptor\n    //       to preserve the object invariants, which makes these lines safe.\n\n    const originalDescriptor = getOwnPropertyDescriptor$1$1(originalTarget, key);\n\n    if (!isUndefined$2(originalDescriptor)) {\n      const wrappedDesc = this.wrapDescriptor(originalDescriptor);\n      ObjectDefineProperty(shadowTarget, key, wrappedDesc);\n    }\n  }\n\n  lockShadowTarget(shadowTarget) {\n    const {\n      originalTarget\n    } = this;\n    const targetKeys = ArrayConcat.call(getOwnPropertyNames$1$1(originalTarget), getOwnPropertySymbols(originalTarget));\n    targetKeys.forEach(key => {\n      this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n    });\n    const {\n      membrane: {\n        tagPropertyKey\n      }\n    } = this;\n\n    if (!isUndefined$2(tagPropertyKey) && !hasOwnProperty$1$1.call(shadowTarget, tagPropertyKey)) {\n      ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));\n    }\n\n    preventExtensions(shadowTarget);\n  } // Shared Traps\n\n\n  apply(shadowTarget, thisArg, argArray) {\n    /* No op */\n  }\n\n  construct(shadowTarget, argArray, newTarget) {\n    /* No op */\n  }\n\n  get(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueObserved\n      }\n    } = this;\n    const value = originalTarget[key];\n    valueObserved(originalTarget, key);\n    return this.wrapValue(value);\n  }\n\n  has(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        tagPropertyKey,\n        valueObserved\n      }\n    } = this;\n    valueObserved(originalTarget, key); // since key is never going to be undefined, and tagPropertyKey might be undefined\n    // we can simply compare them as the second part of the condition.\n\n    return key in originalTarget || key === tagPropertyKey;\n  }\n\n  ownKeys(shadowTarget) {\n    const {\n      originalTarget,\n      membrane: {\n        tagPropertyKey\n      }\n    } = this; // if the membrane tag key exists and it is not in the original target, we add it to the keys.\n\n    const keys = isUndefined$2(tagPropertyKey) || hasOwnProperty$1$1.call(originalTarget, tagPropertyKey) ? [] : [tagPropertyKey]; // small perf optimization using push instead of concat to avoid creating an extra array\n\n    ArrayPush$2.apply(keys, getOwnPropertyNames$1$1(originalTarget));\n    ArrayPush$2.apply(keys, getOwnPropertySymbols(originalTarget));\n    return keys;\n  }\n\n  isExtensible(shadowTarget) {\n    const {\n      originalTarget\n    } = this; // optimization to avoid attempting to lock down the shadowTarget multiple times\n\n    if (!isExtensible(shadowTarget)) {\n      return false; // was already locked down\n    }\n\n    if (!isExtensible(originalTarget)) {\n      this.lockShadowTarget(shadowTarget);\n      return false;\n    }\n\n    return true;\n  }\n\n  getPrototypeOf(shadowTarget) {\n    const {\n      originalTarget\n    } = this;\n    return getPrototypeOf$1$1(originalTarget);\n  }\n\n  getOwnPropertyDescriptor(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueObserved,\n        tagPropertyKey\n      }\n    } = this; // keys looked up via getOwnPropertyDescriptor need to be reactive\n\n    valueObserved(originalTarget, key);\n    let desc = getOwnPropertyDescriptor$1$1(originalTarget, key);\n\n    if (isUndefined$2(desc)) {\n      if (key !== tagPropertyKey) {\n        return undefined;\n      } // if the key is the membrane tag key, and is not in the original target,\n      // we produce a synthetic descriptor and install it on the shadow target\n\n\n      desc = {\n        value: undefined,\n        writable: false,\n        configurable: false,\n        enumerable: false\n      };\n      ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);\n      return desc;\n    }\n\n    if (desc.configurable === false) {\n      // updating the descriptor to non-configurable on the shadow\n      this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n    } // Note: by accessing the descriptor, the key is marked as observed\n    // but access to the value, setter or getter (if available) cannot observe\n    // mutations, just like regular methods, in which case we just do nothing.\n\n\n    return this.wrapDescriptor(desc);\n  }\n\n}\n\nconst getterMap = new WeakMap();\nconst setterMap = new WeakMap();\nconst reverseGetterMap = new WeakMap();\nconst reverseSetterMap = new WeakMap();\n\nclass ReactiveProxyHandler extends BaseProxyHandler {\n  wrapValue(value) {\n    return this.membrane.getProxy(value);\n  }\n\n  wrapGetter(originalGet) {\n    const wrappedGetter = getterMap.get(originalGet);\n\n    if (!isUndefined$2(wrappedGetter)) {\n      return wrappedGetter;\n    }\n\n    const handler = this;\n\n    const get = function () {\n      // invoking the original getter with the original target\n      return handler.wrapValue(originalGet.call(unwrap(this)));\n    };\n\n    getterMap.set(originalGet, get);\n    reverseGetterMap.set(get, originalGet);\n    return get;\n  }\n\n  wrapSetter(originalSet) {\n    const wrappedSetter = setterMap.get(originalSet);\n\n    if (!isUndefined$2(wrappedSetter)) {\n      return wrappedSetter;\n    }\n\n    const set = function (v) {\n      // invoking the original setter with the original target\n      originalSet.call(unwrap(this), unwrap(v));\n    };\n\n    setterMap.set(originalSet, set);\n    reverseSetterMap.set(set, originalSet);\n    return set;\n  }\n\n  unwrapDescriptor(descriptor) {\n    if (hasOwnProperty$1$1.call(descriptor, 'value')) {\n      // dealing with a data descriptor\n      descriptor.value = unwrap(descriptor.value);\n    } else {\n      const {\n        set,\n        get\n      } = descriptor;\n\n      if (!isUndefined$2(get)) {\n        descriptor.get = this.unwrapGetter(get);\n      }\n\n      if (!isUndefined$2(set)) {\n        descriptor.set = this.unwrapSetter(set);\n      }\n    }\n\n    return descriptor;\n  }\n\n  unwrapGetter(redGet) {\n    const reverseGetter = reverseGetterMap.get(redGet);\n\n    if (!isUndefined$2(reverseGetter)) {\n      return reverseGetter;\n    }\n\n    const handler = this;\n\n    const get = function () {\n      // invoking the red getter with the proxy of this\n      return unwrap(redGet.call(handler.wrapValue(this)));\n    };\n\n    getterMap.set(get, redGet);\n    reverseGetterMap.set(redGet, get);\n    return get;\n  }\n\n  unwrapSetter(redSet) {\n    const reverseSetter = reverseSetterMap.get(redSet);\n\n    if (!isUndefined$2(reverseSetter)) {\n      return reverseSetter;\n    }\n\n    const handler = this;\n\n    const set = function (v) {\n      // invoking the red setter with the proxy of this\n      redSet.call(handler.wrapValue(this), handler.wrapValue(v));\n    };\n\n    setterMap.set(set, redSet);\n    reverseSetterMap.set(redSet, set);\n    return set;\n  }\n\n  set(shadowTarget, key, value) {\n    const {\n      originalTarget,\n      membrane: {\n        valueMutated\n      }\n    } = this;\n    const oldValue = originalTarget[key];\n\n    if (oldValue !== value) {\n      originalTarget[key] = value;\n      valueMutated(originalTarget, key);\n    } else if (key === 'length' && isArray$1$1(originalTarget)) {\n      // fix for issue #236: push will add the new index, and by the time length\n      // is updated, the internal length is already equal to the new length value\n      // therefore, the oldValue is equal to the value. This is the forking logic\n      // to support this use case.\n      valueMutated(originalTarget, key);\n    }\n\n    return true;\n  }\n\n  deleteProperty(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueMutated\n      }\n    } = this;\n    delete originalTarget[key];\n    valueMutated(originalTarget, key);\n    return true;\n  }\n\n  setPrototypeOf(shadowTarget, prototype) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString$1$1(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);\n    }\n  }\n\n  preventExtensions(shadowTarget) {\n    if (isExtensible(shadowTarget)) {\n      const {\n        originalTarget\n      } = this;\n      preventExtensions(originalTarget); // if the originalTarget is a proxy itself, it might reject\n      // the preventExtension call, in which case we should not attempt to lock down\n      // the shadow target.\n\n      if (isExtensible(originalTarget)) {\n        return false;\n      }\n\n      this.lockShadowTarget(shadowTarget);\n    }\n\n    return true;\n  }\n\n  defineProperty(shadowTarget, key, descriptor) {\n    const {\n      originalTarget,\n      membrane: {\n        valueMutated,\n        tagPropertyKey\n      }\n    } = this;\n\n    if (key === tagPropertyKey && !hasOwnProperty$1$1.call(originalTarget, key)) {\n      // To avoid leaking the membrane tag property into the original target, we must\n      // be sure that the original target doesn't have yet.\n      // NOTE: we do not return false here because Object.freeze and equivalent operations\n      // will attempt to set the descriptor to the same value, and expect no to throw. This\n      // is an small compromise for the sake of not having to diff the descriptors.\n      return true;\n    }\n\n    ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor)); // intentionally testing if false since it could be undefined as well\n\n    if (descriptor.configurable === false) {\n      this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n    }\n\n    valueMutated(originalTarget, key);\n    return true;\n  }\n\n}\n\nconst getterMap$1 = new WeakMap();\nconst setterMap$1 = new WeakMap();\n\nclass ReadOnlyHandler extends BaseProxyHandler {\n  wrapValue(value) {\n    return this.membrane.getReadOnlyProxy(value);\n  }\n\n  wrapGetter(originalGet) {\n    const wrappedGetter = getterMap$1.get(originalGet);\n\n    if (!isUndefined$2(wrappedGetter)) {\n      return wrappedGetter;\n    }\n\n    const handler = this;\n\n    const get = function () {\n      // invoking the original getter with the original target\n      return handler.wrapValue(originalGet.call(unwrap(this)));\n    };\n\n    getterMap$1.set(originalGet, get);\n    return get;\n  }\n\n  wrapSetter(originalSet) {\n    const wrappedSetter = setterMap$1.get(originalSet);\n\n    if (!isUndefined$2(wrappedSetter)) {\n      return wrappedSetter;\n    }\n\n    const handler = this;\n\n    const set = function (v) {\n      if (process.env.NODE_ENV !== 'production') {\n        const {\n          originalTarget\n        } = handler;\n        throw new Error(`Invalid mutation: Cannot invoke a setter on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n      }\n    };\n\n    setterMap$1.set(originalSet, set);\n    return set;\n  }\n\n  set(shadowTarget, key, value) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot set \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n  deleteProperty(shadowTarget, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot delete \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n  setPrototypeOf(shadowTarget, prototype) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid prototype mutation: Cannot set prototype on \"${originalTarget}\". \"${originalTarget}\" prototype is read-only.`);\n    }\n  }\n\n  preventExtensions(shadowTarget) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}\". \"${originalTarget} is read-only.`);\n    }\n\n    return false;\n  }\n\n  defineProperty(shadowTarget, key, descriptor) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot defineProperty \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n}\n\nfunction extract(objectOrArray) {\n  if (isArray$1$1(objectOrArray)) {\n    return objectOrArray.map(item => {\n      const original = unwrap(item);\n\n      if (original !== item) {\n        return extract(original);\n      }\n\n      return item;\n    });\n  }\n\n  const obj = ObjectCreate(getPrototypeOf$1$1(objectOrArray));\n  const names = getOwnPropertyNames$1$1(objectOrArray);\n  return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce((seed, key) => {\n    const item = objectOrArray[key];\n    const original = unwrap(item);\n\n    if (original !== item) {\n      seed[key] = extract(original);\n    } else {\n      seed[key] = item;\n    }\n\n    return seed;\n  }, obj);\n}\n\nconst formatter = {\n  header: plainOrProxy => {\n    const originalTarget = unwrap(plainOrProxy); // if originalTarget is falsy or not unwrappable, exit\n\n    if (!originalTarget || originalTarget === plainOrProxy) {\n      return null;\n    }\n\n    const obj = extract(plainOrProxy);\n    return ['object', {\n      object: obj\n    }];\n  },\n  hasBody: () => {\n    return false;\n  },\n  body: () => {\n    return null;\n  }\n}; // Inspired from paulmillr/es6-shim\n// https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185\n\nfunction getGlobal() {\n  // the only reliable means to get the global object is `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  } // Gracefully degrade if not able to locate the global object\n\n\n  return {};\n}\n\nfunction init() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const global = getGlobal(); // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools\n  //  - Go to Settings,\n  //  - Under console, select \"Enable custom formatters\"\n  // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview\n\n  const devtoolsFormatters = global.devtoolsFormatters || [];\n  ArrayPush$2.call(devtoolsFormatters, formatter);\n  global.devtoolsFormatters = devtoolsFormatters;\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  init();\n}\n\nconst ObjectDotPrototype = Object.prototype;\n\nfunction defaultValueIsObservable(value) {\n  // intentionally checking for null\n  if (value === null) {\n    return false;\n  } // treat all non-object types, including undefined, as non-observable values\n\n\n  if (typeof value !== 'object') {\n    return false;\n  }\n\n  if (isArray$1$1(value)) {\n    return true;\n  }\n\n  const proto = getPrototypeOf$1$1(value);\n  return proto === ObjectDotPrototype || proto === null || getPrototypeOf$1$1(proto) === null;\n}\n\nconst defaultValueObserved = (obj, key) => {\n  /* do nothing */\n};\n\nconst defaultValueMutated = (obj, key) => {\n  /* do nothing */\n};\n\nconst defaultValueDistortion = value => value;\n\nfunction createShadowTarget(value) {\n  return isArray$1$1(value) ? [] : {};\n}\n\nclass ReactiveMembrane {\n  constructor(options) {\n    this.valueDistortion = defaultValueDistortion;\n    this.valueMutated = defaultValueMutated;\n    this.valueObserved = defaultValueObserved;\n    this.valueIsObservable = defaultValueIsObservable;\n    this.objectGraph = new WeakMap();\n\n    if (!isUndefined$2(options)) {\n      const {\n        valueDistortion,\n        valueMutated,\n        valueObserved,\n        valueIsObservable,\n        tagPropertyKey\n      } = options;\n      this.valueDistortion = isFunction$1$1(valueDistortion) ? valueDistortion : defaultValueDistortion;\n      this.valueMutated = isFunction$1$1(valueMutated) ? valueMutated : defaultValueMutated;\n      this.valueObserved = isFunction$1$1(valueObserved) ? valueObserved : defaultValueObserved;\n      this.valueIsObservable = isFunction$1$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;\n      this.tagPropertyKey = tagPropertyKey;\n    }\n  }\n\n  getProxy(value) {\n    const unwrappedValue = unwrap(value);\n    const distorted = this.valueDistortion(unwrappedValue);\n\n    if (this.valueIsObservable(distorted)) {\n      const o = this.getReactiveState(unwrappedValue, distorted); // when trying to extract the writable version of a readonly\n      // we return the readonly.\n\n      return o.readOnly === value ? value : o.reactive;\n    }\n\n    return distorted;\n  }\n\n  getReadOnlyProxy(value) {\n    value = unwrap(value);\n    const distorted = this.valueDistortion(value);\n\n    if (this.valueIsObservable(distorted)) {\n      return this.getReactiveState(value, distorted).readOnly;\n    }\n\n    return distorted;\n  }\n\n  unwrapProxy(p) {\n    return unwrap(p);\n  }\n\n  getReactiveState(value, distortedValue) {\n    const {\n      objectGraph\n    } = this;\n    let reactiveState = objectGraph.get(distortedValue);\n\n    if (reactiveState) {\n      return reactiveState;\n    }\n\n    const membrane = this;\n    reactiveState = {\n      get reactive() {\n        const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue); // caching the reactive proxy after the first time it is accessed\n\n        const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);\n        registerProxy(proxy, value);\n        ObjectDefineProperty(this, 'reactive', {\n          value: proxy\n        });\n        return proxy;\n      },\n\n      get readOnly() {\n        const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue); // caching the readOnly proxy after the first time it is accessed\n\n        const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);\n        registerProxy(proxy, value);\n        ObjectDefineProperty(this, 'readOnly', {\n          value: proxy\n        });\n        return proxy;\n      }\n\n    };\n    objectGraph.set(distortedValue, reactiveState);\n    return reactiveState;\n  }\n\n}\n/** version: 1.0.0 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst lockerLivePropertyKey = Symbol.for('@@lockerLiveValue');\n\nfunction valueDistortion(value) {\n  return value;\n}\n\nconst reactiveMembrane = new ReactiveMembrane({\n  valueObserved,\n  valueMutated,\n  valueDistortion,\n  tagPropertyKey: lockerLivePropertyKey\n});\n/**\n * EXPERIMENTAL: This function implements an unwrap mechanism that\n * works for observable membrane objects. This API is subject to\n * change or being removed.\n */\n\nconst unwrap$1 = function (value) {\n  const unwrapped = reactiveMembrane.unwrapProxy(value);\n\n  if (unwrapped !== value) {\n    // if value is a proxy, unwrap to access original value and apply distortion\n    return valueDistortion(unwrapped);\n  }\n\n  return value;\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This operation is called with a descriptor of an standard html property\n * that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors\n * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.\n */\n\nfunction createBridgeToElementDescriptor(propName, descriptor) {\n  const {\n    get,\n    set,\n    enumerable,\n    configurable\n  } = descriptor;\n\n  if (!isFunction$1(get)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);\n    }\n\n    throw new TypeError();\n  }\n\n  if (!isFunction$1(set)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);\n    }\n\n    throw new TypeError();\n  }\n\n  return {\n    enumerable,\n    configurable,\n\n    get() {\n      const vm = getAssociatedVM(this);\n\n      if (isBeingConstructed(vm)) {\n        if (process.env.NODE_ENV !== 'production') {\n          logError(`The value of property \\`${propName}\\` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property.`, vm);\n        }\n\n        return;\n      }\n\n      componentValueObserved(vm, propName);\n      return get.call(vm.elm);\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert$1.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n        assert$1.invariant(!isUpdatingTemplate, `When updating the template of ${vmBeingRendered}, one of the accessors used by the template has side effects on the state of ${vm}.${propName}`);\n        assert$1.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n        assert$1.invariant(!isObject$2(newValue) || isNull$1(newValue), `Invalid value \"${newValue}\" for \"${propName}\" of ${vm}. Value cannot be an object, must be a primitive value.`);\n      }\n\n      if (newValue !== vm.cmpProps[propName]) {\n        vm.cmpProps[propName] = newValue;\n        componentValueMutated(vm, propName);\n      }\n\n      return set.call(vm.elm, newValue);\n    }\n\n  };\n}\n/**\n * This class is the base class for any LWC element.\n * Some elements directly extends this class, others implement it via inheritance.\n **/\n\n\nfunction BaseLightningElementConstructor() {\n  var _a; // This should be as performant as possible, while any initialization should be done lazily\n\n\n  if (isNull$1(vmBeingConstructed)) {\n    throw new ReferenceError('Illegal constructor');\n  }\n\n  const vm = vmBeingConstructed;\n  const {\n    elm,\n    mode,\n    renderer,\n    def: {\n      ctor,\n      bridge\n    }\n  } = vm;\n\n  if (process.env.NODE_ENV !== 'production') {\n    (_a = renderer.assertInstanceOfHTMLElement) === null || _a === void 0 ? void 0 : _a.call(renderer, vm.elm, `Component creation requires a DOM element to be associated to ${vm}.`);\n  }\n\n  const component = this;\n  setPrototypeOf$1(elm, bridge.prototype);\n  const cmpRoot = renderer.attachShadow(elm, {\n    mode,\n    delegatesFocus: !!ctor.delegatesFocus,\n    '$$lwc-synthetic-mode$$': true\n  });\n  vm.component = this;\n  vm.cmpRoot = cmpRoot; // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new\n  // component creation and passes hooks to instrument all the component interactions with the\n  // engine. We are intentionally hiding this argument from the formal API of LightningElement\n  // because we don't want folks to know about it just yet.\n\n  if (arguments.length === 1) {\n    const {\n      callHook,\n      setHook,\n      getHook\n    } = arguments[0];\n    vm.callHook = callHook;\n    vm.setHook = setHook;\n    vm.getHook = getHook;\n  } // Making the component instance a live value when using Locker to support expandos.\n\n\n  defineProperty$1(component, lockerLivePropertyKey, EmptyObject); // Linking elm, shadow root and component with the VM.\n\n  associateVM(component, vm);\n  associateVM(cmpRoot, vm);\n  associateVM(elm, vm); // Adding extra guard rails in DEV mode.\n\n  if (process.env.NODE_ENV !== 'production') {\n    patchCustomElementWithRestrictions(elm);\n    patchComponentWithRestrictions(component);\n    patchShadowRootWithRestrictions(cmpRoot);\n  }\n\n  return this;\n}\n\nBaseLightningElementConstructor.prototype = {\n  constructor: BaseLightningElementConstructor,\n\n  dispatchEvent(event) {\n    const {\n      elm,\n      renderer: {\n        dispatchEvent\n      }\n    } = getAssociatedVM(this);\n    return dispatchEvent(elm, event);\n  },\n\n  addEventListener(type, listener, options) {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        addEventListener\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vmBeingRendered = getVMBeingRendered();\n      assert$1.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n      assert$1.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n      assert$1.invariant(isFunction$1(listener), `Invalid second argument for this.addEventListener() in ${vm} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n    }\n\n    const wrappedListener = getWrappedComponentsListener(vm, listener);\n    addEventListener(elm, type, wrappedListener, options);\n  },\n\n  removeEventListener(type, listener, options) {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        removeEventListener\n      }\n    } = vm;\n    const wrappedListener = getWrappedComponentsListener(vm, listener);\n    removeEventListener(elm, type, wrappedListener, options);\n  },\n\n  hasAttribute(name) {\n    const {\n      elm,\n      renderer: {\n        getAttribute\n      }\n    } = getAssociatedVM(this);\n    return !isNull$1(getAttribute(elm, name));\n  },\n\n  hasAttributeNS(namespace, name) {\n    const {\n      elm,\n      renderer: {\n        getAttribute\n      }\n    } = getAssociatedVM(this);\n    return !isNull$1(getAttribute(elm, name, namespace));\n  },\n\n  removeAttribute(name) {\n    const {\n      elm,\n      renderer: {\n        removeAttribute\n      }\n    } = getAssociatedVM(this);\n    unlockAttribute(elm, name);\n    removeAttribute(elm, name);\n    lockAttribute();\n  },\n\n  removeAttributeNS(namespace, name) {\n    const {\n      elm,\n      renderer: {\n        removeAttribute\n      }\n    } = getAssociatedVM(this);\n    unlockAttribute(elm, name);\n    removeAttribute(elm, name, namespace);\n    lockAttribute();\n  },\n\n  getAttribute(name) {\n    const {\n      elm,\n      renderer: {\n        getAttribute\n      }\n    } = getAssociatedVM(this);\n    return getAttribute(elm, name);\n  },\n\n  getAttributeNS(namespace, name) {\n    const {\n      elm,\n      renderer: {\n        getAttribute\n      }\n    } = getAssociatedVM(this);\n    return getAttribute(elm, name, namespace);\n  },\n\n  setAttribute(name, value) {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        setAttribute\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n    }\n\n    unlockAttribute(elm, name);\n    setAttribute(elm, name, value);\n    lockAttribute();\n  },\n\n  setAttributeNS(namespace, name, value) {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        setAttribute\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n    }\n\n    unlockAttribute(elm, name);\n    setAttribute(elm, name, value, namespace);\n    lockAttribute();\n  },\n\n  getBoundingClientRect() {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        getBoundingClientRect\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.isFalse(isBeingConstructed(vm), `this.getBoundingClientRect() should not be called during the construction of the custom element for ${getComponentTag(vm)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`);\n    }\n\n    return getBoundingClientRect(elm);\n  },\n\n  querySelector(selectors) {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        querySelector\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.isFalse(isBeingConstructed(vm), `this.querySelector() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    }\n\n    return querySelector(elm, selectors);\n  },\n\n  querySelectorAll(selectors) {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        querySelectorAll\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.isFalse(isBeingConstructed(vm), `this.querySelectorAll() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    }\n\n    return querySelectorAll(elm, selectors);\n  },\n\n  getElementsByTagName(tagNameOrWildCard) {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        getElementsByTagName\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.isFalse(isBeingConstructed(vm), `this.getElementsByTagName() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    }\n\n    return getElementsByTagName(elm, tagNameOrWildCard);\n  },\n\n  getElementsByClassName(names) {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        getElementsByClassName\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.isFalse(isBeingConstructed(vm), `this.getElementsByClassName() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    }\n\n    return getElementsByClassName(elm, names);\n  },\n\n  get isConnected() {\n    const {\n      elm,\n      renderer: {\n        isConnected\n      }\n    } = getAssociatedVM(this);\n    return isConnected(elm);\n  },\n\n  get classList() {\n    const vm = getAssociatedVM(this);\n    const {\n      elm,\n      renderer: {\n        getClassList\n      }\n    } = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      // TODO [#1290]: this still fails in dev but works in production, eventually, we should\n      // just throw in all modes\n      assert$1.isFalse(isBeingConstructed(vm), `Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);\n    }\n\n    return getClassList(elm);\n  },\n\n  get template() {\n    const vm = getAssociatedVM(this);\n    return vm.cmpRoot;\n  },\n\n  get shadowRoot() {\n    // From within the component instance, the shadowRoot is always reported as \"closed\".\n    // Authors should rely on this.template instead.\n    return null;\n  },\n\n  render() {\n    const vm = getAssociatedVM(this);\n    return vm.def.template;\n  },\n\n  toString() {\n    const vm = getAssociatedVM(this);\n    return `[object ${vm.def.name}]`;\n  }\n\n};\nconst lightningBasedDescriptors = create$1(null);\n\nfor (const propName in HTMLElementOriginalDescriptors) {\n  lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);\n}\n\ndefineProperties$1(BaseLightningElementConstructor.prototype, lightningBasedDescriptors);\ndefineProperty$1(BaseLightningElementConstructor, 'CustomElementConstructor', {\n  get() {\n    // If required, a runtime-specific implementation must be defined.\n    throw new ReferenceError('The current runtime does not support CustomElementConstructor.');\n  },\n\n  configurable: true\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  patchLightningElementPrototypeWithRestrictions(BaseLightningElementConstructor.prototype);\n} // @ts-ignore\n\n\nconst BaseLightningElement = BaseLightningElementConstructor;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * @wire decorator to wire fields and methods to a wire adapter in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\n\nfunction wire(_adapter, _config) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.fail('@wire(adapter, config?) may only be used as a decorator.');\n  }\n\n  throw new Error();\n}\nfunction internalWireFieldDecorator(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n      componentValueObserved(vm, key);\n      return vm.cmpFields[key];\n    },\n\n    set(value) {\n      const vm = getAssociatedVM(this);\n      /**\n       * Reactivity for wired fields is provided in wiring.\n       * We intentionally add reactivity here since this is just\n       * letting the author to do the wrong thing, but it will keep our\n       * system to be backward compatible.\n       */\n\n      if (value !== vm.cmpFields[key]) {\n        vm.cmpFields[key] = value;\n        componentValueMutated(vm, key);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction track(target) {\n  if (arguments.length === 1) {\n    return reactiveMembrane.getProxy(target);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);\n  }\n\n  throw new Error();\n}\nfunction internalTrackDecorator(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n      componentValueObserved(vm, key);\n      return vm.cmpFields[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert$1.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n        assert$1.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n      }\n\n      const reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);\n\n      if (reactiveOrAnyValue !== vm.cmpFields[key]) {\n        vm.cmpFields[key] = reactiveOrAnyValue;\n        componentValueMutated(vm, key);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  assign: assign$1$1,\n  create: create$2,\n  defineProperties: defineProperties$1$1,\n  defineProperty: defineProperty$1$1,\n  freeze: freeze$1$1,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor$2,\n  getOwnPropertyNames: getOwnPropertyNames$2,\n  getPrototypeOf: getPrototypeOf$2,\n  hasOwnProperty: hasOwnProperty$2,\n  isFrozen: isFrozen$1$1,\n  keys: keys$1$1,\n  seal: seal$1$1,\n  setPrototypeOf: setPrototypeOf$1$1\n} = Object;\nconst {\n  filter: ArrayFilter$1$1,\n  find: ArrayFind$1$1,\n  indexOf: ArrayIndexOf$2,\n  join: ArrayJoin$1$1,\n  map: ArrayMap$2,\n  push: ArrayPush$3,\n  reduce: ArrayReduce$1$1,\n  reverse: ArrayReverse$1$1,\n  slice: ArraySlice$1$1,\n  splice: ArraySplice$2,\n  unshift: ArrayUnshift$1$1,\n  forEach: forEach$1$1\n} = Array.prototype;\nconst {\n  charCodeAt: StringCharCodeAt$1$1,\n  replace: StringReplace$1$1,\n  slice: StringSlice$1$1,\n  toLowerCase: StringToLowerCase$1$1\n} = String.prototype;\n\nfunction isUndefined$3(obj) {\n  return obj === undefined;\n}\n\nfunction isTrue$1$1$1(obj) {\n  return obj === true;\n}\n\nfunction isFalse$1$1$1(obj) {\n  return obj === false;\n}\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/**\n * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and\n * ariaGrabbed) are deprecated:\n * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes\n *\n * The above list of 46 aria attributes is consistent with the following resources:\n * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060\n * https://wicg.github.io/aom/spec/aria-reflection.html\n */\n\n\nconst AriaPropertyNames$1$1 = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];\nconst AttrNameToPropNameMap$1$1 = create$2(null);\nconst PropNameToAttrNameMap$1$1 = create$2(null); // Synthetic creation of all AOM property descriptors for Custom Elements\n\nforEach$1$1.call(AriaPropertyNames$1$1, propName => {\n  // Typescript infers the wrong function type for this particular overloaded method:\n  // https://github.com/Microsoft/TypeScript/issues/27972\n  // @ts-ignore type-mismatch\n  const attrName = StringToLowerCase$1$1.call(StringReplace$1$1.call(propName, /^aria/, 'aria-'));\n  AttrNameToPropNameMap$1$1[attrName] = propName;\n  PropNameToAttrNameMap$1$1[propName] = attrName;\n});\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Inspired from: https://mathiasbynens.be/notes/globalthis\n\nconst _globalThis$1$1 = function () {\n  // On recent browsers, `globalThis` is already defined. In this case return it directly.\n  if (typeof globalThis === 'object') {\n    return globalThis;\n  }\n\n  let _globalThis;\n\n  try {\n    // eslint-disable-next-line no-extend-native\n    Object.defineProperty(Object.prototype, '__magic__', {\n      get: function () {\n        return this;\n      },\n      configurable: true\n    }); // __magic__ is undefined in Safari 10 and IE10 and older.\n    // @ts-ignore\n    // eslint-disable-next-line no-undef\n\n    _globalThis = __magic__; // @ts-ignore\n\n    delete Object.prototype.__magic__;\n  } catch (ex) {// In IE8, Object.defineProperty only works on DOM objects.\n  } finally {\n    // If the magic above fails for some reason we assume that we are in a legacy browser.\n    // Assume `window` exists in this case.\n    if (typeof _globalThis === 'undefined') {\n      // @ts-ignore\n      _globalThis = window;\n    }\n  }\n\n  return _globalThis;\n}();\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// We use this to detect symbol support in order to avoid the expensive symbol polyfill. Note that\n// we can't use typeof since it will fail when transpiling.\n\n\nconst hasNativeSymbolSupport$1$1 = Symbol('x').toString() === 'Symbol(x)';\n/** version: 1.9.7 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nif (!_globalThis$1$1.lwcRuntimeFlags) {\n  Object.defineProperty(_globalThis$1$1, 'lwcRuntimeFlags', {\n    value: create$2(null)\n  });\n}\n\nconst runtimeFlags = _globalThis$1$1.lwcRuntimeFlags; // This function is not supported for use within components and is meant for\n// configuring runtime feature flags during app initialization.\n\nfunction setFeatureFlag(name, value) {\n  const isBoolean = isTrue$1$1$1(value) || isFalse$1$1$1(value);\n\n  if (!isBoolean) {\n    const message = `Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". Runtime feature flags can only be set to a boolean value.`;\n\n    if (process.env.NODE_ENV !== 'production') {\n      throw new TypeError(message);\n    } else {\n      // eslint-disable-next-line no-console\n      console.error(message);\n      return;\n    }\n  }\n\n  if (isUndefined$3(featureFlagLookup[name])) {\n    // eslint-disable-next-line no-console\n    console.warn(`Failed to set the value \"${value}\" for the runtime feature flag \"${name}\" because it is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`);\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Allow the same flag to be set more than once outside of production to enable testing\n    runtimeFlags[name] = value;\n  } else {\n    // Disallow the same flag to be set more than once in production\n    const runtimeValue = runtimeFlags[name];\n\n    if (!isUndefined$3(runtimeValue)) {\n      // eslint-disable-next-line no-console\n      console.error(`Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". \"${name}\" has already been set with the value \"${runtimeValue}\".`);\n      return;\n    }\n\n    Object.defineProperty(runtimeFlags, name, {\n      value\n    });\n  }\n} // This function is exposed to components to facilitate testing so we add a\n// check to make sure it is not invoked in production.\n\n\nfunction setFeatureFlagForTest(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    return setFeatureFlag(name, value);\n  }\n}\n\nconst featureFlagLookup = {\n  ENABLE_REACTIVE_SETTER: null,\n  ENABLE_HMR: null,\n  // Flags to toggle on/off the enforcement of shadow dom semantic in element/node outside lwc boundary when using synthetic shadow.\n  ENABLE_ELEMENT_PATCH: null,\n  ENABLE_NODE_LIST_PATCH: null,\n  ENABLE_HTML_COLLECTIONS_PATCH: null,\n  ENABLE_NODE_PATCH: null\n};\n/** version: 1.9.7 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction api() {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.fail(`@api decorator can only be used as a decorator function.`);\n  }\n\n  throw new Error();\n}\nfunction createPublicPropertyDescriptor(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n\n      if (isBeingConstructed(vm)) {\n        if (process.env.NODE_ENV !== 'production') {\n          logError(`Can’t read the value of property \\`${toString$1(key)}\\` from the constructor because the owner component hasn’t set the value yet. Instead, use the constructor to set a default value for the property.`, vm);\n        }\n\n        return;\n      }\n\n      componentValueObserved(vm, key);\n      return vm.cmpProps[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert$1.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n        assert$1.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n      }\n\n      vm.cmpProps[key] = newValue;\n      componentValueMutated(vm, key);\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\nclass AccessorReactiveObserver extends ReactiveObserver {\n  constructor(vm, set) {\n    super(() => {\n      if (isFalse$1$1(this.debouncing)) {\n        this.debouncing = true;\n        addCallbackToNextTick(() => {\n          if (isTrue$1$1(this.debouncing)) {\n            const {\n              value\n            } = this;\n            const {\n              isDirty: dirtyStateBeforeSetterCall,\n              component,\n              idx\n            } = vm;\n            set.call(component, value); // de-bouncing after the call to the original setter to prevent\n            // infinity loop if the setter itself is mutating things that\n            // were accessed during the previous invocation.\n\n            this.debouncing = false;\n\n            if (isTrue$1$1(vm.isDirty) && isFalse$1$1(dirtyStateBeforeSetterCall) && idx > 0) {\n              // immediate rehydration due to a setter driven mutation, otherwise\n              // the component will get rendered on the second tick, which it is not\n              // desirable.\n              rerenderVM(vm);\n            }\n          }\n        });\n      }\n    });\n    this.debouncing = false;\n  }\n\n  reset(value) {\n    super.reset();\n    this.debouncing = false;\n\n    if (arguments.length > 0) {\n      this.value = value;\n    }\n  }\n\n}\nfunction createPublicAccessorDescriptor(key, descriptor) {\n  const {\n    get,\n    set,\n    enumerable,\n    configurable\n  } = descriptor;\n\n  if (!isFunction$1(get)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.invariant(isFunction$1(get), `Invalid compiler output for public accessor ${toString$1(key)} decorated with @api`);\n    }\n\n    throw new Error();\n  }\n\n  return {\n    get() {\n      if (process.env.NODE_ENV !== 'production') {\n        // Assert that the this value is an actual Component with an associated VM.\n        getAssociatedVM(this);\n      }\n\n      return get.call(this);\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert$1.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n        assert$1.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n      }\n\n      if (set) {\n        if (runtimeFlags.ENABLE_REACTIVE_SETTER) {\n          let ro = vm.oar[key];\n\n          if (isUndefined$1(ro)) {\n            ro = vm.oar[key] = new AccessorReactiveObserver(vm, set);\n          } // every time we invoke this setter from outside (through this wrapper setter)\n          // we should reset the value and then debounce just in case there is a pending\n          // invocation the next tick that is not longer relevant since the value is changing\n          // from outside.\n\n\n          ro.reset(newValue);\n          ro.observe(() => {\n            set.call(this, newValue);\n          });\n        } else {\n          set.call(this, newValue);\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        assert$1.fail(`Invalid attempt to set a new value for property ${toString$1(key)} of ${vm} that does not has a setter decorated with @api.`);\n      }\n    },\n\n    enumerable,\n    configurable\n  };\n}\n\nfunction createObservedFieldPropertyDescriptor(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n      componentValueObserved(vm, key);\n      return vm.cmpFields[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (newValue !== vm.cmpFields[key]) {\n        vm.cmpFields[key] = newValue;\n        componentValueMutated(vm, key);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar PropType;\n\n(function (PropType) {\n  PropType[PropType[\"Field\"] = 0] = \"Field\";\n  PropType[PropType[\"Set\"] = 1] = \"Set\";\n  PropType[PropType[\"Get\"] = 2] = \"Get\";\n  PropType[PropType[\"GetSet\"] = 3] = \"GetSet\";\n})(PropType || (PropType = {}));\n\nfunction validateObservedField(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined$1(descriptor)) {\n      assert$1.fail(`Compiler Error: Invalid field ${fieldName} declaration.`);\n    }\n  }\n}\n\nfunction validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined$1(descriptor)) {\n      assert$1.fail(`Compiler Error: Invalid @track ${fieldName} declaration.`);\n    }\n  }\n}\n\nfunction validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined$1(descriptor)) {\n      assert$1.fail(`Compiler Error: Invalid @wire(...) ${fieldName} field declaration.`);\n    }\n  }\n}\n\nfunction validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse$1$1(descriptor.writable)) {\n      assert$1.fail(`Compiler Error: Invalid @wire(...) ${methodName} method declaration.`);\n    }\n  }\n}\n\nfunction validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined$1(descriptor)) {\n      assert$1.fail(`Compiler Error: Invalid @api ${fieldName} field declaration.`);\n    }\n  }\n}\n\nfunction validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined$1(descriptor)) {\n      assert$1.fail(`Compiler Error: Invalid @api get ${fieldName} accessor declaration.`);\n    } else if (isFunction$1(descriptor.set)) {\n      assert$1.isTrue(isFunction$1(descriptor.get), `Compiler Error: Missing getter for property ${toString$1(fieldName)} decorated with @api in ${Ctor}. You cannot have a setter without the corresponding getter.`);\n    } else if (!isFunction$1(descriptor.get)) {\n      assert$1.fail(`Compiler Error: Missing @api get ${fieldName} accessor declaration.`);\n    }\n  }\n}\n\nfunction validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse$1$1(descriptor.writable)) {\n      assert$1.fail(`Compiler Error: Invalid @api ${methodName} method declaration.`);\n    }\n  }\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by user-land code.\n */\n\n\nfunction registerDecorators(Ctor, meta) {\n  const proto = Ctor.prototype;\n  const {\n    publicProps,\n    publicMethods,\n    wire,\n    track,\n    fields\n  } = meta;\n  const apiMethods = create$1(null);\n  const apiFields = create$1(null);\n  const wiredMethods = create$1(null);\n  const wiredFields = create$1(null);\n  const observedFields = create$1(null);\n  const apiFieldsConfig = create$1(null);\n  let descriptor;\n\n  if (!isUndefined$1(publicProps)) {\n    for (const fieldName in publicProps) {\n      const propConfig = publicProps[fieldName];\n      apiFieldsConfig[fieldName] = propConfig.config;\n      descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n\n      if (propConfig.config > 0) {\n        // accessor declaration\n        if (process.env.NODE_ENV !== 'production') {\n          validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);\n        }\n\n        if (isUndefined$1(descriptor)) {\n          throw new Error();\n        }\n\n        descriptor = createPublicAccessorDescriptor(fieldName, descriptor);\n      } else {\n        // field declaration\n        if (process.env.NODE_ENV !== 'production') {\n          validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);\n        }\n\n        descriptor = createPublicPropertyDescriptor(fieldName);\n      }\n\n      apiFields[fieldName] = descriptor;\n      defineProperty$1(proto, fieldName, descriptor);\n    }\n  }\n\n  if (!isUndefined$1(publicMethods)) {\n    forEach$1.call(publicMethods, methodName => {\n      descriptor = getOwnPropertyDescriptor$1(proto, methodName);\n\n      if (process.env.NODE_ENV !== 'production') {\n        validateMethodDecoratedWithApi(Ctor, methodName, descriptor);\n      }\n\n      if (isUndefined$1(descriptor)) {\n        throw new Error();\n      }\n\n      apiMethods[methodName] = descriptor;\n    });\n  }\n\n  if (!isUndefined$1(wire)) {\n    for (const fieldOrMethodName in wire) {\n      const {\n        adapter,\n        method,\n        config: configCallback,\n        dynamic = []\n      } = wire[fieldOrMethodName];\n      descriptor = getOwnPropertyDescriptor$1(proto, fieldOrMethodName);\n\n      if (method === 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert$1.isTrue(adapter, `@wire on method \"${fieldOrMethodName}\": adapter id must be truthy.`);\n          validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n        }\n\n        if (isUndefined$1(descriptor)) {\n          throw new Error();\n        }\n\n        wiredMethods[fieldOrMethodName] = descriptor;\n        storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          assert$1.isTrue(adapter, `@wire on field \"${fieldOrMethodName}\": adapter id must be truthy.`);\n          validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n        }\n\n        descriptor = internalWireFieldDecorator(fieldOrMethodName);\n        wiredFields[fieldOrMethodName] = descriptor;\n        storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);\n        defineProperty$1(proto, fieldOrMethodName, descriptor);\n      }\n    }\n  }\n\n  if (!isUndefined$1(track)) {\n    for (const fieldName in track) {\n      descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n\n      if (process.env.NODE_ENV !== 'production') {\n        validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor);\n      }\n\n      descriptor = internalTrackDecorator(fieldName);\n      defineProperty$1(proto, fieldName, descriptor);\n    }\n  }\n\n  if (!isUndefined$1(fields)) {\n    for (let i = 0, n = fields.length; i < n; i++) {\n      const fieldName = fields[i];\n      descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n\n      if (process.env.NODE_ENV !== 'production') {\n        validateObservedField(Ctor, fieldName, descriptor);\n      }\n\n      observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);\n    }\n  }\n\n  setDecoratorsMeta(Ctor, {\n    apiMethods,\n    apiFields,\n    apiFieldsConfig,\n    wiredMethods,\n    wiredFields,\n    observedFields\n  });\n  return Ctor;\n}\nconst signedDecoratorToMetaMap = new Map();\n\nfunction setDecoratorsMeta(Ctor, meta) {\n  signedDecoratorToMetaMap.set(Ctor, meta);\n}\n\nconst defaultMeta = {\n  apiMethods: EmptyObject,\n  apiFields: EmptyObject,\n  apiFieldsConfig: EmptyObject,\n  wiredMethods: EmptyObject,\n  wiredFields: EmptyObject,\n  observedFields: EmptyObject\n};\nfunction getDecoratorsMeta(Ctor) {\n  const meta = signedDecoratorToMetaMap.get(Ctor);\n  return isUndefined$1(meta) ? defaultMeta : meta;\n}\n\nconst signedTemplateSet = new Set();\nfunction defaultEmptyTemplate() {\n  return [];\n}\nsignedTemplateSet.add(defaultEmptyTemplate);\nfunction isTemplateRegistered(tpl) {\n  return signedTemplateSet.has(tpl);\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\n\nfunction registerTemplate(tpl) {\n  signedTemplateSet.add(tpl); // chaining this method as a way to wrap existing\n  // assignment of templates easily, without too much transformation\n\n  return tpl;\n}\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker\n * Service and other similar libraries to sanitize vulnerable attributes.\n * This API is subject to change or being removed.\n */\n\nfunction sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {\n  // locker-service patches this function during runtime to sanitize vulnerable attributes.\n  // when ran off-core this function becomes a noop and returns the user authored value.\n  return attrValue;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// from the element instance, and get the value or set a new value on the component.\n// This means that across different elements, similar names can get the exact same\n// descriptor, so we can cache them:\n\nconst cachedGetterByKey = create$1(null);\nconst cachedSetterByKey = create$1(null);\n\nfunction createGetter(key) {\n  let fn = cachedGetterByKey[key];\n\n  if (isUndefined$1(fn)) {\n    fn = cachedGetterByKey[key] = function () {\n      const vm = getAssociatedVM(this);\n      const {\n        getHook\n      } = vm;\n      return getHook(vm.component, key);\n    };\n  }\n\n  return fn;\n}\n\nfunction createSetter(key) {\n  let fn = cachedSetterByKey[key];\n\n  if (isUndefined$1(fn)) {\n    fn = cachedSetterByKey[key] = function (newValue) {\n      const vm = getAssociatedVM(this);\n      const {\n        setHook\n      } = vm;\n      newValue = reactiveMembrane.getReadOnlyProxy(newValue);\n      setHook(vm.component, key, newValue);\n    };\n  }\n\n  return fn;\n}\n\nfunction createMethodCaller(methodName) {\n  return function () {\n    const vm = getAssociatedVM(this);\n    const {\n      callHook,\n      component\n    } = vm;\n    const fn = component[methodName];\n    return callHook(vm.component, fn, ArraySlice$2.call(arguments));\n  };\n}\n\nfunction createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback) {\n  return function attributeChangedCallback(attrName, oldValue, newValue) {\n    if (oldValue === newValue) {\n      // Ignore same values.\n      return;\n    }\n\n    const propName = attributeToPropMap[attrName];\n\n    if (isUndefined$1(propName)) {\n      if (!isUndefined$1(superAttributeChangedCallback)) {\n        // delegate unknown attributes to the super.\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        superAttributeChangedCallback.apply(this, arguments);\n      }\n\n      return;\n    }\n\n    if (!isAttributeLocked(this, attrName)) {\n      // Ignore changes triggered by the engine itself during:\n      // * diffing when public props are attempting to reflect to the DOM\n      // * component via `this.setAttribute()`, should never update the prop\n      // Both cases, the setAttribute call is always wrapped by the unlocking of the\n      // attribute to be changed\n      return;\n    } // Reflect attribute change to the corresponding property when changed from outside.\n\n\n    this[propName] = newValue;\n  };\n}\n\nfunction HTMLBridgeElementFactory(SuperClass, props, methods) {\n  let HTMLBridgeElement;\n  /**\n   * Modern browsers will have all Native Constructors as regular Classes\n   * and must be instantiated with the new keyword. In older browsers,\n   * specifically IE11, those are objects with a prototype property defined,\n   * since they are not supposed to be extended or instantiated with the\n   * new keyword. This forking logic supports both cases, specifically because\n   * wc.ts relies on the construction path of the bridges to create new\n   * fully qualifying web components.\n   */\n\n  if (isFunction$1(SuperClass)) {\n    HTMLBridgeElement = class extends SuperClass {};\n  } else {\n    HTMLBridgeElement = function () {\n      // Bridge classes are not supposed to be instantiated directly in\n      // browsers that do not support web components.\n      throw new TypeError('Illegal constructor');\n    }; // prototype inheritance dance\n\n\n    setPrototypeOf$1(HTMLBridgeElement, SuperClass);\n    setPrototypeOf$1(HTMLBridgeElement.prototype, SuperClass.prototype);\n    defineProperty$1(HTMLBridgeElement.prototype, 'constructor', {\n      writable: true,\n      configurable: true,\n      value: HTMLBridgeElement\n    });\n  } // generating the hash table for attributes to avoid duplicate fields and facilitate validation\n  // and false positives in case of inheritance.\n\n\n  const attributeToPropMap = create$1(null);\n  const {\n    attributeChangedCallback: superAttributeChangedCallback\n  } = SuperClass.prototype;\n  const {\n    observedAttributes: superObservedAttributes = []\n  } = SuperClass;\n  const descriptors = create$1(null); // expose getters and setters for each public props on the new Element Bridge\n\n  for (let i = 0, len = props.length; i < len; i += 1) {\n    const propName = props[i];\n    attributeToPropMap[htmlPropertyToAttribute$1(propName)] = propName;\n    descriptors[propName] = {\n      get: createGetter(propName),\n      set: createSetter(propName),\n      enumerable: true,\n      configurable: true\n    };\n  } // expose public methods as props on the new Element Bridge\n\n\n  for (let i = 0, len = methods.length; i < len; i += 1) {\n    const methodName = methods[i];\n    descriptors[methodName] = {\n      value: createMethodCaller(methodName),\n      writable: true,\n      configurable: true\n    };\n  } // creating a new attributeChangedCallback per bridge because they are bound to the corresponding\n  // map of attributes to props. We do this after all other props and methods to avoid the possibility\n  // of getting overrule by a class declaration in user-land, and we make it non-writable, non-configurable\n  // to preserve this definition.\n\n\n  descriptors.attributeChangedCallback = {\n    value: createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback)\n  }; // Specify attributes for which we want to reflect changes back to their corresponding\n  // properties via attributeChangedCallback.\n\n  defineProperty$1(HTMLBridgeElement, 'observedAttributes', {\n    get() {\n      return [...superObservedAttributes, ...keys$1(attributeToPropMap)];\n    }\n\n  });\n  defineProperties$1(HTMLBridgeElement.prototype, descriptors);\n  return HTMLBridgeElement;\n}\nconst BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor, getOwnPropertyNames$1(HTMLElementOriginalDescriptors), []);\nfreeze$1(BaseBridgeElement);\nseal$1(BaseBridgeElement.prototype);\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction resolveCircularModuleDependency(fn) {\n  return fn();\n}\nfunction isCircularModuleDependency(obj) {\n  return isFunction$1(obj) && hasOwnProperty$1.call(obj, '__circular__');\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst swappedTemplateMap = new WeakMap();\nconst swappedComponentMap = new WeakMap();\nconst swappedStyleMap = new WeakMap();\nconst activeTemplates = new WeakMap();\nconst activeComponents = new WeakMap();\nconst activeStyles = new WeakMap();\n\nfunction rehydrateHotTemplate(tpl) {\n  const list = activeTemplates.get(tpl);\n\n  if (!isUndefined$1(list)) {\n    list.forEach(vm => {\n      if (isFalse$1$1(vm.isDirty)) {\n        // forcing the vm to rehydrate in the micro-task:\n        markComponentAsDirty(vm);\n        scheduleRehydration(vm);\n      }\n    }); // resetting the Set to release the memory of those vm references\n    // since they are not longer related to this template, instead\n    // they will get re-associated once these instances are rehydrated.\n\n    list.clear();\n  }\n\n  return true;\n}\n\nfunction rehydrateHotStyle(style) {\n  const list = activeStyles.get(style);\n\n  if (!isUndefined$1(list)) {\n    list.forEach(vm => {\n      // if a style definition is swapped, we must reset\n      // vm's template content in the next micro-task:\n      forceRehydration(vm);\n    }); // resetting the Set to release the memory of those vm references\n    // since they are not longer related to this style, instead\n    // they will get re-associated once these instances are rehydrated.\n\n    list.clear();\n  }\n\n  return true;\n}\n\nfunction rehydrateHotComponent(Ctor) {\n  const list = activeComponents.get(Ctor);\n  let canRefreshAllInstances = true;\n\n  if (!isUndefined$1(list)) {\n    list.forEach(vm => {\n      const {\n        owner\n      } = vm;\n\n      if (!isNull$1(owner)) {\n        // if a component class definition is swapped, we must reset\n        // owner's template content in the next micro-task:\n        forceRehydration(owner);\n      } else {\n        // the hot swapping for components only work for instances of components\n        // created from a template, root elements can't be swapped because we\n        // don't have a way to force the creation of the element with the same state\n        // of the current element.\n        // Instead, we can report the problem to the caller so it can take action,\n        // for example: reload the entire page.\n        canRefreshAllInstances = false;\n      }\n    }); // resetting the Set to release the memory of those vm references\n    // since they are not longer related to this constructor, instead\n    // they will get re-associated once these instances are rehydrated.\n\n    list.clear();\n  }\n\n  return canRefreshAllInstances;\n}\n\nfunction flattenStylesheets(stylesheets) {\n  const list = [];\n\n  for (const stylesheet of stylesheets) {\n    if (!Array.isArray(stylesheet)) {\n      list.push(stylesheet);\n    } else {\n      list.push(...flattenStylesheets(stylesheet));\n    }\n  }\n\n  return list;\n}\n\nfunction getTemplateOrSwappedTemplate(tpl) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  if (runtimeFlags.ENABLE_HMR) {\n    const visited = new Set();\n\n    while (swappedTemplateMap.has(tpl) && !visited.has(tpl)) {\n      visited.add(tpl);\n      tpl = swappedTemplateMap.get(tpl);\n    }\n  }\n\n  return tpl;\n}\nfunction getComponentOrSwappedComponent(Ctor) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  if (runtimeFlags.ENABLE_HMR) {\n    const visited = new Set();\n\n    while (swappedComponentMap.has(Ctor) && !visited.has(Ctor)) {\n      visited.add(Ctor);\n      Ctor = swappedComponentMap.get(Ctor);\n    }\n  }\n\n  return Ctor;\n}\nfunction getStyleOrSwappedStyle(style) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  if (runtimeFlags.ENABLE_HMR) {\n    const visited = new Set();\n\n    while (swappedStyleMap.has(style) && !visited.has(style)) {\n      visited.add(style);\n      style = swappedStyleMap.get(style);\n    }\n  }\n\n  return style;\n}\nfunction setActiveVM(vm) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  if (runtimeFlags.ENABLE_HMR) {\n    // tracking active component\n    const Ctor = vm.def.ctor;\n    let componentVMs = activeComponents.get(Ctor);\n\n    if (isUndefined$1(componentVMs)) {\n      componentVMs = new Set();\n      activeComponents.set(Ctor, componentVMs);\n    } // this will allow us to keep track of the hot components\n\n\n    componentVMs.add(vm); // tracking active template\n\n    const tpl = vm.cmpTemplate;\n\n    if (tpl) {\n      let templateVMs = activeTemplates.get(tpl);\n\n      if (isUndefined$1(templateVMs)) {\n        templateVMs = new Set();\n        activeTemplates.set(tpl, templateVMs);\n      } // this will allow us to keep track of the templates that are\n      // being used by a hot component\n\n\n      templateVMs.add(vm); // tracking active styles associated to template\n\n      const stylesheets = tpl.stylesheets;\n\n      if (!isUndefined$1(stylesheets)) {\n        flattenStylesheets(stylesheets).forEach(stylesheet => {\n          // this is necessary because we don't hold the list of styles\n          // in the vm, we only hold the selected (already swapped template)\n          // but the styles attached to the template might not be the actual\n          // active ones, but the swapped versions of those.\n          stylesheet = getStyleOrSwappedStyle(stylesheet);\n          let stylesheetVMs = activeStyles.get(stylesheet);\n\n          if (isUndefined$1(stylesheetVMs)) {\n            stylesheetVMs = new Set();\n            activeStyles.set(stylesheet, stylesheetVMs);\n          } // this will allow us to keep track of the stylesheet that are\n          // being used by a hot component\n\n\n          stylesheetVMs.add(vm);\n        });\n      }\n    }\n  }\n}\nfunction removeActiveVM(vm) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  if (runtimeFlags.ENABLE_HMR) {\n    // tracking inactive component\n    const Ctor = vm.def.ctor;\n    let list = activeComponents.get(Ctor);\n\n    if (!isUndefined$1(list)) {\n      // deleting the vm from the set to avoid leaking memory\n      list.delete(vm);\n    } // removing inactive template\n\n\n    const tpl = vm.cmpTemplate;\n\n    if (tpl) {\n      list = activeTemplates.get(tpl);\n\n      if (!isUndefined$1(list)) {\n        // deleting the vm from the set to avoid leaking memory\n        list.delete(vm);\n      } // removing active styles associated to template\n\n\n      const styles = tpl.stylesheets;\n\n      if (!isUndefined$1(styles)) {\n        flattenStylesheets(styles).forEach(style => {\n          list = activeStyles.get(style);\n\n          if (!isUndefined$1(list)) {\n            // deleting the vm from the set to avoid leaking memory\n            list.delete(vm);\n          }\n        });\n      }\n    }\n  }\n}\nfunction swapTemplate(oldTpl, newTpl) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isTemplateRegistered(oldTpl) && isTemplateRegistered(newTpl)) {\n      swappedTemplateMap.set(oldTpl, newTpl);\n      return rehydrateHotTemplate(oldTpl);\n    } else {\n      throw new TypeError(`Invalid Template`);\n    }\n  }\n\n  if (!runtimeFlags.ENABLE_HMR) {\n    throw new Error('HMR is not enabled');\n  }\n\n  return false;\n}\nfunction swapComponent(oldComponent, newComponent) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isComponentConstructor(oldComponent) && isComponentConstructor(newComponent)) {\n      swappedComponentMap.set(oldComponent, newComponent);\n      return rehydrateHotComponent(oldComponent);\n    } else {\n      throw new TypeError(`Invalid Component`);\n    }\n  }\n\n  if (!runtimeFlags.ENABLE_HMR) {\n    throw new Error('HMR is not enabled');\n  }\n\n  return false;\n}\nfunction swapStyle(oldStyle, newStyle) {\n  if (process.env.NODE_ENV !== 'production') {\n    // TODO [#1887]: once the support for registering styles is implemented\n    // we can add the validation of both styles around this block.\n    swappedStyleMap.set(oldStyle, newStyle);\n    return rehydrateHotStyle(oldStyle);\n  }\n\n  if (!runtimeFlags.ENABLE_HMR) {\n    throw new Error('HMR is not enabled');\n  }\n\n  return false;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CtorToDefMap = new WeakMap();\n\nfunction getCtorProto(Ctor) {\n  let proto = getPrototypeOf$1(Ctor);\n\n  if (isNull$1(proto)) {\n    throw new ReferenceError(`Invalid prototype chain for ${Ctor.name}, you must extend LightningElement.`);\n  } // covering the cases where the ref is circular in AMD\n\n\n  if (isCircularModuleDependency(proto)) {\n    const p = resolveCircularModuleDependency(proto);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isNull$1(p)) {\n        throw new ReferenceError(`Circular module dependency for ${Ctor.name}, must resolve to a constructor that extends LightningElement.`);\n      }\n    } // escape hatch for Locker and other abstractions to provide their own base class instead\n    // of our Base class without having to leak it to user-land. If the circular function returns\n    // itself, that's the signal that we have hit the end of the proto chain, which must always\n    // be base.\n\n\n    proto = p === proto ? BaseLightningElement : p;\n  }\n\n  return proto;\n}\n\nfunction createComponentDef(Ctor) {\n  if (process.env.NODE_ENV !== 'production') {\n    const ctorName = Ctor.name; // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.\n    // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a \"name\" property with string value, but found ${ctorName}.`);\n\n    assert$1.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a \"constructor\" property.`);\n  }\n\n  const decoratorsMeta = getDecoratorsMeta(Ctor);\n  const {\n    apiFields,\n    apiFieldsConfig,\n    apiMethods,\n    wiredFields,\n    wiredMethods,\n    observedFields\n  } = decoratorsMeta;\n  const proto = Ctor.prototype;\n  let {\n    connectedCallback,\n    disconnectedCallback,\n    renderedCallback,\n    errorCallback,\n    render\n  } = proto;\n  const superProto = getCtorProto(Ctor);\n  const superDef = superProto !== BaseLightningElement ? getComponentInternalDef(superProto) : lightingElementDef;\n  const bridge = HTMLBridgeElementFactory(superDef.bridge, keys$1(apiFields), keys$1(apiMethods));\n  const props = assign$1(create$1(null), superDef.props, apiFields);\n  const propsConfig = assign$1(create$1(null), superDef.propsConfig, apiFieldsConfig);\n  const methods = assign$1(create$1(null), superDef.methods, apiMethods);\n  const wire = assign$1(create$1(null), superDef.wire, wiredFields, wiredMethods);\n  connectedCallback = connectedCallback || superDef.connectedCallback;\n  disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;\n  renderedCallback = renderedCallback || superDef.renderedCallback;\n  errorCallback = errorCallback || superDef.errorCallback;\n  render = render || superDef.render;\n  const template = getComponentRegisteredTemplate(Ctor) || superDef.template;\n  const name = Ctor.name || superDef.name; // installing observed fields into the prototype.\n\n  defineProperties$1(proto, observedFields);\n  const def = {\n    ctor: Ctor,\n    name,\n    wire,\n    props,\n    propsConfig,\n    methods,\n    bridge,\n    template,\n    connectedCallback,\n    disconnectedCallback,\n    renderedCallback,\n    errorCallback,\n    render\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    freeze$1(Ctor.prototype);\n  }\n\n  return def;\n}\n/**\n * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is\n * subject to change or being removed.\n */\n\n\nfunction isComponentConstructor(ctor) {\n  if (!isFunction$1(ctor)) {\n    return false;\n  } // Fast path: LightningElement is part of the prototype chain of the constructor.\n\n\n  if (ctor.prototype instanceof BaseLightningElement) {\n    return true;\n  } // Slow path: LightningElement is not part of the prototype chain of the constructor, we need\n  // climb up the constructor prototype chain to check in case there are circular dependencies\n  // to resolve.\n\n\n  let current = ctor;\n\n  do {\n    if (isCircularModuleDependency(current)) {\n      const circularResolved = resolveCircularModuleDependency(current); // If the circular function returns itself, that's the signal that we have hit the end\n      // of the proto chain, which must always be a valid base constructor.\n\n      if (circularResolved === current) {\n        return true;\n      }\n\n      current = circularResolved;\n    }\n\n    if (current === BaseLightningElement) {\n      return true;\n    }\n  } while (!isNull$1(current) && (current = getPrototypeOf$1(current))); // Finally return false if the LightningElement is not part of the prototype chain.\n\n\n  return false;\n}\nfunction getComponentInternalDef(Ctor) {\n  if (process.env.NODE_ENV !== 'production') {\n    Ctor = getComponentOrSwappedComponent(Ctor);\n  }\n\n  let def = CtorToDefMap.get(Ctor);\n\n  if (isUndefined$1(def)) {\n    if (isCircularModuleDependency(Ctor)) {\n      const resolvedCtor = resolveCircularModuleDependency(Ctor);\n      def = getComponentInternalDef(resolvedCtor); // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,\n      // look up the definition in cache instead of re-resolving and recreating the def.\n\n      CtorToDefMap.set(Ctor, def);\n      return def;\n    }\n\n    if (!isComponentConstructor(Ctor)) {\n      throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.`);\n    }\n\n    def = createComponentDef(Ctor);\n    CtorToDefMap.set(Ctor, def);\n  }\n\n  return def;\n}\nconst lightingElementDef = {\n  ctor: BaseLightningElement,\n  name: BaseLightningElement.name,\n  props: lightningBasedDescriptors,\n  propsConfig: EmptyObject,\n  methods: EmptyObject,\n  wire: EmptyObject,\n  bridge: BaseBridgeElement,\n  template: defaultEmptyTemplate,\n  render: BaseLightningElement.prototype.render\n};\nvar PropDefType;\n\n(function (PropDefType) {\n  PropDefType[\"any\"] = \"any\";\n})(PropDefType || (PropDefType = {}));\n/**\n * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is\n * subject to change or being removed.\n */\n\n\nfunction getComponentDef(Ctor) {\n  const def = getComponentInternalDef(Ctor); // From the internal def object, we need to extract the info that is useful\n  // for some external services, e.g.: Locker Service, usually, all they care\n  // is about the shape of the constructor, the internals of it are not relevant\n  // because they don't have a way to mess with that.\n\n  const {\n    ctor,\n    name,\n    props,\n    propsConfig,\n    methods\n  } = def;\n  const publicProps = {};\n\n  for (const key in props) {\n    // avoid leaking the reference to the public props descriptors\n    publicProps[key] = {\n      config: propsConfig[key] || 0,\n      type: PropDefType.any,\n      attr: htmlPropertyToAttribute$1(key)\n    };\n  }\n\n  const publicMethods = {};\n\n  for (const key in methods) {\n    // avoid leaking the reference to the public method descriptors\n    publicMethods[key] = methods[key].value;\n  }\n\n  return {\n    ctor,\n    name,\n    props: publicProps,\n    methods: publicMethods\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst noop = () => void 0;\n\nfunction observeElementChildNodes(elm) {\n  elm.$domManual$ = true;\n}\n\nfunction setElementShadowToken(elm, token) {\n  elm.$shadowToken$ = token;\n}\n\nfunction updateNodeHook(oldVnode, vnode) {\n  const {\n    elm,\n    text,\n    owner: {\n      renderer\n    }\n  } = vnode;\n\n  if (oldVnode.text !== text) {\n    if (process.env.NODE_ENV !== 'production') {\n      unlockDomMutation();\n    }\n\n    renderer.setText(elm, text);\n\n    if (process.env.NODE_ENV !== 'production') {\n      lockDomMutation();\n    }\n  }\n}\nfunction insertNodeHook(vnode, parentNode, referenceNode) {\n  const {\n    renderer\n  } = vnode.owner;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unlockDomMutation();\n  }\n\n  renderer.insert(vnode.elm, parentNode, referenceNode);\n\n  if (process.env.NODE_ENV !== 'production') {\n    lockDomMutation();\n  }\n}\nfunction removeNodeHook(vnode, parentNode) {\n  const {\n    renderer\n  } = vnode.owner;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unlockDomMutation();\n  }\n\n  renderer.remove(vnode.elm, parentNode);\n\n  if (process.env.NODE_ENV !== 'production') {\n    lockDomMutation();\n  }\n}\nfunction createElmHook(vnode) {\n  modEvents.create(vnode); // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n\n  modAttrs.create(vnode);\n  modProps.create(vnode);\n  modStaticClassName.create(vnode);\n  modStaticStyle.create(vnode);\n  modComputedClassName.create(vnode);\n  modComputedStyle.create(vnode);\n}\nvar LWCDOMMode;\n\n(function (LWCDOMMode) {\n  LWCDOMMode[\"manual\"] = \"manual\";\n})(LWCDOMMode || (LWCDOMMode = {}));\n\nfunction fallbackElmHook(elm, vnode) {\n  const {\n    owner\n  } = vnode;\n\n  if (isTrue$1$1(owner.renderer.syntheticShadow)) {\n    const {\n      data: {\n        context\n      }\n    } = vnode;\n    const {\n      shadowAttribute\n    } = owner.context;\n\n    if (!isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === LWCDOMMode.manual) {\n      // this element will now accept any manual content inserted into it\n      observeElementChildNodes(elm);\n    } // when running in synthetic shadow mode, we need to set the shadowToken value\n    // into each element from the template, so they can be styled accordingly.\n\n\n    setElementShadowToken(elm, shadowAttribute);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    const {\n      data: {\n        context\n      }\n    } = vnode;\n    const isPortal = !isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === LWCDOMMode.manual;\n    patchElementWithRestrictions(elm, {\n      isPortal\n    });\n  }\n}\nfunction updateElmHook(oldVnode, vnode) {\n  // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n  modAttrs.update(oldVnode, vnode);\n  modProps.update(oldVnode, vnode);\n  modComputedClassName.update(oldVnode, vnode);\n  modComputedStyle.update(oldVnode, vnode);\n}\nfunction updateChildrenHook(oldVnode, vnode) {\n  const {\n    children,\n    owner\n  } = vnode;\n  const fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;\n  runWithBoundaryProtection(owner, owner.owner, noop, () => {\n    fn(vnode.elm, oldVnode.children, children);\n  }, noop);\n}\nfunction allocateChildrenHook(vnode, vm) {\n  // A component with slots will re-render because:\n  // 1- There is a change of the internal state.\n  // 2- There is a change on the external api (ex: slots)\n  //\n  // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the\n  // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children\n  // in a reused VCustomElement, there won't be any slotted children.\n  // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.\n  //\n  // In case #2, we will always get a fresh VCustomElement.\n  const children = vnode.aChildren || vnode.children;\n  vm.aChildren = children;\n\n  if (isTrue$1$1(vm.renderer.syntheticShadow)) {\n    // slow path\n    allocateInSlot(vm, children); // save the allocated children in case this vnode is reused.\n\n    vnode.aChildren = children; // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!\n\n    vnode.children = EmptyArray;\n  }\n}\nfunction createViewModelHook(elm, vnode) {\n  if (!isUndefined$1(getAssociatedVMIfPresent(elm))) {\n    // There is a possibility that a custom element is registered under tagName,\n    // in which case, the initialization is already carry on, and there is nothing else\n    // to do here since this hook is called right after invoking `document.createElement`.\n    return;\n  }\n\n  const {\n    sel,\n    mode,\n    ctor,\n    owner\n  } = vnode;\n  const def = getComponentInternalDef(ctor);\n\n  if (isTrue$1$1(owner.renderer.syntheticShadow)) {\n    const {\n      shadowAttribute\n    } = owner.context; // when running in synthetic shadow mode, we need to set the shadowToken value\n    // into each element from the template, so they can be styled accordingly.\n\n    setElementShadowToken(elm, shadowAttribute);\n  }\n\n  createVM(elm, def, {\n    mode,\n    owner,\n    tagName: sel,\n    renderer: owner.renderer\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isArray$2(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n  }\n}\nfunction createCustomElmHook(vnode) {\n  modEvents.create(vnode); // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n\n  modAttrs.create(vnode);\n  modProps.create(vnode);\n  modStaticClassName.create(vnode);\n  modStaticStyle.create(vnode);\n  modComputedClassName.create(vnode);\n  modComputedStyle.create(vnode);\n}\nfunction createChildrenHook(vnode) {\n  const {\n    elm,\n    children\n  } = vnode;\n\n  for (let j = 0; j < children.length; ++j) {\n    const ch = children[j];\n\n    if (ch != null) {\n      ch.hook.create(ch);\n      ch.hook.insert(ch, elm, null);\n    }\n  }\n}\nfunction updateCustomElmHook(oldVnode, vnode) {\n  // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n  modAttrs.update(oldVnode, vnode);\n  modProps.update(oldVnode, vnode);\n  modComputedClassName.update(oldVnode, vnode);\n  modComputedStyle.update(oldVnode, vnode);\n}\nfunction removeElmHook(vnode) {\n  // this method only needs to search on child vnodes from template\n  // to trigger the remove hook just in case some of those children\n  // are custom elements.\n  const {\n    children,\n    elm\n  } = vnode;\n\n  for (let j = 0, len = children.length; j < len; ++j) {\n    const ch = children[j];\n\n    if (!isNull$1(ch)) {\n      ch.hook.remove(ch, elm);\n    }\n  }\n} // Using a WeakMap instead of a WeakSet because this one works in IE11 :(\n\nconst FromIteration = new WeakMap(); // dynamic children means it was generated by an iteration\n// in a template, and will require a more complex diffing algo.\n\nfunction markAsDynamicChildren(children) {\n  FromIteration.set(children, 1);\n}\nfunction hasDynamicChildren(children) {\n  return FromIteration.has(children);\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getUpgradableConstructor(tagName, renderer) {\n  // Should never get a tag with upper case letter at this point, the compiler should\n  // produce only tags with lowercase letters\n  // But, for backwards compatibility, we will lower case the tagName\n  tagName = tagName.toLowerCase();\n  let CE = renderer.getCustomElement(tagName);\n\n  if (!isUndefined$1(CE)) {\n    return CE;\n  }\n  /**\n   * LWC Upgradable Element reference to an element that was created\n   * via the scoped registry mechanism, and that is ready to be upgraded.\n   */\n\n\n  CE = class LWCUpgradableElement extends renderer.HTMLElement {\n    constructor(upgradeCallback) {\n      super();\n\n      if (isFunction$1(upgradeCallback)) {\n        upgradeCallback(this); // nothing to do with the result for now\n      }\n    }\n\n  };\n  renderer.defineCustomElement(tagName, CE);\n  return CE;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CHAR_S = 115;\nconst CHAR_V = 118;\nconst CHAR_G = 103;\nconst NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';\nconst SymbolIterator = Symbol.iterator;\nconst TextHook = {\n  create: vnode => {\n    const {\n      renderer\n    } = vnode.owner;\n    const elm = renderer.createText(vnode.text);\n    linkNodeToShadow(elm, vnode);\n    vnode.elm = elm;\n  },\n  update: updateNodeHook,\n  insert: insertNodeHook,\n  move: insertNodeHook,\n  remove: removeNodeHook\n}; // insert is called after update, which is used somewhere else (via a module)\n// to mark the vm as inserted, that means we cannot use update as the main channel\n// to rehydrate when dirty, because sometimes the element is not inserted just yet,\n// which breaks some invariants. For that reason, we have the following for any\n// Custom Element that is inserted via a template.\n\nconst ElementHook = {\n  create: vnode => {\n    const {\n      sel,\n      data: {\n        ns\n      },\n      owner: {\n        renderer\n      }\n    } = vnode;\n    const elm = renderer.createElement(sel, ns);\n    linkNodeToShadow(elm, vnode);\n    fallbackElmHook(elm, vnode);\n    vnode.elm = elm;\n    createElmHook(vnode);\n  },\n  update: (oldVnode, vnode) => {\n    updateElmHook(oldVnode, vnode);\n    updateChildrenHook(oldVnode, vnode);\n  },\n  insert: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n    createChildrenHook(vnode);\n  },\n  move: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n  },\n  remove: (vnode, parentNode) => {\n    removeNodeHook(vnode, parentNode);\n    removeElmHook(vnode);\n  }\n};\nconst CustomElementHook = {\n  create: vnode => {\n    const {\n      sel,\n      owner: {\n        renderer\n      }\n    } = vnode;\n    const UpgradableConstructor = getUpgradableConstructor(sel, renderer);\n    /**\n     * Note: if the upgradable constructor does not expect, or throw when we new it\n     * with a callback as the first argument, we could implement a more advanced\n     * mechanism that only passes that argument if the constructor is known to be\n     * an upgradable custom element.\n     */\n\n    const elm = new UpgradableConstructor(elm => {\n      // the custom element from the registry is expecting an upgrade callback\n      createViewModelHook(elm, vnode);\n    });\n    vnode.elm = elm;\n    linkNodeToShadow(elm, vnode);\n    const vm = getAssociatedVMIfPresent(elm);\n\n    if (vm) {\n      allocateChildrenHook(vnode, vm);\n    } else if (vnode.ctor !== UpgradableConstructor) {\n      throw new TypeError(`Incorrect Component Constructor`);\n    }\n\n    createCustomElmHook(vnode);\n  },\n  update: (oldVnode, vnode) => {\n    updateCustomElmHook(oldVnode, vnode);\n    const vm = getAssociatedVMIfPresent(vnode.elm);\n\n    if (vm) {\n      // in fallback mode, the allocation will always set children to\n      // empty and delegate the real allocation to the slot elements\n      allocateChildrenHook(vnode, vm);\n    } // in fallback mode, the children will be always empty, so, nothing\n    // will happen, but in native, it does allocate the light dom\n\n\n    updateChildrenHook(oldVnode, vnode);\n\n    if (vm) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert$1.isTrue(isArray$2(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n      } // this will probably update the shadowRoot, but only if the vm is in a dirty state\n      // this is important to preserve the top to bottom synchronous rendering phase.\n\n\n      rerenderVM(vm);\n    }\n  },\n  insert: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n    const vm = getAssociatedVMIfPresent(vnode.elm);\n\n    if (vm) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert$1.isTrue(vm.state === VMState.created, `${vm} cannot be recycled.`);\n      }\n\n      runConnectedCallback(vm);\n    }\n\n    createChildrenHook(vnode);\n\n    if (vm) {\n      appendVM(vm);\n    }\n  },\n  move: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n  },\n  remove: (vnode, parentNode) => {\n    removeNodeHook(vnode, parentNode);\n    const vm = getAssociatedVMIfPresent(vnode.elm);\n\n    if (vm) {\n      // for custom elements we don't have to go recursively because the removeVM routine\n      // will take care of disconnecting any child VM attached to its shadow as well.\n      removeVM(vm);\n    }\n  }\n};\n\nfunction linkNodeToShadow(elm, vnode) {\n  // TODO [#1164]: this should eventually be done by the polyfill directly\n  elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;\n} // TODO [#1136]: this should be done by the compiler, adding ns to every sub-element\n\n\nfunction addNS(vnode) {\n  const {\n    data,\n    children,\n    sel\n  } = vnode;\n  data.ns = NamespaceAttributeForSVG; // TODO [#1275]: review why `sel` equal `foreignObject` should get this `ns`\n\n  if (isArray$2(children) && sel !== 'foreignObject') {\n    for (let j = 0, n = children.length; j < n; ++j) {\n      const childNode = children[j];\n\n      if (childNode != null && childNode.hook === ElementHook) {\n        addNS(childNode);\n      }\n    }\n  }\n}\n\nfunction addVNodeToChildLWC(vnode) {\n  ArrayPush$1.call(getVMBeingRendered().velements, vnode);\n} // [h]tml node\n\n\nfunction h(sel, data, children) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isString(sel), `h() 1st argument sel must be a string.`);\n    assert$1.isTrue(isObject$2(data), `h() 2nd argument data must be an object.`);\n    assert$1.isTrue(isArray$2(children), `h() 3rd argument children must be an array.`);\n    assert$1.isTrue('key' in data, ` <${sel}> \"key\" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`); // checking reserved internal data properties\n\n    assert$1.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n    assert$1.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n\n    if (data.style && !isString(data.style)) {\n      logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n    }\n\n    forEach$1.call(children, childVnode => {\n      if (childVnode != null) {\n        assert$1.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, `${childVnode} is not a vnode.`);\n      }\n    });\n  }\n\n  const {\n    key\n  } = data;\n  let text, elm;\n  const vnode = {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: ElementHook,\n    owner: vmBeingRendered\n  };\n\n  if (sel.length === 3 && StringCharCodeAt$1.call(sel, 0) === CHAR_S && StringCharCodeAt$1.call(sel, 1) === CHAR_V && StringCharCodeAt$1.call(sel, 2) === CHAR_G) {\n    addNS(vnode);\n  }\n\n  return vnode;\n} // [t]ab[i]ndex function\n\nfunction ti(value) {\n  // if value is greater than 0, we normalize to 0\n  // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through\n  // If value is less than -1, we don't care\n  const shouldNormalize = value > 0 && !(isTrue$1$1(value) || isFalse$1$1(value));\n\n  if (process.env.NODE_ENV !== 'production') {\n    const vmBeingRendered = getVMBeingRendered();\n\n    if (shouldNormalize) {\n      logError(`Invalid tabindex value \\`${toString$1(value)}\\` in template for ${vmBeingRendered}. This attribute must be set to 0 or -1.`, vmBeingRendered);\n    }\n  }\n\n  return shouldNormalize ? 0 : value;\n} // [s]lot element node\n\nfunction s(slotName, data, children, slotset) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isString(slotName), `s() 1st argument slotName must be a string.`);\n    assert$1.isTrue(isObject$2(data), `s() 2nd argument data must be an object.`);\n    assert$1.isTrue(isArray$2(children), `h() 3rd argument children must be an array.`);\n  }\n\n  if (!isUndefined$1(slotset) && !isUndefined$1(slotset[slotName]) && slotset[slotName].length !== 0) {\n    children = slotset[slotName];\n  }\n\n  const vnode = h('slot', data, children);\n\n  if (vnode.owner.renderer.syntheticShadow) {\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(children);\n  }\n\n  return vnode;\n} // [c]ustom element node\n\nfunction c(sel, Ctor, data, children = EmptyArray) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isString(sel), `c() 1st argument sel must be a string.`);\n    assert$1.isTrue(isFunction$1(Ctor), `c() 2nd argument Ctor must be a function.`);\n    assert$1.isTrue(isObject$2(data), `c() 3nd argument data must be an object.`);\n    assert$1.isTrue(arguments.length === 3 || isArray$2(children), `c() 4nd argument data must be an array.`); // checking reserved internal data properties\n\n    assert$1.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n    assert$1.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n\n    if (data.style && !isString(data.style)) {\n      logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n    }\n\n    if (arguments.length === 4) {\n      forEach$1.call(children, childVnode => {\n        if (childVnode != null) {\n          assert$1.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, `${childVnode} is not a vnode.`);\n        }\n      });\n    }\n  }\n\n  const {\n    key\n  } = data;\n  let text, elm;\n  const vnode = {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: CustomElementHook,\n    ctor: Ctor,\n    owner: vmBeingRendered,\n    mode: 'open'\n  };\n  addVNodeToChildLWC(vnode);\n  return vnode;\n} // [i]terable node\n\nfunction i(iterable, factory) {\n  const list = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n\n  sc(list);\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined$1(iterable) || iterable === null) {\n    if (process.env.NODE_ENV !== 'production') {\n      logError(`Invalid template iteration for value \"${toString$1(iterable)}\" in ${vmBeingRendered}. It must be an Array or an iterable Object.`, vmBeingRendered);\n    }\n\n    return list;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isFalse(isUndefined$1(iterable[SymbolIterator]), `Invalid template iteration for value \\`${toString$1(iterable)}\\` in ${vmBeingRendered}. It must be an array-like object and not \\`null\\` nor \\`undefined\\`.`);\n  }\n\n  const iterator = iterable[SymbolIterator]();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(iterator && isFunction$1(iterator.next), `Invalid iterator function for \"${toString$1(iterable)}\" in ${vmBeingRendered}.`);\n  }\n\n  let next = iterator.next();\n  let j = 0;\n  let {\n    value,\n    done: last\n  } = next;\n  let keyMap;\n  let iterationError;\n\n  if (process.env.NODE_ENV !== 'production') {\n    keyMap = create$1(null);\n  }\n\n  while (last === false) {\n    // implementing a look-back-approach because we need to know if the element is the last\n    next = iterator.next();\n    last = next.done; // template factory logic based on the previous collected value\n\n    const vnode = factory(value, j, j === 0, last);\n\n    if (isArray$2(vnode)) {\n      ArrayPush$1.apply(list, vnode);\n    } else {\n      ArrayPush$1.call(list, vnode);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vnodes = isArray$2(vnode) ? vnode : [vnode];\n      forEach$1.call(vnodes, childVnode => {\n        if (!isNull$1(childVnode) && isObject$2(childVnode) && !isUndefined$1(childVnode.sel)) {\n          const {\n            key\n          } = childVnode;\n\n          if (isString(key) || isNumber(key)) {\n            if (keyMap[key] === 1 && isUndefined$1(iterationError)) {\n              iterationError = `Duplicated \"key\" attribute value for \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. A key with value \"${childVnode.key}\" appears more than once in the iteration. Key values must be unique numbers or strings.`;\n            }\n\n            keyMap[key] = 1;\n          } else if (isUndefined$1(iterationError)) {\n            iterationError = `Invalid \"key\" attribute value in \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. Set a unique \"key\" value on all iterated child elements.`;\n          }\n        }\n      });\n    } // preparing next value\n\n\n    j += 1;\n    value = next.value;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined$1(iterationError)) {\n      logError(iterationError, vmBeingRendered);\n    }\n  }\n\n  return list;\n}\n/**\n * [f]lattening\n */\n\nfunction f(items) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isArray$2(items), 'flattening api can only work with arrays.');\n  }\n\n  const len = items.length;\n  const flattened = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n\n  sc(flattened);\n\n  for (let j = 0; j < len; j += 1) {\n    const item = items[j];\n\n    if (isArray$2(item)) {\n      ArrayPush$1.apply(flattened, item);\n    } else {\n      ArrayPush$1.call(flattened, item);\n    }\n  }\n\n  return flattened;\n} // [t]ext node\n\nfunction t(text) {\n  const data = EmptyObject;\n  let sel, children, key, elm;\n  return {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: TextHook,\n    owner: getVMBeingRendered()\n  };\n} // [d]ynamic value to produce a text vnode\n\nfunction d(value) {\n  if (value == null) {\n    return null;\n  }\n\n  return t(value);\n} // [b]ind function\n\nfunction b(fn) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isNull$1(vmBeingRendered)) {\n    throw new Error();\n  }\n\n  const vm = vmBeingRendered;\n  return function (event) {\n    invokeEventListener(vm, fn, vm.component, event);\n  };\n} // [k]ey function\n\nfunction k(compilerKey, obj) {\n  switch (typeof obj) {\n    case 'number':\n    case 'string':\n      return compilerKey + ':' + obj;\n\n    case 'object':\n      if (process.env.NODE_ENV !== 'production') {\n        assert$1.fail(`Invalid key value \"${obj}\" in ${getVMBeingRendered()}. Key must be a string or number.`);\n      }\n\n  }\n} // [g]lobal [id] function\n\nfunction gid(id) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined$1(id) || id === '') {\n    if (process.env.NODE_ENV !== 'production') {\n      logError(`Invalid id value \"${id}\". The id attribute must contain a non-empty string.`, vmBeingRendered);\n    }\n\n    return id;\n  } // We remove attributes when they are assigned a value of null\n\n\n  if (isNull$1(id)) {\n    return null;\n  }\n\n  return `${id}-${vmBeingRendered.idx}`;\n} // [f]ragment [id] function\n\nfunction fid(url) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined$1(url) || url === '') {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined$1(url)) {\n        logError(`Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.`, vmBeingRendered);\n      }\n    }\n\n    return url;\n  } // We remove attributes when they are assigned a value of null\n\n\n  if (isNull$1(url)) {\n    return null;\n  } // Apply transformation only for fragment-only-urls\n\n\n  if (/^#/.test(url)) {\n    return `${url}-${vmBeingRendered.idx}`;\n  }\n\n  return url;\n}\n/**\n * Map to store an index value assigned to any dynamic component reference ingested\n * by dc() api. This allows us to generate a unique unique per template per dynamic\n * component reference to avoid diffing algo mismatches.\n */\n\nconst DynamicImportedComponentMap = new Map();\nlet dynamicImportedComponentCounter = 0;\n/**\n * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`\n */\n\nfunction dc(sel, Ctor, data, children) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isString(sel), `dc() 1st argument sel must be a string.`);\n    assert$1.isTrue(isObject$2(data), `dc() 3nd argument data must be an object.`);\n    assert$1.isTrue(arguments.length === 3 || isArray$2(children), `dc() 4nd argument data must be an array.`);\n  } // null or undefined values should produce a null value in the VNodes\n\n\n  if (Ctor == null) {\n    return null;\n  }\n\n  if (!isComponentConstructor(Ctor)) {\n    throw new Error(`Invalid LWC Constructor ${toString$1(Ctor)} for custom element <${sel}>.`);\n  }\n\n  let idx = DynamicImportedComponentMap.get(Ctor);\n\n  if (isUndefined$1(idx)) {\n    idx = dynamicImportedComponentCounter++;\n    DynamicImportedComponentMap.set(Ctor, idx);\n  } // the new vnode key is a mix of idx and compiler key, this is required by the diffing algo\n  // to identify different constructors as vnodes with different keys to avoid reusing the\n  // element used for previous constructors.\n\n\n  data.key = `dc:${idx}:${data.key}`;\n  return c(sel, Ctor, data, children);\n}\n/**\n * slow children collection marking mechanism. this API allows the compiler to signal\n * to the engine that a particular collection of children must be diffed using the slow\n * algo based on keys due to the nature of the list. E.g.:\n *\n *   - slot element's children: the content of the slot has to be dynamic when in synthetic\n *                              shadow mode because the `vnode.children` might be the slotted\n *                              content vs default content, in which case the size and the\n *                              keys are not matching.\n *   - children that contain dynamic components\n *   - children that are produced by iteration\n *\n */\n\nfunction sc(vnodes) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isArray$2(vnodes), 'sc() api can only work with arrays.');\n  } // We have to mark the vnodes collection as dynamic so we can later on\n  // choose to use the snabbdom virtual dom diffing algo instead of our\n  // static dummy algo.\n\n\n  markAsDynamicChildren(vnodes);\n  return vnodes;\n}\n\nvar api$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    h: h,\n    ti: ti,\n    s: s,\n    c: c,\n    i: i,\n    f: f,\n    t: t,\n    d: d,\n    b: b,\n    k: k,\n    gid: gid,\n    fid: fid,\n    dc: dc,\n    sc: sc\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction createShadowStyleVNode(content) {\n  return h('style', {\n    key: 'style',\n    attrs: {\n      type: 'text/css'\n    }\n  }, [t(content)]);\n}\n\nfunction updateSyntheticShadowAttributes(vm, template) {\n  const {\n    elm,\n    context,\n    renderer\n  } = vm;\n  const {\n    stylesheets: newStylesheets,\n    stylesheetTokens: newStylesheetTokens\n  } = template;\n  let newHostAttribute;\n  let newShadowAttribute; // Reset the styling token applied to the host element.\n\n  const oldHostAttribute = context.hostAttribute;\n\n  if (!isUndefined$1(oldHostAttribute)) {\n    renderer.removeAttribute(elm, oldHostAttribute);\n  } // Apply the new template styling token to the host element, if the new template has any\n  // associated stylesheets.\n\n\n  if (!isUndefined$1(newStylesheetTokens) && !isUndefined$1(newStylesheets) && newStylesheets.length !== 0) {\n    newHostAttribute = newStylesheetTokens.hostAttribute;\n    newShadowAttribute = newStylesheetTokens.shadowAttribute;\n    renderer.setAttribute(elm, newHostAttribute, '');\n  } // Update the styling tokens present on the context object.\n\n\n  context.hostAttribute = newHostAttribute;\n  context.shadowAttribute = newShadowAttribute;\n}\n\nfunction evaluateStylesheetsContent(stylesheets, hostSelector, shadowSelector, nativeShadow) {\n  const content = [];\n\n  for (let i = 0; i < stylesheets.length; i++) {\n    let stylesheet = stylesheets[i];\n\n    if (isArray$2(stylesheet)) {\n      ArrayPush$1.apply(content, evaluateStylesheetsContent(stylesheet, hostSelector, shadowSelector, nativeShadow));\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        // in dev-mode, we support hot swapping of stylesheet, which means that\n        // the component instance might be attempting to use an old version of\n        // the stylesheet, while internally, we have a replacement for it.\n        stylesheet = getStyleOrSwappedStyle(stylesheet);\n      }\n\n      ArrayPush$1.call(content, stylesheet(hostSelector, shadowSelector, nativeShadow));\n    }\n  }\n\n  return content;\n}\n\nfunction getStylesheetsContent(vm, template) {\n  const {\n    stylesheets,\n    stylesheetTokens: tokens\n  } = template;\n  const {\n    syntheticShadow\n  } = vm.renderer;\n  let content = [];\n\n  if (!isUndefined$1(stylesheets) && !isUndefined$1(tokens)) {\n    const hostSelector = syntheticShadow ? `[${tokens.hostAttribute}]` : '';\n    const shadowSelector = syntheticShadow ? `[${tokens.shadowAttribute}]` : '';\n    content = evaluateStylesheetsContent(stylesheets, hostSelector, shadowSelector, !syntheticShadow);\n  }\n\n  return content;\n}\nfunction createStylesheet(vm, stylesheets) {\n  const {\n    renderer\n  } = vm;\n\n  if (renderer.syntheticShadow) {\n    for (let i = 0; i < stylesheets.length; i++) {\n      renderer.insertGlobalStylesheet(stylesheets[i]);\n    }\n\n    return null;\n  } else {\n    const shadowStyleSheetContent = ArrayJoin$1.call(stylesheets, '\\n');\n    return createShadowStyleVNode(shadowStyleSheetContent);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar GlobalMeasurementPhase;\n\n(function (GlobalMeasurementPhase) {\n  GlobalMeasurementPhase[\"REHYDRATE\"] = \"lwc-rehydrate\";\n  GlobalMeasurementPhase[\"HYDRATE\"] = \"lwc-hydrate\";\n})(GlobalMeasurementPhase || (GlobalMeasurementPhase = {})); // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.\n// JSDom (used in Jest) for example doesn't implement the UserTiming APIs.\n\n\nconst isUserTimingSupported = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\nfunction getMarkName(phase, vm) {\n  // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce\n  // the right measures for components that are recursive.\n  return `${getComponentTag(vm)} - ${phase} - ${vm.idx}`;\n}\n\nfunction getMeasureName(phase, vm) {\n  return `${getComponentTag(vm)} - ${phase}`;\n}\n\nfunction start(markName) {\n  performance.mark(markName);\n}\n\nfunction end(measureName, markName) {\n  performance.measure(measureName, markName); // Clear the created marks and measure to avoid filling the performance entries buffer.\n  // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.\n\n  performance.clearMarks(markName);\n  performance.clearMarks(measureName);\n}\n\nfunction noop$1() {\n  /* do nothing */\n}\n\nconst startMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {\n  const markName = getMarkName(phase, vm);\n  start(markName);\n};\nconst endMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {\n  const markName = getMarkName(phase, vm);\n  const measureName = getMeasureName(phase, vm);\n  end(measureName, markName);\n};\nconst startGlobalMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {\n  const markName = isUndefined$1(vm) ? phase : getMarkName(phase, vm);\n  start(markName);\n};\nconst endGlobalMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {\n  const markName = isUndefined$1(vm) ? phase : getMarkName(phase, vm);\n  end(phase, markName);\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction noop$2(_opId, _phase, _cmpName, _vm_idx) {}\n\nlet logOperation = noop$2;\nvar OperationId;\n\n(function (OperationId) {\n  OperationId[OperationId[\"constructor\"] = 0] = \"constructor\";\n  OperationId[OperationId[\"render\"] = 1] = \"render\";\n  OperationId[OperationId[\"patch\"] = 2] = \"patch\";\n  OperationId[OperationId[\"connectedCallback\"] = 3] = \"connectedCallback\";\n  OperationId[OperationId[\"renderedCallback\"] = 4] = \"renderedCallback\";\n  OperationId[OperationId[\"disconnectedCallback\"] = 5] = \"disconnectedCallback\";\n  OperationId[OperationId[\"errorCallback\"] = 6] = \"errorCallback\";\n})(OperationId || (OperationId = {}));\n\nvar Phase;\n\n(function (Phase) {\n  Phase[Phase[\"Start\"] = 0] = \"Start\";\n  Phase[Phase[\"Stop\"] = 1] = \"Stop\";\n})(Phase || (Phase = {}));\n\nconst opIdToMeasurementPhaseMappingArray = ['constructor', 'render', 'patch', 'connectedCallback', 'renderedCallback', 'disconnectedCallback', 'errorCallback'];\nlet profilerEnabled = false;\nlet logMarks = false;\nlet bufferLogging = false;\n\nif (process.env.NODE_ENV !== 'production') {\n  profilerEnabled = true;\n  logMarks = true;\n  bufferLogging = false;\n}\n\nconst profilerStateCallbacks = [];\n\nfunction trackProfilerState(callback) {\n  callback(profilerEnabled);\n  profilerStateCallbacks.push(callback);\n}\n\nfunction logOperationStart(opId, vm) {\n  if (logMarks) {\n    startMeasure(opIdToMeasurementPhaseMappingArray[opId], vm);\n  }\n\n  if (bufferLogging) {\n    logOperation(opId, Phase.Start, vm.tagName, vm.idx);\n  }\n}\n\nfunction logOperationEnd(opId, vm) {\n  if (logMarks) {\n    endMeasure(opIdToMeasurementPhaseMappingArray[opId], vm);\n  }\n\n  if (bufferLogging) {\n    logOperation(opId, Phase.Stop, vm.tagName, vm.idx);\n  }\n}\n\nfunction enableProfiler() {\n  profilerEnabled = true;\n  bufferLogging = true;\n  notifyProfilerStateChange();\n}\n\nfunction disableProfiler() {\n  if (process.env.NODE_ENV !== 'production') {\n    // in non-prod mode we want to keep logging marks\n    profilerEnabled = true;\n    logMarks = true;\n    bufferLogging = false;\n  } else {\n    profilerEnabled = false;\n    bufferLogging = false;\n    logMarks = false;\n  }\n\n  notifyProfilerStateChange();\n}\n\nfunction notifyProfilerStateChange() {\n  for (let i = 0; i < profilerStateCallbacks.length; i++) {\n    profilerStateCallbacks[i](profilerEnabled);\n  }\n}\n\nfunction attachDispatcher(dispatcher) {\n  logOperation = dispatcher;\n  bufferLogging = true;\n}\n\nfunction detachDispatcher() {\n  const currentLogOperation = logOperation;\n  logOperation = noop$2;\n  bufferLogging = false;\n  return currentLogOperation;\n}\n\nconst profilerControl = {\n  enableProfiler,\n  disableProfiler,\n  attachDispatcher,\n  detachDispatcher\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isUpdatingTemplate = false;\nlet vmBeingRendered = null;\nfunction getVMBeingRendered() {\n  return vmBeingRendered;\n}\nfunction setVMBeingRendered(vm) {\n  vmBeingRendered = vm;\n}\nlet profilerEnabled$1 = false;\ntrackProfilerState(t => profilerEnabled$1 = t);\n\nfunction validateSlots(vm, html) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const {\n    cmpSlots\n  } = vm;\n  const {\n    slots = EmptyArray\n  } = html;\n\n  for (const slotName in cmpSlots) {\n    // eslint-disable-next-line lwc-internal/no-production-assert\n    assert$1.isTrue(isArray$2(cmpSlots[slotName]), `Slots can only be set to an array, instead received ${toString$1(cmpSlots[slotName])} for slot \"${slotName}\" in ${vm}.`);\n\n    if (slotName !== '' && ArrayIndexOf$1.call(slots, slotName) === -1) {\n      // TODO [#1297]: this should never really happen because the compiler should always validate\n      // eslint-disable-next-line lwc-internal/no-production-assert\n      logError(`Ignoring unknown provided slot name \"${slotName}\" in ${vm}. Check for a typo on the slot attribute.`, vm);\n    }\n  }\n}\n\nfunction evaluateTemplate(vm, html) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isFunction$1(html), `evaluateTemplate() second argument must be an imported template instead of ${toString$1(html)}`); // in dev-mode, we support hot swapping of templates, which means that\n    // the component instance might be attempting to use an old version of\n    // the template, while internally, we have a replacement for it.\n\n    html = getTemplateOrSwappedTemplate(html);\n  }\n\n  const isUpdatingTemplateInception = isUpdatingTemplate;\n  const vmOfTemplateBeingUpdatedInception = vmBeingRendered;\n  let vnodes = [];\n  runWithBoundaryProtection(vm, vm.owner, () => {\n    // pre\n    vmBeingRendered = vm;\n\n    if (profilerEnabled$1) {\n      logOperationStart(OperationId.render, vm);\n    }\n  }, () => {\n    // job\n    const {\n      component,\n      context,\n      cmpSlots,\n      cmpTemplate,\n      tro,\n      renderer\n    } = vm;\n    tro.observe(() => {\n      // Reset the cache memoizer for template when needed.\n      if (html !== cmpTemplate) {\n        // Perf opt: do not reset the shadow root during the first rendering (there is\n        // nothing to reset).\n        if (!isNull$1(cmpTemplate)) {\n          // It is important to reset the content to avoid reusing similar elements\n          // generated from a different template, because they could have similar IDs,\n          // and snabbdom just rely on the IDs.\n          resetShadowRoot(vm);\n        } // Check that the template was built by the compiler.\n\n\n        if (!isTemplateRegistered(html)) {\n          throw new TypeError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \\`import html from \"./${vm.def.name}.html\"\\`), instead, it has returned: ${toString$1(html)}.`);\n        }\n\n        vm.cmpTemplate = html; // Create a brand new template cache for the swapped templated.\n\n        context.tplCache = create$1(null); // Update the synthetic shadow attributes on the host element if necessary.\n\n        if (renderer.syntheticShadow) {\n          updateSyntheticShadowAttributes(vm, html);\n        } // Evaluate, create stylesheet and cache the produced VNode for future\n        // re-rendering.\n\n\n        const stylesheetsContent = getStylesheetsContent(vm, html);\n        context.styleVNode = stylesheetsContent.length === 0 ? null : createStylesheet(vm, stylesheetsContent);\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        // validating slots in every rendering since the allocated content might change over time\n        validateSlots(vm, html); // add the VM to the list of host VMs that can be re-rendered if html is swapped\n\n        setActiveVM(vm);\n      } // right before producing the vnodes, we clear up all internal references\n      // to custom elements from the template.\n\n\n      vm.velements = []; // Set the global flag that template is being updated\n\n      isUpdatingTemplate = true;\n      vnodes = html.call(undefined, api$1, component, cmpSlots, context.tplCache);\n      const {\n        styleVNode\n      } = context;\n\n      if (!isNull$1(styleVNode)) {\n        ArrayUnshift$2.call(vnodes, styleVNode);\n      }\n    });\n  }, () => {\n    // post\n    isUpdatingTemplate = isUpdatingTemplateInception;\n    vmBeingRendered = vmOfTemplateBeingUpdatedInception;\n\n    if (profilerEnabled$1) {\n      logOperationEnd(OperationId.render, vm);\n    }\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.invariant(isArray$2(vnodes), `Compiler should produce html functions that always return an array.`);\n  }\n\n  return vnodes;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction addErrorComponentStack(vm, error) {\n  if (!isFrozen$1(error) && isUndefined$1(error.wcStack)) {\n    const wcStack = getErrorComponentStack(vm);\n    defineProperty$1(error, 'wcStack', {\n      get() {\n        return wcStack;\n      }\n\n    });\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isInvokingRender = false;\nlet vmBeingConstructed = null;\nfunction isBeingConstructed(vm) {\n  return vmBeingConstructed === vm;\n}\nlet profilerEnabled$2 = false;\ntrackProfilerState(t => profilerEnabled$2 = t);\n\nconst noop$3 = () => void 0;\n\nfunction invokeComponentCallback(vm, fn, args) {\n  const {\n    component,\n    callHook,\n    owner\n  } = vm;\n  let result;\n  runWithBoundaryProtection(vm, owner, noop$3, () => {\n    // job\n    result = callHook(component, fn, args);\n  }, noop$3);\n  return result;\n}\nfunction invokeComponentConstructor(vm, Ctor) {\n  const vmBeingConstructedInception = vmBeingConstructed;\n  let error;\n\n  if (profilerEnabled$2) {\n    logOperationStart(OperationId.constructor, vm);\n  }\n\n  vmBeingConstructed = vm;\n  /**\n   * Constructors don't need to be wrapped with a boundary because for root elements\n   * it should throw, while elements from template are already wrapped by a boundary\n   * associated to the diffing algo.\n   */\n\n  try {\n    // job\n    const result = new Ctor(); // Check indirectly if the constructor result is an instance of LightningElement. Using\n    // the \"instanceof\" operator would not work here since Locker Service provides its own\n    // implementation of LightningElement, so we indirectly check if the base constructor is\n    // invoked by accessing the component on the vm.\n\n    if (vmBeingConstructed.component !== result) {\n      throw new TypeError('Invalid component constructor, the class should extend LightningElement.');\n    }\n  } catch (e) {\n    error = Object(e);\n  } finally {\n    if (profilerEnabled$2) {\n      logOperationEnd(OperationId.constructor, vm);\n    }\n\n    vmBeingConstructed = vmBeingConstructedInception;\n\n    if (!isUndefined$1(error)) {\n      addErrorComponentStack(vm, error); // re-throwing the original error annotated after restoring the context\n\n      throw error; // eslint-disable-line no-unsafe-finally\n    }\n  }\n}\nfunction invokeComponentRenderMethod(vm) {\n  const {\n    def: {\n      render\n    },\n    callHook,\n    component,\n    owner\n  } = vm;\n  const isRenderBeingInvokedInception = isInvokingRender;\n  const vmBeingRenderedInception = getVMBeingRendered();\n  let html;\n  let renderInvocationSuccessful = false;\n  runWithBoundaryProtection(vm, owner, () => {\n    // pre\n    isInvokingRender = true;\n    setVMBeingRendered(vm);\n  }, () => {\n    // job\n    vm.tro.observe(() => {\n      html = callHook(component, render);\n      renderInvocationSuccessful = true;\n    });\n  }, () => {\n    // post\n    isInvokingRender = isRenderBeingInvokedInception;\n    setVMBeingRendered(vmBeingRenderedInception);\n  }); // If render() invocation failed, process errorCallback in boundary and return an empty template\n\n  return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];\n}\nfunction invokeComponentRenderedCallback(vm) {\n  const {\n    def: {\n      renderedCallback\n    },\n    component,\n    callHook,\n    owner\n  } = vm;\n\n  if (!isUndefined$1(renderedCallback)) {\n    runWithBoundaryProtection(vm, owner, () => {\n\n      if (profilerEnabled$2) {\n        logOperationStart(OperationId.renderedCallback, vm);\n      }\n    }, () => {\n      // job\n      callHook(component, renderedCallback);\n    }, () => {\n      // post\n      if (profilerEnabled$2) {\n        logOperationEnd(OperationId.renderedCallback, vm);\n      }\n    });\n  }\n}\nfunction invokeEventListener(vm, fn, thisValue, event) {\n  const {\n    callHook,\n    owner\n  } = vm;\n  runWithBoundaryProtection(vm, owner, noop$3, () => {\n    // job\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.isTrue(isFunction$1(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);\n    }\n\n    callHook(thisValue, fn, [event]);\n  }, noop$3);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedTemplateMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\n\nfunction registerComponent(Ctor, {\n  tmpl\n}) {\n  signedTemplateMap.set(Ctor, tmpl); // chaining this method as a way to wrap existing assignment of component constructor easily,\n  // without too much transformation\n\n  return Ctor;\n}\nfunction getComponentRegisteredTemplate(Ctor) {\n  return signedTemplateMap.get(Ctor);\n}\nfunction createComponent(vm, Ctor) {\n  // create the component instance\n  invokeComponentConstructor(vm, Ctor);\n\n  if (isUndefined$1(vm.component)) {\n    throw new ReferenceError(`Invalid construction for ${Ctor}, you must extend LightningElement.`);\n  }\n}\nfunction getTemplateReactiveObserver(vm) {\n  return new ReactiveObserver(() => {\n    const {\n      isDirty\n    } = vm;\n\n    if (isFalse$1$1(isDirty)) {\n      markComponentAsDirty(vm);\n      scheduleRehydration(vm);\n    }\n  });\n}\nfunction renderComponent(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.invariant(vm.isDirty, `${vm} is not dirty.`);\n  }\n\n  vm.tro.reset();\n  const vnodes = invokeComponentRenderMethod(vm);\n  vm.isDirty = false;\n  vm.isScheduled = false;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.invariant(isArray$2(vnodes), `${vm}.render() should always return an array of vnodes instead of ${vnodes}`);\n  }\n\n  return vnodes;\n}\nfunction markComponentAsDirty(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    const vmBeingRendered = getVMBeingRendered();\n    assert$1.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);\n    assert$1.isFalse(isInvokingRender, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);\n    assert$1.isFalse(isUpdatingTemplate, `markComponentAsDirty() for ${vm} cannot be called while updating template of ${vmBeingRendered}.`);\n  }\n\n  vm.isDirty = true;\n}\nconst cmpEventListenerMap = new WeakMap();\nfunction getWrappedComponentsListener(vm, listener) {\n  if (!isFunction$1(listener)) {\n    throw new TypeError(); // avoiding problems with non-valid listeners\n  }\n\n  let wrappedListener = cmpEventListenerMap.get(listener);\n\n  if (isUndefined$1(wrappedListener)) {\n    wrappedListener = function (event) {\n      invokeEventListener(vm, listener, undefined, event);\n    };\n\n    cmpEventListenerMap.set(listener, wrappedListener);\n  }\n\n  return wrappedListener;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Services = create$1(null);\nconst hooks = ['rendered', 'connected', 'disconnected'];\n/**\n * EXPERIMENTAL: This function allows for the registration of \"services\"\n * in LWC by exposing hooks into the component life-cycle. This API is\n * subject to change or being removed.\n */\n\nfunction register(service) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isObject$2(service), `Invalid service declaration, ${service}: service must be an object`);\n  }\n\n  for (let i = 0; i < hooks.length; ++i) {\n    const hookName = hooks[i];\n\n    if (hookName in service) {\n      let l = Services[hookName];\n\n      if (isUndefined$1(l)) {\n        Services[hookName] = l = [];\n      }\n\n      ArrayPush$1.call(l, service[hookName]);\n    }\n  }\n}\nfunction invokeServiceHook(vm, cbs) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(isArray$2(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);\n  }\n\n  const {\n    component,\n    def,\n    context\n  } = vm;\n\n  for (let i = 0, len = cbs.length; i < len; ++i) {\n    cbs[i].call(undefined, component, {}, def, context);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar VMState;\n\n(function (VMState) {\n  VMState[VMState[\"created\"] = 0] = \"created\";\n  VMState[VMState[\"connected\"] = 1] = \"connected\";\n  VMState[VMState[\"disconnected\"] = 2] = \"disconnected\";\n})(VMState || (VMState = {}));\n\nlet profilerEnabled$3 = false;\ntrackProfilerState(t => profilerEnabled$3 = t);\nlet idx = 0;\n/** The internal slot used to associate different objects the engine manipulates with the VM */\n\nconst ViewModelReflection = createHiddenField$1('ViewModel', 'engine');\n\nfunction callHook(cmp, fn, args = []) {\n  return fn.apply(cmp, args);\n}\n\nfunction setHook(cmp, prop, newValue) {\n  cmp[prop] = newValue;\n}\n\nfunction getHook(cmp, prop) {\n  return cmp[prop];\n}\n\nfunction rerenderVM(vm) {\n  rehydrate(vm);\n}\nfunction connectRootElement(elm) {\n  const vm = getAssociatedVM(elm);\n  startGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm); // Usually means moving the element from one place to another, which is observable via\n  // life-cycle hooks.\n\n  if (vm.state === VMState.connected) {\n    disconnectRootElement(elm);\n  }\n\n  runConnectedCallback(vm);\n  rehydrate(vm);\n  endGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);\n}\nfunction disconnectRootElement(elm) {\n  const vm = getAssociatedVM(elm);\n  resetComponentStateWhenRemoved(vm);\n}\nfunction appendVM(vm) {\n  rehydrate(vm);\n} // just in case the component comes back, with this we guarantee re-rendering it\n// while preventing any attempt to rehydration until after reinsertion.\n\nfunction resetComponentStateWhenRemoved(vm) {\n  const {\n    state\n  } = vm;\n\n  if (state !== VMState.disconnected) {\n    const {\n      oar,\n      tro\n    } = vm; // Making sure that any observing record will not trigger the rehydrated on this vm\n\n    tro.reset(); // Making sure that any observing accessor record will not trigger the setter to be reinvoked\n\n    for (const key in oar) {\n      oar[key].reset();\n    }\n\n    runDisconnectedCallback(vm); // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)\n\n    runShadowChildNodesDisconnectedCallback(vm);\n    runLightChildNodesDisconnectedCallback(vm);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    removeActiveVM(vm);\n  }\n} // this method is triggered by the diffing algo only when a vnode from the\n// old vnode.children is removed from the DOM.\n\n\nfunction removeVM(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(vm.state === VMState.connected || vm.state === VMState.disconnected, `${vm} must have been connected.`);\n  }\n\n  resetComponentStateWhenRemoved(vm);\n}\nfunction createVM(elm, def, options) {\n  const {\n    mode,\n    owner,\n    renderer,\n    tagName\n  } = options;\n  const vm = {\n    elm,\n    def,\n    idx: idx++,\n    state: VMState.created,\n    isScheduled: false,\n    isDirty: true,\n    tagName,\n    mode,\n    owner,\n    renderer,\n    children: EmptyArray,\n    aChildren: EmptyArray,\n    velements: EmptyArray,\n    cmpProps: create$1(null),\n    cmpFields: create$1(null),\n    cmpSlots: create$1(null),\n    oar: create$1(null),\n    cmpTemplate: null,\n    context: {\n      hostAttribute: undefined,\n      shadowAttribute: undefined,\n      styleVNode: null,\n      tplCache: EmptyObject,\n      wiredConnecting: EmptyArray,\n      wiredDisconnecting: EmptyArray\n    },\n    tro: null,\n    component: null,\n    cmpRoot: null,\n    callHook,\n    setHook,\n    getHook\n  };\n  vm.tro = getTemplateReactiveObserver(vm);\n\n  if (process.env.NODE_ENV !== 'production') {\n    vm.toString = () => {\n      return `[object:vm ${def.name} (${vm.idx})]`;\n    };\n  } // Create component instance associated to the vm and the element.\n\n\n  createComponent(vm, def.ctor); // Initializing the wire decorator per instance only when really needed\n\n  if (isFalse$1$1(renderer.ssr) && hasWireAdapters(vm)) {\n    installWireAdapters(vm);\n  }\n\n  return vm;\n}\n\nfunction assertIsVM(obj) {\n  if (isNull$1(obj) || !isObject$2(obj) || !('cmpRoot' in obj)) {\n    throw new TypeError(`${obj} is not a VM.`);\n  }\n}\n\nfunction associateVM(obj, vm) {\n  setHiddenField$1(obj, ViewModelReflection, vm);\n}\nfunction getAssociatedVM(obj) {\n  const vm = getHiddenField$1(obj, ViewModelReflection);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertIsVM(vm);\n  }\n\n  return vm;\n}\nfunction getAssociatedVMIfPresent(obj) {\n  const maybeVm = getHiddenField$1(obj, ViewModelReflection);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined$1(maybeVm)) {\n      assertIsVM(maybeVm);\n    }\n  }\n\n  return maybeVm;\n}\n\nfunction rehydrate(vm) {\n  if (isTrue$1$1(vm.isDirty)) {\n    const children = renderComponent(vm);\n    patchShadowRoot(vm, children);\n  }\n}\n\nfunction patchShadowRoot(vm, newCh) {\n  const {\n    cmpRoot,\n    children: oldCh\n  } = vm; // caching the new children collection\n\n  vm.children = newCh;\n\n  if (newCh.length > 0 || oldCh.length > 0) {\n    // patch function mutates vnodes by adding the element reference,\n    // however, if patching fails it contains partial changes.\n    if (oldCh !== newCh) {\n      const fn = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;\n      runWithBoundaryProtection(vm, vm, () => {\n        // pre\n        if (profilerEnabled$3) {\n          logOperationStart(OperationId.patch, vm);\n        }\n      }, () => {\n        // job\n        fn(cmpRoot, oldCh, newCh);\n      }, () => {\n        // post\n        if (profilerEnabled$3) {\n          logOperationEnd(OperationId.patch, vm);\n        }\n      });\n    }\n  }\n\n  if (vm.state === VMState.connected) {\n    // If the element is connected, that means connectedCallback was already issued, and\n    // any successive rendering should finish with the call to renderedCallback, otherwise\n    // the connectedCallback will take care of calling it in the right order at the end of\n    // the current rehydration process.\n    runRenderedCallback(vm);\n  }\n}\n\nfunction runRenderedCallback(vm) {\n  if (isTrue$1$1(vm.renderer.ssr)) {\n    return;\n  }\n\n  const {\n    rendered\n  } = Services;\n\n  if (rendered) {\n    invokeServiceHook(vm, rendered);\n  }\n\n  invokeComponentRenderedCallback(vm);\n}\n\nlet rehydrateQueue = [];\n\nfunction flushRehydrationQueue() {\n  startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n  }\n\n  const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);\n  rehydrateQueue = []; // reset to a new queue\n\n  for (let i = 0, len = vms.length; i < len; i += 1) {\n    const vm = vms[i];\n\n    try {\n      rehydrate(vm);\n    } catch (error) {\n      if (i + 1 < len) {\n        // pieces of the queue are still pending to be rehydrated, those should have priority\n        if (rehydrateQueue.length === 0) {\n          addCallbackToNextTick(flushRehydrationQueue);\n        }\n\n        ArrayUnshift$2.apply(rehydrateQueue, ArraySlice$2.call(vms, i + 1));\n      } // we need to end the measure before throwing.\n\n\n      endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE); // re-throwing the original error will break the current tick, but since the next tick is\n      // already scheduled, it should continue patching the rest.\n\n      throw error; // eslint-disable-line no-unsafe-finally\n    }\n  }\n\n  endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n}\n\nfunction runConnectedCallback(vm) {\n  const {\n    state\n  } = vm;\n\n  if (state === VMState.connected) {\n    return; // nothing to do since it was already connected\n  }\n\n  vm.state = VMState.connected; // reporting connection\n\n  const {\n    connected\n  } = Services;\n\n  if (connected) {\n    invokeServiceHook(vm, connected);\n  }\n\n  if (hasWireAdapters(vm)) {\n    connectWireAdapters(vm);\n  }\n\n  const {\n    connectedCallback\n  } = vm.def;\n\n  if (!isUndefined$1(connectedCallback)) {\n    if (profilerEnabled$3) {\n      logOperationStart(OperationId.connectedCallback, vm);\n    }\n\n    invokeComponentCallback(vm, connectedCallback);\n\n    if (profilerEnabled$3) {\n      logOperationEnd(OperationId.connectedCallback, vm);\n    }\n  }\n}\n\nfunction hasWireAdapters(vm) {\n  return getOwnPropertyNames$1(vm.def.wire).length > 0;\n}\n\nfunction runDisconnectedCallback(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.isTrue(vm.state !== VMState.disconnected, `${vm} must be inserted.`);\n  }\n\n  if (isFalse$1$1(vm.isDirty)) {\n    // this guarantees that if the component is reused/reinserted,\n    // it will be re-rendered because we are disconnecting the reactivity\n    // linking, so mutations are not automatically reflected on the state\n    // of disconnected components.\n    vm.isDirty = true;\n  }\n\n  vm.state = VMState.disconnected; // reporting disconnection\n\n  const {\n    disconnected\n  } = Services;\n\n  if (disconnected) {\n    invokeServiceHook(vm, disconnected);\n  }\n\n  if (hasWireAdapters(vm)) {\n    disconnectWireAdapters(vm);\n  }\n\n  const {\n    disconnectedCallback\n  } = vm.def;\n\n  if (!isUndefined$1(disconnectedCallback)) {\n    if (profilerEnabled$3) {\n      logOperationStart(OperationId.disconnectedCallback, vm);\n    }\n\n    invokeComponentCallback(vm, disconnectedCallback);\n\n    if (profilerEnabled$3) {\n      logOperationEnd(OperationId.disconnectedCallback, vm);\n    }\n  }\n}\n\nfunction runShadowChildNodesDisconnectedCallback(vm) {\n  const {\n    velements: vCustomElementCollection\n  } = vm; // Reporting disconnection for every child in inverse order since they are\n  // inserted in reserved order.\n\n  for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {\n    const {\n      elm\n    } = vCustomElementCollection[i]; // There are two cases where the element could be undefined:\n    // * when there is an error during the construction phase, and an error\n    //   boundary picks it, there is a possibility that the VCustomElement\n    //   is not properly initialized, and therefore is should be ignored.\n    // * when slotted custom element is not used by the element where it is\n    //   slotted into it, as  a result, the custom element was never\n    //   initialized.\n\n    if (!isUndefined$1(elm)) {\n      const childVM = getAssociatedVMIfPresent(elm); // The VM associated with the element might be associated undefined\n      // in the case where the VM failed in the middle of its creation,\n      // eg: constructor throwing before invoking super().\n\n      if (!isUndefined$1(childVM)) {\n        resetComponentStateWhenRemoved(childVM);\n      }\n    }\n  }\n}\n\nfunction runLightChildNodesDisconnectedCallback(vm) {\n  const {\n    aChildren: adoptedChildren\n  } = vm;\n  recursivelyDisconnectChildren(adoptedChildren);\n}\n/**\n * The recursion doesn't need to be a complete traversal of the vnode graph,\n * instead it can be partial, when a custom element vnode is found, we don't\n * need to continue into its children because by attempting to disconnect the\n * custom element itself will trigger the removal of anything slotted or anything\n * defined on its shadow.\n */\n\n\nfunction recursivelyDisconnectChildren(vnodes) {\n  for (let i = 0, len = vnodes.length; i < len; i += 1) {\n    const vnode = vnodes[i];\n\n    if (!isNull$1(vnode) && isArray$2(vnode.children) && !isUndefined$1(vnode.elm)) {\n      // vnode is a VElement with children\n      if (isUndefined$1(vnode.ctor)) {\n        // it is a VElement, just keep looking (recursively)\n        recursivelyDisconnectChildren(vnode.children);\n      } else {\n        // it is a VCustomElement, disconnect it and ignore its children\n        resetComponentStateWhenRemoved(getAssociatedVM(vnode.elm));\n      }\n    }\n  }\n} // This is a super optimized mechanism to remove the content of the shadowRoot without having to go\n// into snabbdom. Especially useful when the reset is a consequence of an error, in which case the\n// children VNodes might not be representing the current state of the DOM.\n\n\nfunction resetShadowRoot(vm) {\n  const {\n    children,\n    cmpRoot,\n    renderer\n  } = vm;\n\n  for (let i = 0, len = children.length; i < len; i++) {\n    const child = children[i];\n\n    if (!isNull$1(child) && !isUndefined$1(child.elm)) {\n      renderer.remove(child.elm, cmpRoot);\n    }\n  }\n\n  vm.children = EmptyArray;\n  runShadowChildNodesDisconnectedCallback(vm);\n  vm.velements = EmptyArray;\n}\nfunction scheduleRehydration(vm) {\n  if (isTrue$1$1(vm.renderer.ssr) || isTrue$1$1(vm.isScheduled)) {\n    return;\n  }\n\n  vm.isScheduled = true;\n\n  if (rehydrateQueue.length === 0) {\n    addCallbackToNextTick(flushRehydrationQueue);\n  }\n\n  ArrayPush$1.call(rehydrateQueue, vm);\n}\n\nfunction getErrorBoundaryVM(vm) {\n  let currentVm = vm;\n\n  while (!isNull$1(currentVm)) {\n    if (!isUndefined$1(currentVm.def.errorCallback)) {\n      return currentVm;\n    }\n\n    currentVm = currentVm.owner;\n  }\n} // slow path routine\n// NOTE: we should probably more this routine to the synthetic shadow folder\n// and get the allocation to be cached by in the elm instead of in the VM\n\n\nfunction allocateInSlot(vm, children) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert$1.invariant(isObject$2(vm.cmpSlots), `When doing manual allocation, there must be a cmpSlots object available.`);\n  }\n\n  const {\n    cmpSlots: oldSlots\n  } = vm;\n  const cmpSlots = vm.cmpSlots = create$1(null);\n\n  for (let i = 0, len = children.length; i < len; i += 1) {\n    const vnode = children[i];\n\n    if (isNull$1(vnode)) {\n      continue;\n    }\n\n    const {\n      data\n    } = vnode;\n    const slotName = data.attrs && data.attrs.slot || '';\n    const vnodes = cmpSlots[slotName] = cmpSlots[slotName] || []; // re-keying the vnodes is necessary to avoid conflicts with default content for the slot\n    // which might have similar keys. Each vnode will always have a key that\n    // starts with a numeric character from compiler. In this case, we add a unique\n    // notation for slotted vnodes keys, e.g.: `@foo:1:1`\n\n    if (!isUndefined$1(vnode.key)) {\n      vnode.key = `@${slotName}:${vnode.key}`;\n    }\n\n    ArrayPush$1.call(vnodes, vnode);\n  }\n\n  if (isFalse$1$1(vm.isDirty)) {\n    // We need to determine if the old allocation is really different from the new one\n    // and mark the vm as dirty\n    const oldKeys = keys$1(oldSlots);\n\n    if (oldKeys.length !== keys$1(cmpSlots).length) {\n      markComponentAsDirty(vm);\n      return;\n    }\n\n    for (let i = 0, len = oldKeys.length; i < len; i += 1) {\n      const key = oldKeys[i];\n\n      if (isUndefined$1(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {\n        markComponentAsDirty(vm);\n        return;\n      }\n\n      const oldVNodes = oldSlots[key];\n      const vnodes = cmpSlots[key];\n\n      for (let j = 0, a = cmpSlots[key].length; j < a; j += 1) {\n        if (oldVNodes[j] !== vnodes[j]) {\n          markComponentAsDirty(vm);\n          return;\n        }\n      }\n    }\n  }\n}\nfunction runWithBoundaryProtection(vm, owner, pre, job, post) {\n  let error;\n  pre();\n\n  try {\n    job();\n  } catch (e) {\n    error = Object(e);\n  } finally {\n    post();\n\n    if (!isUndefined$1(error)) {\n      addErrorComponentStack(vm, error);\n      const errorBoundaryVm = isNull$1(owner) ? undefined : getErrorBoundaryVM(owner);\n\n      if (isUndefined$1(errorBoundaryVm)) {\n        throw error; // eslint-disable-line no-unsafe-finally\n      }\n\n      resetShadowRoot(vm); // remove offenders\n\n      if (profilerEnabled$3) {\n        logOperationStart(OperationId.errorCallback, vm);\n      } // error boundaries must have an ErrorCallback\n\n\n      const errorCallback = errorBoundaryVm.def.errorCallback;\n      invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);\n\n      if (profilerEnabled$3) {\n        logOperationEnd(OperationId.errorCallback, vm);\n      }\n    }\n  }\n}\nfunction forceRehydration(vm) {\n  // if we must reset the shadowRoot content and render the template\n  // from scratch on an active instance, the way to force the reset\n  // is by replacing the value of old template, which is used during\n  // to determine if the template has changed or not during the rendering\n  // process. If the template returned by render() is different from the\n  // previous stored template, the styles will be reset, along with the\n  // content of the shadowRoot, this way we can guarantee that all children\n  // elements will be throw away, and new instances will be created.\n  vm.cmpTemplate = () => [];\n\n  if (isFalse$1$1(vm.isDirty)) {\n    // forcing the vm to rehydrate in the next tick\n    markComponentAsDirty(vm);\n    scheduleRehydration(vm);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';\nconst DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';\nconst WireMetaMap = new Map();\n\nfunction noop$4() {}\n\nclass WireContextRegistrationEvent extends CustomEvent {\n  constructor(adapterToken, {\n    setNewContext,\n    setDisconnectedCallback\n  }) {\n    super(adapterToken, {\n      bubbles: true,\n      composed: true\n    });\n    defineProperties$1(this, {\n      setNewContext: {\n        value: setNewContext\n      },\n      setDisconnectedCallback: {\n        value: setDisconnectedCallback\n      }\n    });\n  }\n\n}\n\nfunction createFieldDataCallback(vm, name) {\n  const {\n    cmpFields\n  } = vm;\n  return value => {\n    if (value !== vm.cmpFields[name]) {\n      // storing the value in the underlying storage\n      cmpFields[name] = value;\n      componentValueMutated(vm, name);\n    }\n  };\n}\n\nfunction createMethodDataCallback(vm, method) {\n  return value => {\n    // dispatching new value into the wired method\n    runWithBoundaryProtection(vm, vm.owner, noop$4, () => {\n      // job\n      method.call(vm.component, value);\n    }, noop$4);\n  };\n}\n\nfunction createConfigWatcher(component, configCallback, callbackWhenConfigIsReady) {\n  let hasPendingConfig = false; // creating the reactive observer for reactive params when needed\n\n  const ro = new ReactiveObserver(() => {\n    if (hasPendingConfig === false) {\n      hasPendingConfig = true; // collect new config in the micro-task\n\n      Promise.resolve().then(() => {\n        hasPendingConfig = false; // resetting current reactive params\n\n        ro.reset(); // dispatching a new config due to a change in the configuration\n\n        computeConfigAndUpdate();\n      });\n    }\n  });\n\n  const computeConfigAndUpdate = () => {\n    let config;\n    ro.observe(() => config = configCallback(component)); // eslint-disable-next-line lwc-internal/no-invalid-todo\n    // TODO: dev-mode validation of config based on the adapter.configSchema\n    // @ts-ignore it is assigned in the observe() callback\n\n    callbackWhenConfigIsReady(config);\n  };\n\n  return {\n    computeConfigAndUpdate,\n    ro\n  };\n}\n\nfunction createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {\n  const {\n    adapter\n  } = wireDef;\n  const adapterContextToken = getAdapterToken(adapter);\n\n  if (isUndefined$1(adapterContextToken)) {\n    return; // no provider found, nothing to be done\n  }\n\n  const {\n    elm,\n    renderer,\n    context: {\n      wiredConnecting,\n      wiredDisconnecting\n    }\n  } = vm; // waiting for the component to be connected to formally request the context via the token\n\n  ArrayPush$1.call(wiredConnecting, () => {\n    // This event is responsible for connecting the host element with another\n    // element in the composed path that is providing contextual data. The provider\n    // must be listening for a special dom event with the name corresponding to the value of\n    // `adapterContextToken`, which will remain secret and internal to this file only to\n    // guarantee that the linkage can be forged.\n    const contextRegistrationEvent = new WireContextRegistrationEvent(adapterContextToken, {\n      setNewContext(newContext) {\n        // eslint-disable-next-line lwc-internal/no-invalid-todo\n        // TODO: dev-mode validation of config based on the adapter.contextSchema\n        callbackWhenContextIsReady(newContext);\n      },\n\n      setDisconnectedCallback(disconnectCallback) {\n        // adds this callback into the disconnect bucket so it gets disconnected from parent\n        // the the element hosting the wire is disconnected\n        ArrayPush$1.call(wiredDisconnecting, disconnectCallback);\n      }\n\n    });\n    renderer.dispatchEvent(elm, contextRegistrationEvent);\n  });\n}\n\nfunction createConnector(vm, name, wireDef) {\n  const {\n    method,\n    adapter,\n    configCallback,\n    dynamic\n  } = wireDef;\n  const dataCallback = isUndefined$1(method) ? createFieldDataCallback(vm, name) : createMethodDataCallback(vm, method);\n  let context;\n  let connector; // Workaround to pass the component element associated to this wire adapter instance.\n\n  defineProperty$1(dataCallback, DeprecatedWiredElementHost, {\n    value: vm.elm\n  });\n  defineProperty$1(dataCallback, DeprecatedWiredParamsMeta, {\n    value: dynamic\n  });\n  runWithBoundaryProtection(vm, vm, noop$4, () => {\n    // job\n    connector = new adapter(dataCallback);\n  }, noop$4);\n\n  const updateConnectorConfig = config => {\n    // every time the config is recomputed due to tracking,\n    // this callback will be invoked with the new computed config\n    runWithBoundaryProtection(vm, vm, noop$4, () => {\n      // job\n      connector.update(config, context);\n    }, noop$4);\n  }; // Computes the current wire config and calls the update method on the wire adapter.\n  // If it has params, we will need to observe changes in the next tick.\n\n\n  const {\n    computeConfigAndUpdate,\n    ro\n  } = createConfigWatcher(vm.component, configCallback, updateConnectorConfig); // if the adapter needs contextualization, we need to watch for new context and push it alongside the config\n\n  if (!isUndefined$1(adapter.contextSchema)) {\n    createContextWatcher(vm, wireDef, newContext => {\n      // every time the context is pushed into this component,\n      // this callback will be invoked with the new computed context\n      if (context !== newContext) {\n        context = newContext; // Note: when new context arrives, the config will be recomputed and pushed along side the new\n        // context, this is to preserve the identity characteristics, config should not have identity\n        // (ever), while context can have identity\n\n        if (vm.state === VMState.connected) {\n          computeConfigAndUpdate();\n        }\n      }\n    });\n  }\n\n  return {\n    // @ts-ignore the boundary protection executes sync, connector is always defined\n    connector,\n    computeConfigAndUpdate,\n    resetConfigWatcher: () => ro.reset()\n  };\n}\n\nconst AdapterToTokenMap = new Map();\nfunction getAdapterToken(adapter) {\n  return AdapterToTokenMap.get(adapter);\n}\nfunction setAdapterToken(adapter, token) {\n  AdapterToTokenMap.set(adapter, token);\n}\nfunction storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {\n  // support for callable adapters\n  if (adapter.adapter) {\n    adapter = adapter.adapter;\n  }\n\n  const method = descriptor.value;\n  const def = {\n    adapter,\n    method,\n    configCallback,\n    dynamic\n  };\n  WireMetaMap.set(descriptor, def);\n}\nfunction storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {\n  // support for callable adapters\n  if (adapter.adapter) {\n    adapter = adapter.adapter;\n  }\n\n  const def = {\n    adapter,\n    configCallback,\n    dynamic\n  };\n  WireMetaMap.set(descriptor, def);\n}\nfunction installWireAdapters(vm) {\n  const {\n    context,\n    def: {\n      wire\n    }\n  } = vm;\n  const wiredConnecting = context.wiredConnecting = [];\n  const wiredDisconnecting = context.wiredDisconnecting = [];\n\n  for (const fieldNameOrMethod in wire) {\n    const descriptor = wire[fieldNameOrMethod];\n    const wireDef = WireMetaMap.get(descriptor);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert$1.invariant(wireDef, `Internal Error: invalid wire definition found.`);\n    }\n\n    if (!isUndefined$1(wireDef)) {\n      const {\n        connector,\n        computeConfigAndUpdate,\n        resetConfigWatcher\n      } = createConnector(vm, fieldNameOrMethod, wireDef);\n      const hasDynamicParams = wireDef.dynamic.length > 0;\n      ArrayPush$1.call(wiredConnecting, () => {\n        connector.connect();\n\n        if (hasDynamicParams) {\n          Promise.resolve().then(computeConfigAndUpdate);\n        } else {\n          computeConfigAndUpdate();\n        }\n      });\n      ArrayPush$1.call(wiredDisconnecting, () => {\n        connector.disconnect();\n        resetConfigWatcher();\n      });\n    }\n  }\n}\nfunction connectWireAdapters(vm) {\n  const {\n    wiredConnecting\n  } = vm.context;\n\n  for (let i = 0, len = wiredConnecting.length; i < len; i += 1) {\n    wiredConnecting[i]();\n  }\n}\nfunction disconnectWireAdapters(vm) {\n  const {\n    wiredDisconnecting\n  } = vm.context;\n  runWithBoundaryProtection(vm, vm, noop$4, () => {\n    // job\n    for (let i = 0, len = wiredDisconnecting.length; i < len; i += 1) {\n      wiredDisconnecting[i]();\n    }\n  }, noop$4);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction createContextProvider(adapter) {\n  let adapterContextToken = getAdapterToken(adapter);\n\n  if (!isUndefined$1(adapterContextToken)) {\n    throw new Error(`Adapter already has a context provider.`);\n  }\n\n  adapterContextToken = guid();\n  setAdapterToken(adapter, adapterContextToken);\n  const providers = new WeakSet();\n  return (elm, options) => {\n    if (providers.has(elm)) {\n      throw new Error(`Adapter was already installed on ${elm}.`);\n    }\n\n    providers.add(elm);\n    const {\n      consumerConnectedCallback,\n      consumerDisconnectedCallback\n    } = options;\n    elm.addEventListener(adapterContextToken, evt => {\n      const {\n        setNewContext,\n        setDisconnectedCallback\n      } = evt;\n      const consumer = {\n        provide(newContext) {\n          setNewContext(newContext);\n        }\n\n      };\n\n      const disconnectCallback = () => {\n        if (!isUndefined$1(consumerDisconnectedCallback)) {\n          consumerDisconnectedCallback(consumer);\n        }\n      };\n\n      setDisconnectedCallback(disconnectCallback);\n      consumerConnectedCallback(consumer);\n      evt.stopImmediatePropagation();\n    });\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function allows you to create a reactive readonly\n * membrane around any object value. This API is subject to change or\n * being removed.\n */\n\nfunction readonly(obj) {\n  if (process.env.NODE_ENV !== 'production') {\n    // TODO [#1292]: Remove the readonly decorator\n    if (arguments.length !== 1) {\n      assert$1.fail('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');\n    }\n  }\n\n  return reactiveMembrane.getReadOnlyProxy(obj);\n}\n/* version: 1.9.7 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst globalStylesheets = create(null);\nconst globalStylesheetsParentElement = document.head || document.body || document;\nlet getCustomElement, defineCustomElement, HTMLElementConstructor$1;\nfunction isCustomElementRegistryAvailable() {\n    if (typeof customElements === 'undefined') {\n        return false;\n    }\n    try {\n        // dereference HTMLElement global because babel wraps globals in compat mode with a\n        // _wrapNativeSuper()\n        // This is a problem because LWCUpgradableElement extends renderer.HTMLElement which does not\n        // get wrapped by babel.\n        const HTMLElementAlias = HTMLElement;\n        // In case we use compat mode with a modern browser, the compat mode transformation\n        // invokes the DOM api with an .apply() or .call() to initialize any DOM api sub-classing,\n        // which are not equipped to be initialized that way.\n        class clazz extends HTMLElementAlias {\n        }\n        customElements.define('lwc-test-' + Math.floor(Math.random() * 1000000), clazz);\n        new clazz();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nif (isCustomElementRegistryAvailable()) {\n    getCustomElement = customElements.get.bind(customElements);\n    defineCustomElement = customElements.define.bind(customElements);\n    HTMLElementConstructor$1 = HTMLElement;\n}\nelse {\n    const registry = create(null);\n    const reverseRegistry = new WeakMap();\n    defineCustomElement = function define(name, ctor) {\n        if (name !== StringToLowerCase.call(name) || registry[name]) {\n            throw new TypeError(`Invalid Registration`);\n        }\n        registry[name] = ctor;\n        reverseRegistry.set(ctor, name);\n    };\n    getCustomElement = function get(name) {\n        return registry[name];\n    };\n    HTMLElementConstructor$1 = function HTMLElement() {\n        if (!(this instanceof HTMLElement)) {\n            throw new TypeError(`Invalid Invocation`);\n        }\n        const { constructor } = this;\n        const name = reverseRegistry.get(constructor);\n        if (!name) {\n            throw new TypeError(`Invalid Construction`);\n        }\n        const elm = document.createElement(name);\n        setPrototypeOf(elm, constructor.prototype);\n        return elm;\n    };\n    HTMLElementConstructor$1.prototype = HTMLElement.prototype;\n}\n// TODO [#0]: Evaluate how we can extract the `$shadowToken$` property name in a shared package\n// to avoid having to synchronize it between the different modules.\nconst useSyntheticShadow = hasOwnProperty.call(Element.prototype, '$shadowToken$');\nconst renderer = {\n    ssr: false,\n    syntheticShadow: useSyntheticShadow,\n    createElement(tagName, namespace) {\n        return isUndefined(namespace)\n            ? document.createElement(tagName)\n            : document.createElementNS(namespace, tagName);\n    },\n    createText(content) {\n        return document.createTextNode(content);\n    },\n    insert(node, parent, anchor) {\n        parent.insertBefore(node, anchor);\n    },\n    remove(node, parent) {\n        parent.removeChild(node);\n    },\n    nextSibling(node) {\n        return node.nextSibling;\n    },\n    attachShadow(element, options) {\n        return element.attachShadow(options);\n    },\n    setText(node, content) {\n        node.nodeValue = content;\n    },\n    getProperty(node, key) {\n        return node[key];\n    },\n    setProperty(node, key, value) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (node instanceof Element && !(key in node)) {\n                // TODO [#1297]: Move this validation to the compiler\n                assert.fail(`Unknown public property \"${key}\" of element <${node.tagName}>. This is likely a typo on the corresponding attribute \"${htmlPropertyToAttribute(key)}\".`);\n            }\n        }\n        node[key] = value;\n    },\n    getAttribute(element, name, namespace) {\n        return isUndefined(namespace)\n            ? element.getAttribute(name)\n            : element.getAttributeNS(namespace, name);\n    },\n    setAttribute(element, name, value, namespace) {\n        return isUndefined(namespace)\n            ? element.setAttribute(name, value)\n            : element.setAttributeNS(namespace, name, value);\n    },\n    removeAttribute(element, name, namespace) {\n        if (isUndefined(namespace)) {\n            element.removeAttribute(name);\n        }\n        else {\n            element.removeAttributeNS(namespace, name);\n        }\n    },\n    addEventListener(target, type, callback, options) {\n        target.addEventListener(type, callback, options);\n    },\n    removeEventListener(target, type, callback, options) {\n        target.removeEventListener(type, callback, options);\n    },\n    dispatchEvent(target, event) {\n        return target.dispatchEvent(event);\n    },\n    getClassList(element) {\n        return element.classList;\n    },\n    getStyleDeclaration(element) {\n        // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to\n        // represent elements in the engine?\n        return element.style;\n    },\n    getBoundingClientRect(element) {\n        return element.getBoundingClientRect();\n    },\n    querySelector(element, selectors) {\n        return element.querySelector(selectors);\n    },\n    querySelectorAll(element, selectors) {\n        return element.querySelectorAll(selectors);\n    },\n    getElementsByTagName(element, tagNameOrWildCard) {\n        return element.getElementsByTagName(tagNameOrWildCard);\n    },\n    getElementsByClassName(element, names) {\n        return element.getElementsByClassName(names);\n    },\n    isConnected(node) {\n        return node.isConnected;\n    },\n    insertGlobalStylesheet(content) {\n        if (!isUndefined(globalStylesheets[content])) {\n            return;\n        }\n        globalStylesheets[content] = true;\n        const elm = document.createElement('style');\n        elm.type = 'text/css';\n        elm.textContent = content;\n        globalStylesheetsParentElement.appendChild(elm);\n    },\n    assertInstanceOfHTMLElement(elm, msg) {\n        assert.invariant(elm instanceof HTMLElement, msg);\n    },\n    defineCustomElement,\n    getCustomElement,\n    HTMLElement: HTMLElementConstructor$1,\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This function builds a Web Component class from a LWC constructor so it can be\n * registered as a new element via customElements.define() at any given time.\n *\n * @deprecated since version 1.3.11\n *\n * @example\n * ```\n * import { buildCustomElementConstructor } from 'lwc';\n * import Foo from 'ns/foo';\n * const WC = buildCustomElementConstructor(Foo);\n * customElements.define('x-foo', WC);\n * const elm = document.createElement('x-foo');\n * ```\n */\nfunction deprecatedBuildCustomElementConstructor(Ctor) {\n    if (process.env.NODE_ENV !== 'production') {\n        /* eslint-disable-next-line no-console */\n        console.warn('Deprecated function called: \"buildCustomElementConstructor\" function is deprecated and it will be removed.' +\n            `Use \"${Ctor.name}.CustomElementConstructor\" static property of the component constructor to access the corresponding custom element constructor instead.`);\n    }\n    return Ctor.CustomElementConstructor;\n}\nfunction buildCustomElementConstructor(Ctor) {\n    const def = getComponentInternalDef(Ctor);\n    return class extends def.bridge {\n        constructor() {\n            super();\n            createVM(this, def, {\n                mode: 'open',\n                owner: null,\n                tagName: this.tagName,\n                renderer,\n            });\n        }\n        connectedCallback() {\n            connectRootElement(this);\n        }\n        disconnectedCallback() {\n            disconnectRootElement(this);\n        }\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ConnectingSlot = createHiddenField('connecting', 'engine');\nconst DisconnectingSlot = createHiddenField('disconnecting', 'engine');\nfunction callNodeSlot(node, slot) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);\n    }\n    const fn = getHiddenField(node, slot);\n    if (!isUndefined(fn)) {\n        fn(node);\n    }\n    return node; // for convenience\n}\n// Monkey patching Node methods to be able to detect the insertions and removal of root elements\n// created via createElement.\nconst { appendChild, insertBefore, removeChild, replaceChild } = Node.prototype;\nassign(Node.prototype, {\n    appendChild(newChild) {\n        const appendedNode = appendChild.call(this, newChild);\n        return callNodeSlot(appendedNode, ConnectingSlot);\n    },\n    insertBefore(newChild, referenceNode) {\n        const insertedNode = insertBefore.call(this, newChild, referenceNode);\n        return callNodeSlot(insertedNode, ConnectingSlot);\n    },\n    removeChild(oldChild) {\n        const removedNode = removeChild.call(this, oldChild);\n        return callNodeSlot(removedNode, DisconnectingSlot);\n    },\n    replaceChild(newChild, oldChild) {\n        const replacedNode = replaceChild.call(this, newChild, oldChild);\n        callNodeSlot(replacedNode, DisconnectingSlot);\n        callNodeSlot(newChild, ConnectingSlot);\n        return replacedNode;\n    },\n});\n/**\n * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly\n * difference that in the options, you can pass the `is` property set to a Constructor instead of\n * just a string value. The intent is to allow the creation of an element controlled by LWC without\n * having to register the element as a custom element.\n *\n * @example\n * ```\n * const el = createElement('x-foo', { is: FooCtor });\n * ```\n */\nfunction createElement(sel, options) {\n    if (!isObject$1(options) || isNull(options)) {\n        throw new TypeError(`\"createElement\" function expects an object as second parameter but received \"${toString(options)}\".`);\n    }\n    const Ctor = options.is;\n    if (!isFunction(Ctor)) {\n        throw new TypeError(`\"createElement\" function expects an \"is\" option with a valid component constructor.`);\n    }\n    const UpgradableConstructor = getUpgradableConstructor(sel, renderer);\n    let wasComponentUpgraded = false;\n    // the custom element from the registry is expecting an upgrade callback\n    /**\n     * Note: if the upgradable constructor does not expect, or throw when we new it\n     * with a callback as the first argument, we could implement a more advanced\n     * mechanism that only passes that argument if the constructor is known to be\n     * an upgradable custom element.\n     */\n    const element = new UpgradableConstructor((elm) => {\n        const def = getComponentInternalDef(Ctor);\n        createVM(elm, def, {\n            tagName: sel,\n            mode: options.mode !== 'closed' ? 'open' : 'closed',\n            owner: null,\n            renderer,\n        });\n        setHiddenField(elm, ConnectingSlot, connectRootElement);\n        setHiddenField(elm, DisconnectingSlot, disconnectRootElement);\n        wasComponentUpgraded = true;\n    });\n    if (!wasComponentUpgraded) {\n        /* eslint-disable-next-line no-console */\n        console.error(`Unexpected tag name \"${sel}\". This name is a registered custom element, preventing LWC to upgrade the element.`);\n    }\n    return element;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.\n * This API is subject to change or being removed.\n */\nfunction getComponentConstructor(elm) {\n    let ctor = null;\n    if (elm instanceof HTMLElement) {\n        const vm = getAssociatedVMIfPresent(elm);\n        if (!isUndefined(vm)) {\n            ctor = vm.def.ctor;\n        }\n    }\n    return ctor;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function detects whether or not a Node is controlled by a LWC template. This\n * API is subject to change or being removed.\n */\nfunction isNodeFromTemplate(node) {\n    if (isFalse$1(node instanceof Node)) {\n        return false;\n    }\n    // TODO [#1250]: skipping the shadowRoot instances itself makes no sense, we need to revisit\n    // this with locker\n    if (node instanceof ShadowRoot) {\n        return false;\n    }\n    if (useSyntheticShadow) {\n        // TODO [#1252]: old behavior that is still used by some pieces of the platform,\n        // specifically, nodes inserted manually on places where `lwc:dom=\"manual\"` directive is not\n        // used, will be considered global elements.\n        if (isUndefined(node.$shadowResolver$)) {\n            return false;\n        }\n    }\n    const root = node.getRootNode();\n    return root instanceof ShadowRoot;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ComponentConstructorToCustomElementConstructorMap = new Map();\nfunction getCustomElementConstructor(Ctor) {\n    if (Ctor === BaseLightningElement) {\n        throw new TypeError(`Invalid Constructor. LightningElement base class can't be claimed as a custom element.`);\n    }\n    let ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);\n    if (isUndefined(ce)) {\n        ce = buildCustomElementConstructor(Ctor);\n        ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);\n    }\n    return ce;\n}\n/**\n * This static getter builds a Web Component class from a LWC constructor so it can be registered\n * as a new element via customElements.define() at any given time. E.g.:\n *\n *      import Foo from 'ns/foo';\n *      customElements.define('x-foo', Foo.CustomElementConstructor);\n *      const elm = document.createElement('x-foo');\n *\n */\ndefineProperty(BaseLightningElement, 'CustomElementConstructor', {\n    get() {\n        return getCustomElementConstructor(this);\n    },\n});\nfreeze(BaseLightningElement);\nseal(BaseLightningElement.prototype);\n\nexports.LightningElement = BaseLightningElement;\nexports.__unstable__ProfilerControl = profilerControl;\nexports.api = api;\nexports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;\nexports.createContextProvider = createContextProvider;\nexports.createElement = createElement;\nexports.getComponentConstructor = getComponentConstructor;\nexports.getComponentDef = getComponentDef;\nexports.isComponentConstructor = isComponentConstructor;\nexports.isNodeFromTemplate = isNodeFromTemplate;\nexports.readonly = readonly;\nexports.register = register;\nexports.registerComponent = registerComponent;\nexports.registerDecorators = registerDecorators;\nexports.registerTemplate = registerTemplate;\nexports.sanitizeAttribute = sanitizeAttribute;\nexports.setFeatureFlag = setFeatureFlag;\nexports.setFeatureFlagForTest = setFeatureFlagForTest;\nexports.swapComponent = swapComponent;\nexports.swapStyle = swapStyle;\nexports.swapTemplate = swapTemplate;\nexports.track = track;\nexports.unwrap = unwrap$1;\nexports.wire = wire;\n/* version: 1.9.7 */\n"],"sourceRoot":""}