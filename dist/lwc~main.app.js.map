{"version":3,"sources":["webpack:////home/85suraj/.npm/lib/node_modules/lwc-services/node_modules/@lwc/engine/dist/engine.cjs.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AACa;;AAEb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA,KAAK;;AAEL;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D,SAAS;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;;AAEA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;;AAEA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0DAA0D,UAAU,GAAG,IAAI;AAC3E;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAyC;AACxD,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;;AAEpC;AACA,aAAa,IAAI,IAAI,sBAAsB;AAC3C;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,iCAAiC;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iIAAiI;AACjI;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB,KAAK;AAC7B,CAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA,4DAA4D;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA,gDAAgD,IAAI,gBAAgB,IAAI,2DAA2D,6BAA6B;AAChK;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB,oBAAoB,aAAa;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;;AAEA,0BAA0B,QAAQ;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,KAAK,KAAK,KAAK;AACjC;;AAEA,0DAA0D;AAC1D,MAAM,SAAoB;AAC1B;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,gBAAgB,oDAAoD,aAAa,oCAAoC,KAAK;AACzK,0EAA0E,gBAAgB,oCAAoC,aAAa,oCAAoC,KAAK,KAAK;AACzL;;AAEA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,uJAAuJ,GAAG,6CAA6C;AACvM;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,2JAA2J,GAAG,6CAA6C;AAC3M;;AAEA;AACA;;AAEA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;;AAEA,KAAK;AACL;AACA,GAAG;AACH;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,gBAAgB,oDAAoD,eAAe,oCAAoC,KAAK;AAC3K,0EAA0E,gBAAgB,oCAAoC,cAAc,oCAAoC,KAAK,KAAK;AAC1L;;AAEA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL,GAAG;AACH;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mJAAmJ,oBAAoB;;AAEvK;AACA;AACA;AACA,WAAW;;AAEX;AACA,4CAA4C,KAAK,0BAA0B,oBAAoB;AAC/F;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA,mJAAmJ,aAAa;AAChK,+IAA+I,aAAa;AAC5J,yJAAyJ,aAAa;AACtK;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wDAAwD,SAAS;;AAEjE;AACA;AACA,SAAS;AACT,iEAAiE,UAAU;AAC3E;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA,SAAS;;AAET;AACA,iDAAiD,SAAS;AAC1D;AACA;;AAEA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,wIAAwI,UAAU;AAClJ;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B,2FAA2F,SAAS;AACpG;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,2FAA2F,SAAS;AACpG;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,SAAoB;AAChC;AACA,wBAAwB,KAAK,oDAAoD,SAAS,8EAA8E,KAAK;AAC7K;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,GAAG,SAAS;AAClI,+EAA+E,gBAAgB,+EAA+E,GAAG,GAAG,SAAS;AAC7L,uEAAuE,oBAAoB;AAC3F,sFAAsF,SAAS,SAAS,SAAS,OAAO,GAAG;AAC3H;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B,qIAAqI,mBAAmB;AACxJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,sDAAsD;;AAEtD;AACA;AACA,uBAAuB;;AAEvB;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,6CAA6C,gBAAgB,oDAAoD,GAAG,oCAAoC,KAAK;AAC7J,wEAAwE,gBAAgB,oCAAoC,GAAG,oCAAoC,KAAK;AACxK,uGAAuG,GAAG,cAAc,KAAK,4CAA4C,SAAS;AAClL;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,uCAAuC;AACvC;;AAEA;AACA,GAAG;;AAEH;AACA,uCAAuC;AACvC;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,uCAAuC;AACvC;;AAEA;AACA,GAAG;;AAEH;AACA,uCAAuC;AACvC;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,qEAAqE,oBAAoB;AACzF;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,qEAAqE,oBAAoB;AACzF;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,oJAAoJ,oBAAoB;AACxK,KAAK;AACL;;;AAGA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,wIAAwI,oBAAoB;AAC5J,KAAK;AACL;;;AAGA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,2IAA2I,oBAAoB;AAC/J,KAAK;AACL;;;AAGA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,+IAA+I,oBAAoB;AACnK,KAAK;AACL;;;AAGA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,iJAAiJ,oBAAoB;AACrK,KAAK;AACL;;;AAGA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B,uCAAuC;;AAEvC,oEAAoE,GAAG;AACvE;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,sBAAsB,YAAY;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,IAAI,SAAoB;AACxB;AACA;;AAEA;AACA,gDAAgD;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;;AAEhB;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,8EAA8E,gCAAgC;AAC9G;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,iBAAiB;;AAEtB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,cAAc;AACnB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,uDAAuD,eAAe,QAAQ,eAAe,MAAM,eAAe;AAClH;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,0DAA0D,eAAe,QAAQ,eAAe,MAAM,eAAe;AACrH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,8EAA8E,eAAe,MAAM,eAAe;AAClH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,YAAY;;AAEjB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,uEAAuE,eAAe,MAAM,eAAe;AAC3G;;AAEA;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,OAAO;AACP,kEAAkE,eAAe,QAAQ,eAAe,MAAM,eAAe;AAC7H;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI,SAAoB;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAiE;AACjE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mFAAmF;;AAEnF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;AACA,8EAA8E;;AAE9E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,GAAG,cAAc;AACvI,0EAA0E,gBAAgB,oCAAoC,GAAG,GAAG,cAAc;AAClJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK,EAAE;AACP;AACA;;AAEA,4BAA4B;;AAE5B;AACA,GAAG,aAAa;AAChB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA,mDAAmD;AACnD;;AAEA;AACA;;AAEA;AACA,gDAAgD,MAAM,kCAAkC,KAAK;;AAE7F,QAAQ,SAAoB;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,MAAM,kCAAkC,KAAK;AAC1F;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,gDAAgD,MAAM,kCAAkC,KAAK,MAAM,KAAK,yCAAyC,aAAa;AAC9J;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,SAAoB;AAChC;AACA,wBAAwB,KAAK,oDAAoD,cAAc,8EAA8E,KAAK;AAClL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,GAAG,cAAc;AACvI,0EAA0E,gBAAgB,oCAAoC,GAAG,GAAG,cAAc;AAClJ;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,uCAAuC;AACvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B,uFAAuF,cAAc;AACrG;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,SAAoB;AAC9B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA,+CAA+C,gBAAgB,oDAAoD,GAAG,GAAG,cAAc;AACvI,0EAA0E,gBAAgB,oCAAoC,GAAG,GAAG,cAAc;AAClJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO,UAAU,SAAoB;AACrC,uEAAuE,cAAc,MAAM,GAAG;AAC9F;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAAmH;;AAEnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,+BAA+B;;AAE/B;AACA;AACA,8BAA8B;;AAE9B;AACA,iCAAiC;;AAEjC,mBAAmB;;AAEnB;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA,yDAAyD;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,MAAM;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+DAA+D;AAC/D;;AAEA;AACA;;AAEA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;AAE7B;AACA,MAAM,SAAoB;AAC1B;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,wDAAwD,UAAU;AAClE;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,sDAAsD,UAAU;AAChE,KAAK;AACL,+FAA+F,oBAAoB,0BAA0B,KAAK;AAClJ,KAAK;AACL,sDAAsD,UAAU;AAChE;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,YAAY,SAAoB;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,YAAY,SAAoB;AAChC,qDAAqD,kBAAkB;AACvE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,YAAY,SAAoB;AAChC,oDAAoD,kBAAkB;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,OAAO;AAC7C;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,mCAAmC;;AAEnC,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D,sBAAsB;AAClF,GAAG;;;AAGH;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA,mEAAmE,sBAAsB;AACzF;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,+BAA+B;AAC/B,wDAAwD,eAAe,8DAA8D,SAAS;;AAE9I,+CAA+C,SAAS,gBAAgB,SAAS;AACjF;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;AACA;;;AAGA;;AAEA;AACA;AACA,wEAAwE;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG,iEAAiE;;;AAGpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,KAAK;AAClC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mEAAmE;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,gCAAgC;;AAEjC;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAK,iBAAiB;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK,QAAQ;AACb;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yCAAyC;AACzC;;AAEA,gCAAgC;AAChC;;AAEA,wCAAwC;;AAExC;AACA,GAAG;AACH;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B,qDAAqD,GAAG;AACxD;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,qCAAqC;;AAErC;AACA,wCAAwC,OAAO;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,sCAAsC,IAAI,8CAA8C,gBAAgB,qDAAqD;;AAE7J;AACA;;AAEA;AACA,uDAAuD,IAAI;AAC3D;;AAEA;AACA;AACA,sLAAsL,WAAW;AACjM;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;;AAEA;AACA,2CAA2C,gBAAgB,qBAAqB,gBAAgB;AAChG;AACA;;AAEA;AACA,CAAC;;AAED;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,4GAA4G;;AAE5G;AACA;;AAEA;AACA,uDAAuD,IAAI;AAC3D;;AAEA;AACA;AACA;AACA,wLAAwL,WAAW;AACnM;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,wDAAwD,mBAAmB,OAAO,gBAAgB;AAClG;;AAEA;AACA;;AAEA,MAAM,SAAoB;AAC1B,oGAAoG,mBAAmB,QAAQ,gBAAgB;AAC/I;;AAEA;;AAEA,MAAM,SAAoB;AAC1B,2FAA2F,mBAAmB,OAAO,gBAAgB;AACrI;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,yEAAyE,eAAe,QAAQ,gBAAgB,mBAAmB,EAAE,sBAAsB,eAAe;AAC1K;;AAEA;AACA,WAAW;AACX,mEAAmE,eAAe,QAAQ,gBAAgB,mBAAmB,EAAE;AAC/H;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA,uBAAuB;;AAEvB;;AAEA,iBAAiB,SAAS;AAC1B;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,SAAoB;AAC9B,0CAA0C,IAAI,OAAO,qBAAqB;AAC1E;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B,oCAAoC,GAAG;AACvC;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA,YAAY,GAAG,GAAG,oBAAoB;AACtC,CAAC;;AAED;AACA;;AAEA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA,cAAc,IAAI,GAAG,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA,+CAA+C,eAAe,uBAAuB,IAAI;AACzF;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA,mBAAmB,IAAI,GAAG,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,cAAc;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,GAAG,MAAM;;AAET;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,MAAM;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA,6BAA6B,cAAc;AAC3C,+BAA+B,gBAAgB;AAC/C;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,wDAAwD,GAAG;AAC5D;;;AAGA;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB,KAAK,MAAM,KAAK,OAAO;AACvD;;AAEA;AACA,YAAY,oBAAoB,KAAK,MAAM;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA,wGAAwG,6BAA6B,aAAa,SAAS,OAAO,GAAG;;AAErK;AACA;AACA;AACA,uDAAuD,SAAS,OAAO,GAAG;AAC1E;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;;AAEA;AACA;AACA,GAAG,MAAM;;AAET;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2CAA2C,GAAG,qBAAqB,SAAS;AAC5E;AACA,GAAG;AACH;;AAEA;AACA,MAAM,SAAoB;AAC1B,kHAAkH,eAAe;AACjI;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT;AACA,qFAAqF,GAAG,qEAAqE,YAAY,uCAAuC,eAAe;AAC/N;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,mEAAmE;;AAEnE;AACA;;AAEA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,SAAoB;AAC9B,2GAA2G,YAAY,IAAI;;AAE3H;AACA,OAAO;AACP;;;AAGA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA,GAAG;;AAEH,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,QAAQ,SAAoB;AAC5B;AACA;;AAEA;;AAEA;AACA,iDAAiD;;AAEjD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,GAAG,EAAE;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,sCAAsC;;AAEtC,UAAU,SAAoB;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,UAAU,SAAoB;AAC9B;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,QAAQ,SAAoB;AAC5B,wEAAwE,WAAW,OAAO,GAAG;AAC7F;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG,EAAE;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,MAAM,SAAoB;AAC1B,oCAAoC,GAAG;AACvC;;AAEA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B,2CAA2C,GAAG,+DAA+D,OAAO;AACpH;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA,6DAA6D,GAAG;AAChE,mEAAmE,GAAG,wCAAwC,gBAAgB;AAC9H,qEAAqE,GAAG,+CAA+C,gBAAgB;AACvI;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,uEAAuE,QAAQ;AAC/E;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK,MAAM;;AAEX,gBAAgB;;AAEhB;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA,CAAC;AACD;;;AAGA;AACA,MAAM,SAAoB;AAC1B,0FAA0F,GAAG;AAC7F;;AAEA;AACA;AACA;AACA,MAAM,SAAoB;AAC1B,kGAAkG,IAAI;AACtG;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA,2BAA2B,SAAS,IAAI,oBAAoB;AAC5D;AACA,GAAG;;;AAGH,6CAA6C;;AAE7C,wCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,sFAAsF,GAAG;AACzF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,YAAY,SAAoB;AAChC;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,MAAM,SAAoB;AAC1B,6JAA6J,eAAe;AAC5K;;AAEA;AACA,sBAAsB;;AAEtB,mCAAmC,SAAS;AAC5C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;;AAGP,yDAAyD;AACzD;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,WAAW;AACX;;AAEA,+BAA+B;;AAE/B;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B,wDAAwD,GAAG;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,QAAQ,SAAoB;AAC5B;AACA;;AAEA;;AAEA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,MAAM;;AAET,mDAAmD,QAAQ;AAC3D,gDAAgD;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;;AAGA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,iEAAiE;AACjE;AACA;AACA;;AAEA,oBAAoB,SAAS,GAAG,UAAU;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA,0BAA0B;;AAE1B,UAAU,SAAoB;AAC9B;AACA,OAAO;;;AAGP;AACA;;AAEA,UAAU,SAAoB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd,CAAC;AACD;;;AAGA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;;AAEA;AACA;AACA,wGAAwG,kBAAkB;AAC1H;;AAEA;;AAEA;AACA;AACA;;AAEA,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,SAAoB;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"lwc~main.app.js","sourcesContent":["/* proxy-compat-disable */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect() {\n  // Don't apply polyfill when ProxyCompat is enabled.\n  if ('getKey' in Proxy) {\n    return false;\n  }\n\n  const proxy = new Proxy([3, 4], {});\n  const res = [1, 2].concat(proxy);\n  return res.length !== 4;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  isConcatSpreadable\n} = Symbol;\nconst {\n  isArray\n} = Array;\nconst {\n  slice: ArraySlice,\n  unshift: ArrayUnshift,\n  shift: ArrayShift\n} = Array.prototype;\n\nfunction isObject(O) {\n  return typeof O === 'object' ? O !== null : typeof O === 'function';\n} // https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable\n\n\nfunction isSpreadable(O) {\n  if (!isObject(O)) {\n    return false;\n  }\n\n  const spreadable = O[isConcatSpreadable];\n  return spreadable !== undefined ? Boolean(spreadable) : isArray(O);\n} // https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat\n\n\nfunction ArrayConcatPolyfill(..._args) {\n  const O = Object(this);\n  const A = [];\n  let N = 0;\n  const items = ArraySlice.call(arguments);\n  ArrayUnshift.call(items, O);\n\n  while (items.length) {\n    const E = ArrayShift.call(items);\n\n    if (isSpreadable(E)) {\n      let k = 0;\n      const length = E.length;\n\n      for (k; k < length; k += 1, N += 1) {\n        if (k in E) {\n          const subElement = E[k];\n          A[N] = subElement;\n        }\n      }\n    } else {\n      A[N] = E;\n      N += 1;\n    }\n  }\n\n  return A;\n}\n\nfunction apply() {\n  Array.prototype.concat = ArrayConcatPolyfill;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nif (detect()) {\n  apply();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$1(propName) {\n  return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  getAttribute,\n  hasAttribute,\n  removeAttribute,\n  removeAttributeNS,\n  setAttribute,\n  setAttributeNS\n} = Element.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// that doesn't follow the regular transformation process. e.g.: `aria-labeledby` <=> `ariaLabelBy`\n\nconst ARIA_REGEX = /^aria/;\nconst nodeToAriaPropertyValuesMap = new WeakMap();\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst {\n  replace: StringReplace,\n  toLowerCase: StringToLowerCase\n} = String.prototype;\n\nfunction getAriaPropertyMap(elm) {\n  let map = nodeToAriaPropertyValuesMap.get(elm);\n\n  if (map === undefined) {\n    map = {};\n    nodeToAriaPropertyValuesMap.set(elm, map);\n  }\n\n  return map;\n}\n\nfunction getNormalizedAriaPropertyValue(value) {\n  return value == null ? null : value + '';\n}\n\nfunction createAriaPropertyPropertyDescriptor(propName, attrName) {\n  return {\n    get() {\n      const map = getAriaPropertyMap(this);\n\n      if (hasOwnProperty.call(map, propName)) {\n        return map[propName];\n      } // otherwise just reflect what's in the attribute\n\n\n      return hasAttribute.call(this, attrName) ? getAttribute.call(this, attrName) : null;\n    },\n\n    set(newValue) {\n      const normalizedValue = getNormalizedAriaPropertyValue(newValue);\n      const map = getAriaPropertyMap(this);\n      map[propName] = normalizedValue; // reflect into the corresponding attribute\n\n      if (newValue === null) {\n        removeAttribute.call(this, attrName);\n      } else {\n        setAttribute.call(this, attrName, newValue);\n      }\n    },\n\n    configurable: true,\n    enumerable: true\n  };\n}\n\nfunction patch(propName) {\n  // Typescript is inferring the wrong function type for this particular\n  // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n  // @ts-ignore type-mismatch\n  const replaced = StringReplace.call(propName, ARIA_REGEX, 'aria-');\n  const attrName = StringToLowerCase.call(replaced);\n  const descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);\n  Object.defineProperty(Element.prototype, propName, descriptor);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// https://wicg.github.io/aom/spec/aria-reflection.html\n\nconst ElementPrototypeAriaPropertyNames = ['ariaAutoComplete', 'ariaChecked', 'ariaCurrent', 'ariaDisabled', 'ariaExpanded', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaLabel', 'ariaLevel', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaPressed', 'ariaReadOnly', 'ariaRequired', 'ariaSelected', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'ariaLive', 'ariaRelevant', 'ariaAtomic', 'ariaBusy', 'ariaActiveDescendant', 'ariaControls', 'ariaDescribedBy', 'ariaFlowTo', 'ariaLabelledBy', 'ariaOwns', 'ariaPosInSet', 'ariaSetSize', 'ariaColCount', 'ariaColIndex', 'ariaDetails', 'ariaErrorMessage', 'ariaKeyShortcuts', 'ariaModal', 'ariaPlaceholder', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaColSpan', 'role'];\n/**\n * Note: Attributes aria-dropeffect and aria-grabbed were deprecated in\n * ARIA 1.1 and do not have corresponding IDL attributes.\n */\n\nfor (let i = 0, len = ElementPrototypeAriaPropertyNames.length; i < len; i += 1) {\n  const propName = ElementPrototypeAriaPropertyNames[i];\n\n  if (detect$1(propName)) {\n    patch(propName);\n  }\n}\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction invariant(value, msg) {\n  if (!value) {\n    throw new Error(`Invariant Violation: ${msg}`);\n  }\n}\n\nfunction isTrue(value, msg) {\n  if (!value) {\n    throw new Error(`Assert Violation: ${msg}`);\n  }\n}\n\nfunction isFalse(value, msg) {\n  if (value) {\n    throw new Error(`Assert Violation: ${msg}`);\n  }\n}\n\nfunction fail(msg) {\n  throw new Error(msg);\n}\n\nvar assert = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  invariant: invariant,\n  isTrue: isTrue,\n  isFalse: isFalse,\n  fail: fail\n});\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Global Aria and Role Properties derived from ARIA and Role Attributes.\n// https://wicg.github.io/aom/spec/aria-reflection.html\n\nconst AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst {\n  assign,\n  create,\n  defineProperties,\n  defineProperty,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getPrototypeOf,\n  hasOwnProperty: hasOwnProperty$1,\n  keys,\n  seal,\n  setPrototypeOf\n} = Object;\nconst {\n  isArray: isArray$1\n} = Array;\nconst {\n  filter: ArrayFilter,\n  find: ArrayFind,\n  indexOf: ArrayIndexOf,\n  join: ArrayJoin,\n  map: ArrayMap,\n  push: ArrayPush,\n  reduce: ArrayReduce,\n  reverse: ArrayReverse,\n  slice: ArraySlice$1,\n  splice: ArraySplice,\n  unshift: ArrayUnshift$1,\n  forEach\n} = Array.prototype;\nconst {\n  charCodeAt: StringCharCodeAt,\n  replace: StringReplace$1,\n  slice: StringSlice,\n  toLowerCase: StringToLowerCase$1\n} = String.prototype;\n\nfunction isUndefined(obj) {\n  return obj === undefined;\n}\n\nfunction isNull(obj) {\n  return obj === null;\n}\n\nfunction isTrue$1(obj) {\n  return obj === true;\n}\n\nfunction isFalse$1(obj) {\n  return obj === false;\n}\n\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n\nfunction isObject$1(obj) {\n  return typeof obj === 'object';\n}\n\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n\nconst OtS = {}.toString;\n\nfunction toString(obj) {\n  if (obj && obj.toString) {\n    // Arrays might hold objects with \"null\" prototype So using\n    // Array.prototype.toString directly will cause an error Iterate through\n    // all the items and handle individually.\n    if (isArray$1(obj)) {\n      return ArrayJoin.call(ArrayMap.call(obj, toString), ',');\n    }\n\n    return obj.toString();\n  } else if (typeof obj === 'object') {\n    return OtS.call(obj);\n  } else {\n    return obj + emptyString;\n  }\n}\n\nfunction getPropertyDescriptor(o, p) {\n  do {\n    const d = getOwnPropertyDescriptor(o, p);\n\n    if (!isUndefined(d)) {\n      return d;\n    }\n\n    o = getPrototypeOf(o);\n  } while (o !== null);\n}\n\nconst emptyString = '';\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/*\n * In IE11, symbols are expensive.\n * Due to the nature of the symbol polyfill. This method abstract the\n * creation of symbols, so we can fallback to string when native symbols\n * are not supported. Note that we can't use typeof since it will fail when transpiling.\n */\n\nconst hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';\n\nfunction createHiddenField(key, namespace) {\n  return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${namespace}-${key}$$`;\n}\n\nconst hiddenFieldsMap = new WeakMap();\n\nfunction setHiddenField(o, field, value) {\n  let valuesByField = hiddenFieldsMap.get(o);\n\n  if (isUndefined(valuesByField)) {\n    valuesByField = create(null);\n    hiddenFieldsMap.set(o, valuesByField);\n  }\n\n  valuesByField[field] = value;\n}\n\nfunction getHiddenField(o, field) {\n  const valuesByField = hiddenFieldsMap.get(o);\n\n  if (!isUndefined(valuesByField)) {\n    return valuesByField[field];\n  }\n}\n/** version: 1.6.2 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  appendChild,\n  insertBefore,\n  removeChild,\n  replaceChild\n} = Node.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getComponentTag(vm) {\n  // Element.prototype.tagName getter might be poisoned. We need to use a try/catch to protect the\n  // engine internal when accessing the tagName property.\n  try {\n    return `<${StringToLowerCase$1.call(vm.elm.tagName)}>`;\n  } catch (error) {\n    return '<invalid-tag-name>';\n  }\n} // TODO [#1695]: Unify getComponentStack and getErrorComponentStack\n\nfunction getComponentStack(vm) {\n  const stack = [];\n  let prefix = '';\n\n  while (!isNull(vm.owner)) {\n    ArrayPush.call(stack, prefix + getComponentTag(vm));\n    vm = vm.owner;\n    prefix += '\\t';\n  }\n\n  return ArrayJoin.call(stack, '\\n');\n}\nfunction getErrorComponentStack(vm) {\n  const wcStack = [];\n  let currentVm = vm;\n\n  while (!isNull(currentVm)) {\n    ArrayPush.call(wcStack, getComponentTag(currentVm));\n    currentVm = currentVm.owner;\n  }\n\n  return wcStack.reverse().join('\\n\\t');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction logError(message, vm) {\n  let msg = `[LWC error]: ${message}`;\n\n  if (!isUndefined(vm)) {\n    msg = `${msg}\\n${getComponentStack(vm)}`;\n  }\n\n  if (process.env.NODE_ENV === 'test') {\n    /* eslint-disable-next-line no-console */\n    console.error(msg);\n    return;\n  }\n\n  try {\n    throw new Error(msg);\n  } catch (e) {\n    /* eslint-disable-next-line no-console */\n    console.error(e);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet nextTickCallbackQueue = [];\nconst SPACE_CHAR = 32;\nconst EmptyObject = seal(create(null));\nconst EmptyArray = seal([]);\n\nfunction flushCallbackQueue() {\n  if (process.env.NODE_ENV !== 'production') {\n    if (nextTickCallbackQueue.length === 0) {\n      throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);\n    }\n  }\n\n  const callbacks = nextTickCallbackQueue;\n  nextTickCallbackQueue = []; // reset to a new queue\n\n  for (let i = 0, len = callbacks.length; i < len; i += 1) {\n    callbacks[i]();\n  }\n}\n\nfunction addCallbackToNextTick(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isFunction(callback)) {\n      throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);\n    }\n  }\n\n  if (nextTickCallbackQueue.length === 0) {\n    Promise.resolve().then(flushCallbackQueue);\n  }\n\n  ArrayPush.call(nextTickCallbackQueue, callback);\n}\nconst useSyntheticShadow = hasOwnProperty$1.call(Element.prototype, '$shadowToken$');\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction handleEvent(event, vnode) {\n  const {\n    type\n  } = event;\n  const {\n    data: {\n      on\n    }\n  } = vnode;\n  const handler = on && on[type]; // call event handler if exists\n\n  if (handler) {\n    handler.call(undefined, event);\n  }\n}\n\nfunction createListener() {\n  return function handler(event) {\n    handleEvent(event, handler.vnode);\n  };\n}\n\nfunction updateAllEventListeners(oldVnode, vnode) {\n  if (isUndefined(oldVnode.listener)) {\n    createAllEventListeners(vnode);\n  } else {\n    vnode.listener = oldVnode.listener;\n    vnode.listener.vnode = vnode;\n  }\n}\n\nfunction createAllEventListeners(vnode) {\n  const {\n    data: {\n      on\n    }\n  } = vnode;\n\n  if (isUndefined(on)) {\n    return;\n  }\n\n  const elm = vnode.elm;\n  const listener = vnode.listener = createListener();\n  listener.vnode = vnode;\n  let name;\n\n  for (name in on) {\n    elm.addEventListener(name, listener);\n  }\n}\n\nvar modEvents = {\n  update: updateAllEventListeners,\n  create: createAllEventListeners\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst defaultDefHTMLPropertyNames = ['accessKey', 'dir', 'draggable', 'hidden', 'id', 'lang', 'spellcheck', 'tabIndex', 'title']; // Few more exceptions that are using the attribute name to match the property in lowercase.\n// this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx\n// and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n// Note: this list most be in sync with the compiler as well.\n\nconst HTMLPropertyNamesWithLowercasedReflectiveAttributes = ['accessKey', 'readOnly', 'tabIndex', 'bgColor', 'colSpan', 'rowSpan', 'contentEditable', 'dateTime', 'formAction', 'isMap', 'maxLength', 'useMap'];\n\nfunction offsetPropertyErrorMessage(name) {\n  return `Using the \\`${name}\\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \\`getBoundingClientRect\\` method to obtain fractional values for the size of an element and its position relative to the viewport.`;\n} // Global HTML Attributes & Properties\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n\n\nconst globalHTMLProperties = assign(create(null), {\n  accessKey: {\n    attribute: 'accesskey'\n  },\n  accessKeyLabel: {\n    readOnly: true\n  },\n  className: {\n    attribute: 'class',\n    error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.'\n  },\n  contentEditable: {\n    attribute: 'contenteditable'\n  },\n  dataset: {\n    readOnly: true,\n    error: \"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead.\"\n  },\n  dir: {\n    attribute: 'dir'\n  },\n  draggable: {\n    attribute: 'draggable'\n  },\n  dropzone: {\n    attribute: 'dropzone',\n    readOnly: true\n  },\n  hidden: {\n    attribute: 'hidden'\n  },\n  id: {\n    attribute: 'id'\n  },\n  inputMode: {\n    attribute: 'inputmode'\n  },\n  lang: {\n    attribute: 'lang'\n  },\n  slot: {\n    attribute: 'slot',\n    error: 'Using the `slot` property is an anti-pattern.'\n  },\n  spellcheck: {\n    attribute: 'spellcheck'\n  },\n  style: {\n    attribute: 'style'\n  },\n  tabIndex: {\n    attribute: 'tabindex'\n  },\n  title: {\n    attribute: 'title'\n  },\n  translate: {\n    attribute: 'translate'\n  },\n  // additional \"global attributes\" that are not present in the link above.\n  isContentEditable: {\n    readOnly: true\n  },\n  offsetHeight: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetHeight')\n  },\n  offsetLeft: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetLeft')\n  },\n  offsetParent: {\n    readOnly: true\n  },\n  offsetTop: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetTop')\n  },\n  offsetWidth: {\n    readOnly: true,\n    error: offsetPropertyErrorMessage('offsetWidth')\n  },\n  role: {\n    attribute: 'role'\n  }\n});\nconst AttrNameToPropNameMap = create(null);\nconst PropNameToAttrNameMap = create(null); // Synthetic creation of all AOM property descriptors for Custom Elements\n\nforEach.call(AriaPropertyNames, propName => {\n  // Typescript is inferring the wrong function type for this particular\n  // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n  // @ts-ignore type-mismatch\n  const attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, 'aria-'));\n  AttrNameToPropNameMap[attrName] = propName;\n  PropNameToAttrNameMap[propName] = attrName;\n});\nforEach.call(defaultDefHTMLPropertyNames, propName => {\n  const attrName = StringToLowerCase$1.call(propName);\n  AttrNameToPropNameMap[attrName] = propName;\n  PropNameToAttrNameMap[propName] = attrName;\n});\nforEach.call(HTMLPropertyNamesWithLowercasedReflectiveAttributes, propName => {\n  const attrName = StringToLowerCase$1.call(propName);\n  AttrNameToPropNameMap[attrName] = propName;\n  PropNameToAttrNameMap[propName] = attrName;\n});\nconst CAPS_REGEX = /[A-Z]/g;\n/**\n * This method maps between property names\n * and the corresponding attribute name.\n */\n\nfunction getAttrNameFromPropName(propName) {\n  if (isUndefined(PropNameToAttrNameMap[propName])) {\n    PropNameToAttrNameMap[propName] = StringReplace$1.call(propName, CAPS_REGEX, match => '-' + match.toLowerCase());\n  }\n\n  return PropNameToAttrNameMap[propName];\n}\nlet controlledElement = null;\nlet controlledAttributeName;\nfunction isAttributeLocked(elm, attrName) {\n  return elm !== controlledElement || attrName !== controlledAttributeName;\n}\nfunction lockAttribute(_elm, _key) {\n  controlledElement = null;\n  controlledAttributeName = undefined;\n}\nfunction unlockAttribute(elm, key) {\n  controlledElement = elm;\n  controlledAttributeName = key;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace';\nconst ColonCharCode = 58;\n\nfunction updateAttrs(oldVnode, vnode) {\n  const {\n    data: {\n      attrs\n    }\n  } = vnode;\n\n  if (isUndefined(attrs)) {\n    return;\n  }\n\n  let {\n    data: {\n      attrs: oldAttrs\n    }\n  } = oldVnode;\n\n  if (oldAttrs === attrs) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isUndefined(oldAttrs) || keys(oldAttrs).join(',') === keys(attrs).join(','), `vnode.data.attrs cannot change shape.`);\n  }\n\n  const elm = vnode.elm;\n  let key;\n  oldAttrs = isUndefined(oldAttrs) ? EmptyObject : oldAttrs; // update modified attributes, add new attributes\n  // this routine is only useful for data-* attributes in all kind of elements\n  // and aria-* in standard elements (custom elements will use props for these)\n\n  for (key in attrs) {\n    const cur = attrs[key];\n    const old = oldAttrs[key];\n\n    if (old !== cur) {\n      unlockAttribute(elm, key);\n\n      if (StringCharCodeAt.call(key, 3) === ColonCharCode) {\n        // Assume xml namespace\n        elm.setAttributeNS(xmlNS, key, cur);\n      } else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {\n        // Assume xlink namespace\n        elm.setAttributeNS(xlinkNS, key, cur);\n      } else if (isNull(cur)) {\n        elm.removeAttribute(key);\n      } else {\n        elm.setAttribute(key, cur);\n      }\n\n      lockAttribute();\n    }\n  }\n}\n\nconst emptyVNode = {\n  data: {}\n};\nvar modAttrs = {\n  create: vnode => updateAttrs(emptyVNode, vnode),\n  update: updateAttrs\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction isLiveBindingProp(sel, key) {\n  // For properties with live bindings, we read values from the DOM element\n  // instead of relying on internally tracked values.\n  return sel === 'input' && (key === 'value' || key === 'checked');\n}\n\nfunction update(oldVnode, vnode) {\n  const props = vnode.data.props;\n\n  if (isUndefined(props)) {\n    return;\n  }\n\n  const oldProps = oldVnode.data.props;\n\n  if (oldProps === props) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isUndefined(oldProps) || keys(oldProps).join(',') === keys(props).join(','), 'vnode.data.props cannot change shape.');\n  }\n\n  const elm = vnode.elm;\n  const isFirstPatch = isUndefined(oldProps);\n  const {\n    sel\n  } = vnode;\n\n  for (const key in props) {\n    const cur = props[key];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(key in elm)) {\n        // TODO [#1297]: Move this validation to the compiler\n        assert.fail(`Unknown public property \"${key}\" of element <${sel}>. This is likely a typo on the corresponding attribute \"${getAttrNameFromPropName(key)}\".`);\n      }\n    } // if it is the first time this element is patched, or the current value is different to the previous value...\n\n\n    if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {\n      elm[key] = cur;\n    }\n  }\n}\n\nconst emptyVNode$1 = {\n  data: {}\n};\nvar modProps = {\n  create: vnode => update(emptyVNode$1, vnode),\n  update\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst classNameToClassMap = create(null);\n\nfunction getMapFromClassName(className) {\n  // Intentionally using == to match undefined and null values from computed style attribute\n  if (className == null) {\n    return EmptyObject;\n  } // computed class names must be string\n\n\n  className = isString(className) ? className : className + '';\n  let map = classNameToClassMap[className];\n\n  if (map) {\n    return map;\n  }\n\n  map = create(null);\n  let start = 0;\n  let o;\n  const len = className.length;\n\n  for (o = 0; o < len; o++) {\n    if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {\n      if (o > start) {\n        map[StringSlice.call(className, start, o)] = true;\n      }\n\n      start = o + 1;\n    }\n  }\n\n  if (o > start) {\n    map[StringSlice.call(className, start, o)] = true;\n  }\n\n  classNameToClassMap[className] = map;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // just to make sure that this object never changes as part of the diffing algo\n    freeze(map);\n  }\n\n  return map;\n}\n\nfunction updateClassAttribute(oldVnode, vnode) {\n  const {\n    elm,\n    data: {\n      className: newClass\n    }\n  } = vnode;\n  const {\n    data: {\n      className: oldClass\n    }\n  } = oldVnode;\n\n  if (oldClass === newClass) {\n    return;\n  }\n\n  const {\n    classList\n  } = elm;\n  const newClassMap = getMapFromClassName(newClass);\n  const oldClassMap = getMapFromClassName(oldClass);\n  let name;\n\n  for (name in oldClassMap) {\n    // remove only if it is not in the new class collection and it is not set from within the instance\n    if (isUndefined(newClassMap[name])) {\n      classList.remove(name);\n    }\n  }\n\n  for (name in newClassMap) {\n    if (isUndefined(oldClassMap[name])) {\n      classList.add(name);\n    }\n  }\n}\n\nconst emptyVNode$2 = {\n  data: {}\n};\nvar modComputedClassName = {\n  create: vnode => updateClassAttribute(emptyVNode$2, vnode),\n  update: updateClassAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction updateStyleAttribute(oldVnode, vnode) {\n  const {\n    style: newStyle\n  } = vnode.data;\n\n  if (oldVnode.data.style === newStyle) {\n    return;\n  }\n\n  const elm = vnode.elm;\n  const {\n    style\n  } = elm;\n\n  if (!isString(newStyle) || newStyle === '') {\n    removeAttribute.call(elm, 'style');\n  } else {\n    style.cssText = newStyle;\n  }\n}\n\nconst emptyVNode$3 = {\n  data: {}\n};\nvar modComputedStyle = {\n  create: vnode => updateStyleAttribute(emptyVNode$3, vnode),\n  update: updateStyleAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The compiler takes care of transforming the inline classnames into an object. It's faster to set the\n// different classnames properties individually instead of via a string.\n\nfunction createClassAttribute(vnode) {\n  const {\n    elm,\n    data: {\n      classMap\n    }\n  } = vnode;\n\n  if (isUndefined(classMap)) {\n    return;\n  }\n\n  const {\n    classList\n  } = elm;\n\n  for (const name in classMap) {\n    classList.add(name);\n  }\n}\n\nvar modStaticClassName = {\n  create: createClassAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The compiler takes care of transforming the inline style into an object. It's faster to set the\n// different style properties individually instead of via a string.\n\nfunction createStyleAttribute(vnode) {\n  const {\n    elm,\n    data: {\n      styleMap\n    }\n  } = vnode;\n\n  if (isUndefined(styleMap)) {\n    return;\n  }\n\n  const {\n    style\n  } = elm;\n\n  for (const name in styleMap) {\n    style[name] = styleMap[name];\n  }\n}\n\nvar modStaticStyle = {\n  create: createStyleAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/**\n@license\nCopyright (c) 2015 Simon Friis Vindum.\nThis code may only be used under the MIT License found at\nhttps://github.com/snabbdom/snabbdom/blob/master/LICENSE\nCode distributed by Snabbdom as part of the Snabbdom project at\nhttps://github.com/snabbdom/snabbdom/\n*/\nfunction isUndef(s) {\n  return s === undefined;\n}\n\nfunction sameVnode(vnode1, vnode2) {\n  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\n\nfunction isVNode(vnode) {\n  return vnode != null;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  const map = {};\n  let j, key, ch; // TODO [#1637]: simplify this by assuming that all vnodes has keys\n\n  for (j = beginIdx; j <= endIdx; ++j) {\n    ch = children[j];\n\n    if (isVNode(ch)) {\n      key = ch.key;\n\n      if (key !== undefined) {\n        map[key] = j;\n      }\n    }\n  }\n\n  return map;\n}\n\nfunction addVnodes(parentElm, before, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx];\n\n    if (isVNode(ch)) {\n      ch.hook.create(ch);\n      ch.hook.insert(ch, parentElm, before);\n    }\n  }\n}\n\nfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx]; // text nodes do not have logic associated to them\n\n    if (isVNode(ch)) {\n      ch.hook.remove(ch, parentElm);\n    }\n  }\n}\n\nfunction updateDynamicChildren(parentElm, oldCh, newCh) {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let oldKeyToIdx;\n  let idxInOld;\n  let elmToMove;\n  let before;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (!isVNode(oldStartVnode)) {\n      oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n    } else if (!isVNode(oldEndVnode)) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (!isVNode(newStartVnode)) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (!isVNode(newEndVnode)) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n      // Vnode moved right\n      patchVnode(oldStartVnode, newEndVnode);\n      newEndVnode.hook.move(oldStartVnode, parentElm, oldEndVnode.elm.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n      // Vnode moved left\n      patchVnode(oldEndVnode, newStartVnode);\n      newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      if (oldKeyToIdx === undefined) {\n        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n      }\n\n      idxInOld = oldKeyToIdx[newStartVnode.key];\n\n      if (isUndef(idxInOld)) {\n        // New element\n        newStartVnode.hook.create(newStartVnode);\n        newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        elmToMove = oldCh[idxInOld];\n\n        if (isVNode(elmToMove)) {\n          if (elmToMove.sel !== newStartVnode.sel) {\n            // New element\n            newStartVnode.hook.create(newStartVnode);\n            newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n          } else {\n            patchVnode(elmToMove, newStartVnode);\n            oldCh[idxInOld] = undefined;\n            newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);\n          }\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n  }\n\n  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n    if (oldStartIdx > oldEndIdx) {\n      const n = newCh[newEndIdx + 1];\n      before = isVNode(n) ? n.elm : null;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);\n    } else {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n}\nfunction updateStaticChildren(parentElm, oldCh, newCh) {\n  const {\n    length\n  } = newCh;\n\n  if (oldCh.length === 0) {\n    // the old list is empty, we can directly insert anything new\n    addVnodes(parentElm, null, newCh, 0, length);\n    return;\n  } // if the old list is not empty, the new list MUST have the same\n  // amount of nodes, that's why we call this static children\n\n\n  let referenceElm = null;\n\n  for (let i = length - 1; i >= 0; i -= 1) {\n    const vnode = newCh[i];\n    const oldVNode = oldCh[i];\n\n    if (vnode !== oldVNode) {\n      if (isVNode(oldVNode)) {\n        if (isVNode(vnode)) {\n          // both vnodes must be equivalent, and se just need to patch them\n          patchVnode(oldVNode, vnode);\n          referenceElm = vnode.elm;\n        } else {\n          // removing the old vnode since the new one is null\n          oldVNode.hook.remove(oldVNode, parentElm);\n        }\n      } else if (isVNode(vnode)) {\n        // this condition is unnecessary\n        vnode.hook.create(vnode); // insert the new node one since the old one is null\n\n        vnode.hook.insert(vnode, parentElm, referenceElm);\n        referenceElm = vnode.elm;\n      }\n    }\n  }\n}\n\nfunction patchVnode(oldVnode, vnode) {\n  if (oldVnode !== vnode) {\n    vnode.elm = oldVnode.elm;\n    vnode.hook.update(oldVnode, vnode);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction generateDataDescriptor(options) {\n  return assign({\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }, options);\n}\n\nfunction generateAccessorDescriptor(options) {\n  return assign({\n    configurable: true,\n    enumerable: true\n  }, options);\n}\n\nlet isDomMutationAllowed = false;\nfunction unlockDomMutation() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  isDomMutationAllowed = true;\n}\nfunction lockDomMutation() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  isDomMutationAllowed = false;\n}\n\nfunction portalRestrictionErrorMessage(name, type) {\n  return `The \\`${name}\\` ${type} is available only on elements that use the \\`lwc:dom=\"manual\"\\` directive.`;\n}\n\nfunction getNodeRestrictionsDescriptors(node, options = {}) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  } // getPropertyDescriptor here recursively looks up the prototype chain\n  // and returns the first descriptor for the property\n\n\n  const originalTextContentDescriptor = getPropertyDescriptor(node, 'textContent');\n  const originalNodeValueDescriptor = getPropertyDescriptor(node, 'nodeValue');\n  const {\n    appendChild,\n    insertBefore,\n    removeChild,\n    replaceChild\n  } = node;\n  return {\n    appendChild: generateDataDescriptor({\n      value(aChild) {\n        if (this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('appendChild', 'method'));\n        }\n\n        return appendChild.call(this, aChild);\n      }\n\n    }),\n    insertBefore: generateDataDescriptor({\n      value(newNode, referenceNode) {\n        if (!isDomMutationAllowed && this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('insertBefore', 'method'));\n        }\n\n        return insertBefore.call(this, newNode, referenceNode);\n      }\n\n    }),\n    removeChild: generateDataDescriptor({\n      value(aChild) {\n        if (!isDomMutationAllowed && this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('removeChild', 'method'));\n        }\n\n        return removeChild.call(this, aChild);\n      }\n\n    }),\n    replaceChild: generateDataDescriptor({\n      value(newChild, oldChild) {\n        if (this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('replaceChild', 'method'));\n        }\n\n        return replaceChild.call(this, newChild, oldChild);\n      }\n\n    }),\n    nodeValue: generateAccessorDescriptor({\n      get() {\n        return originalNodeValueDescriptor.get.call(this);\n      },\n\n      set(value) {\n        if (!isDomMutationAllowed && this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('nodeValue', 'property'));\n        }\n\n        originalNodeValueDescriptor.set.call(this, value);\n      }\n\n    }),\n    textContent: generateAccessorDescriptor({\n      get() {\n        return originalTextContentDescriptor.get.call(this);\n      },\n\n      set(value) {\n        if (this instanceof Element && isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('textContent', 'property'));\n        }\n\n        originalTextContentDescriptor.set.call(this, value);\n      }\n\n    })\n  };\n}\n\nfunction getElementRestrictionsDescriptors(elm, options) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const descriptors = getNodeRestrictionsDescriptors(elm, options);\n  const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n  const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n  assign(descriptors, {\n    innerHTML: generateAccessorDescriptor({\n      get() {\n        return originalInnerHTMLDescriptor.get.call(this);\n      },\n\n      set(value) {\n        if (isFalse$1(options.isPortal)) {\n          logError(portalRestrictionErrorMessage('innerHTML', 'property'), getAssociatedVMIfPresent(this));\n        }\n\n        return originalInnerHTMLDescriptor.set.call(this, value);\n      }\n\n    }),\n    outerHTML: generateAccessorDescriptor({\n      get() {\n        return originalOuterHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set outerHTML on Element.`);\n      }\n\n    })\n  });\n  return descriptors;\n}\n\nfunction getShadowRootRestrictionsDescriptors(sr) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  } // Disallowing properties in dev mode only to avoid people doing the wrong\n  // thing when using the real shadow root, because if that's the case,\n  // the component will not work when running with synthetic shadow.\n\n\n  const originalQuerySelector = sr.querySelector;\n  const originalQuerySelectorAll = sr.querySelectorAll;\n  const originalAddEventListener = sr.addEventListener;\n  const descriptors = getNodeRestrictionsDescriptors(sr);\n  const originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');\n  const originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');\n  assign(descriptors, {\n    innerHTML: generateAccessorDescriptor({\n      get() {\n        return originalInnerHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set innerHTML on ShadowRoot.`);\n      }\n\n    }),\n    textContent: generateAccessorDescriptor({\n      get() {\n        return originalTextContentDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set textContent on ShadowRoot.`);\n      }\n\n    }),\n    addEventListener: generateDataDescriptor({\n      value(type, listener, options) {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${toString(sr)} by adding an event listener for \"${type}\".`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${toString(sr)} by adding an event listener for \"${type}\".`); // TODO [#420]: this is triggered when the component author attempts to add a listener\n        // programmatically into its Component's shadow root\n\n        if (!isUndefined(options)) {\n          logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalAddEventListener.apply(this, arguments);\n      }\n\n    }),\n    querySelector: generateDataDescriptor({\n      value() {\n        const vm = getAssociatedVM(this);\n        assert.isFalse(isBeingConstructed(vm), `this.template.querySelector() cannot be called during the construction of the` + `custom element for ${vm} because no content has been rendered yet.`); // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n        return originalQuerySelector.apply(this, arguments);\n      }\n\n    }),\n    querySelectorAll: generateDataDescriptor({\n      value() {\n        const vm = getAssociatedVM(this);\n        assert.isFalse(isBeingConstructed(vm), `this.template.querySelectorAll() cannot be called during the construction of the` + ` custom element for ${vm} because no content has been rendered yet.`); // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n        return originalQuerySelectorAll.apply(this, arguments);\n      }\n\n    })\n  });\n  const BlockedShadowRootMethods = {\n    cloneNode: 0,\n    getElementById: 0,\n    getSelection: 0,\n    elementsFromPoint: 0,\n    dispatchEvent: 0\n  };\n  forEach.call(getOwnPropertyNames(BlockedShadowRootMethods), methodName => {\n    const descriptor = generateAccessorDescriptor({\n      get() {\n        throw new Error(`Disallowed method \"${methodName}\" in ShadowRoot.`);\n      }\n\n    });\n    descriptors[methodName] = descriptor;\n  });\n  return descriptors;\n} // Custom Elements Restrictions:\n// -----------------------------\n\n\nfunction getCustomElementRestrictionsDescriptors(elm) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const descriptors = getNodeRestrictionsDescriptors(elm);\n  const originalAddEventListener = elm.addEventListener;\n  const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n  const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n  const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n  return assign(descriptors, {\n    innerHTML: generateAccessorDescriptor({\n      get() {\n        return originalInnerHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set innerHTML on HTMLElement.`);\n      }\n\n    }),\n    outerHTML: generateAccessorDescriptor({\n      get() {\n        return originalOuterHTMLDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set outerHTML on HTMLElement.`);\n      }\n\n    }),\n    textContent: generateAccessorDescriptor({\n      get() {\n        return originalTextContentDescriptor.get.call(this);\n      },\n\n      set(_value) {\n        throw new TypeError(`Invalid attempt to set textContent on HTMLElement.`);\n      }\n\n    }),\n    addEventListener: generateDataDescriptor({\n      value(type, listener, options) {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${toString(this)} by adding an event listener for \"${type}\".`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${toString(elm)} by adding an event listener for \"${type}\".`); // TODO [#420]: this is triggered when the component author attempts to add a listener\n        // programmatically into a lighting element node\n\n        if (!isUndefined(options)) {\n          logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalAddEventListener.apply(this, arguments);\n      }\n\n    })\n  });\n}\n\nfunction getComponentRestrictionsDescriptors() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  return {\n    tagName: generateAccessorDescriptor({\n      get() {\n        throw new Error(`Usage of property \\`tagName\\` is disallowed because the component itself does` + ` not know which tagName will be used to create the element, therefore writing` + ` code that check for that value is error prone.`);\n      },\n\n      configurable: true,\n      enumerable: false\n    })\n  };\n}\n\nfunction getLightningElementPrototypeRestrictionsDescriptors(proto) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const originalDispatchEvent = proto.dispatchEvent;\n  const originalIsConnectedGetter = getOwnPropertyDescriptor(proto, 'isConnected').get;\n  const descriptors = {\n    dispatchEvent: generateDataDescriptor({\n      value(event) {\n        const vm = getAssociatedVM(this);\n        assert.isFalse(isBeingConstructed(vm), `this.dispatchEvent() should not be called during the construction of the custom` + ` element for ${getComponentTag(vm)} because no one is listening just yet.`);\n\n        if (!isNull(event) && isObject$1(event)) {\n          const {\n            type\n          } = event;\n\n          if (!/^[a-z][a-z0-9_]*$/.test(type)) {\n            logError(`Invalid event type \"${type}\" dispatched in element ${getComponentTag(vm)}.` + ` Event name must start with a lowercase letter and followed only lowercase` + ` letters, numbers, and underscores`, vm);\n          }\n        } // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n\n\n        return originalDispatchEvent.apply(this, arguments);\n      }\n\n    }),\n    isConnected: generateAccessorDescriptor({\n      get() {\n        const vm = getAssociatedVM(this);\n        const componentTag = getComponentTag(vm);\n        assert.isFalse(isBeingConstructed(vm), `this.isConnected should not be accessed during the construction phase of the custom` + ` element ${componentTag}. The value will always be` + ` false for Lightning Web Components constructed using lwc.createElement().`);\n        assert.isFalse(isVMBeingRendered(vm), `this.isConnected should not be accessed during the rendering phase of the custom` + ` element ${componentTag}. The value will always be true.`);\n        assert.isFalse(isInvokingRenderedCallback(vm), `this.isConnected should not be accessed during the renderedCallback of the custom` + ` element ${componentTag}. The value will always be true.`);\n        return originalIsConnectedGetter.call(this);\n      }\n\n    })\n  };\n  forEach.call(getOwnPropertyNames(globalHTMLProperties), propName => {\n    if (propName in proto) {\n      return; // no need to redefine something that we are already exposing\n    }\n\n    descriptors[propName] = generateAccessorDescriptor({\n      get() {\n        const {\n          error,\n          attribute\n        } = globalHTMLProperties[propName];\n        const msg = [];\n        msg.push(`Accessing the global HTML property \"${propName}\" is disabled.`);\n\n        if (error) {\n          msg.push(error);\n        } else if (attribute) {\n          msg.push(`Instead access it via \\`this.getAttribute(\"${attribute}\")\\`.`);\n        }\n\n        logError(msg.join('\\n'), getAssociatedVM(this));\n      },\n\n      set() {\n        const {\n          readOnly\n        } = globalHTMLProperties[propName];\n\n        if (readOnly) {\n          logError(`The global HTML property \\`${propName}\\` is read-only.`, getAssociatedVM(this));\n        }\n      }\n\n    });\n  });\n  return descriptors;\n}\n\nfunction patchElementWithRestrictions(elm, options) {\n  defineProperties(elm, getElementRestrictionsDescriptors(elm, options));\n} // This routine will prevent access to certain properties on a shadow root instance to guarantee\n// that all components will work fine in IE11 and other browsers without shadow dom support.\n\nfunction patchShadowRootWithRestrictions(sr) {\n  defineProperties(sr, getShadowRootRestrictionsDescriptors(sr));\n}\nfunction patchCustomElementWithRestrictions(elm) {\n  const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm);\n  const elmProto = getPrototypeOf(elm);\n  setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));\n}\nfunction patchComponentWithRestrictions(cmp) {\n  defineProperties(cmp, getComponentRestrictionsDescriptors());\n}\nfunction patchLightningElementPrototypeWithRestrictions(proto) {\n  defineProperties(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This is a descriptor map that contains\n * all standard properties that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base HTML Element and\n * Base Lightning Element should support.\n */\n\nconst HTMLElementOriginalDescriptors = create(null);\nforEach.call(AriaPropertyNames, propName => {\n  // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n  // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.\n  const descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);\n\n  if (!isUndefined(descriptor)) {\n    HTMLElementOriginalDescriptors[propName] = descriptor;\n  }\n});\nforEach.call(defaultDefHTMLPropertyNames, propName => {\n  // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n  // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into\n  // this category, so, better to be sure.\n  const descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);\n\n  if (!isUndefined(descriptor)) {\n    HTMLElementOriginalDescriptors[propName] = descriptor;\n  }\n});\n\n/*\n * Copyright (c) 2019, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  create: create$1\n} = Object;\nconst {\n  splice: ArraySplice$1,\n  indexOf: ArrayIndexOf$1,\n  push: ArrayPush$1\n} = Array.prototype;\nconst TargetToReactiveRecordMap = new WeakMap();\n\nfunction isUndefined$1(obj) {\n  return obj === undefined;\n}\n\nfunction getReactiveRecord(target) {\n  let reactiveRecord = TargetToReactiveRecordMap.get(target);\n\n  if (isUndefined$1(reactiveRecord)) {\n    const newRecord = create$1(null);\n    reactiveRecord = newRecord;\n    TargetToReactiveRecordMap.set(target, newRecord);\n  }\n\n  return reactiveRecord;\n}\n\nlet currentReactiveObserver = null;\nfunction valueMutated(target, key) {\n  const reactiveRecord = TargetToReactiveRecordMap.get(target);\n\n  if (!isUndefined$1(reactiveRecord)) {\n    const reactiveObservers = reactiveRecord[key];\n\n    if (!isUndefined$1(reactiveObservers)) {\n      for (let i = 0, len = reactiveObservers.length; i < len; i += 1) {\n        const ro = reactiveObservers[i];\n        ro.notify();\n      }\n    }\n  }\n}\nfunction valueObserved(target, key) {\n  // We should determine if an active Observing Record is present to track mutations.\n  if (currentReactiveObserver === null) {\n    return;\n  }\n\n  const ro = currentReactiveObserver;\n  const reactiveRecord = getReactiveRecord(target);\n  let reactiveObservers = reactiveRecord[key];\n\n  if (isUndefined$1(reactiveObservers)) {\n    reactiveObservers = [];\n    reactiveRecord[key] = reactiveObservers;\n  } else if (reactiveObservers[0] === ro) {\n    return; // perf optimization considering that most subscriptions will come from the same record\n  }\n\n  if (ArrayIndexOf$1.call(reactiveObservers, ro) === -1) {\n    ro.link(reactiveObservers);\n  }\n}\nclass ReactiveObserver {\n  constructor(callback) {\n    this.listeners = [];\n    this.callback = callback;\n  }\n\n  observe(job) {\n    const inceptionReactiveRecord = currentReactiveObserver;\n    currentReactiveObserver = this;\n    let error;\n\n    try {\n      job();\n    } catch (e) {\n      error = Object(e);\n    } finally {\n      currentReactiveObserver = inceptionReactiveRecord;\n\n      if (error !== undefined) {\n        throw error; // eslint-disable-line no-unsafe-finally\n      }\n    }\n  }\n  /**\n   * This method is responsible for disconnecting the Reactive Observer\n   * from any Reactive Record that has a reference to it, to prevent future\n   * notifications about previously recorded access.\n   */\n\n\n  reset() {\n    const {\n      listeners\n    } = this;\n    const len = listeners.length;\n\n    if (len > 0) {\n      for (let i = 0; i < len; i += 1) {\n        const set = listeners[i];\n        const pos = ArrayIndexOf$1.call(listeners[i], this);\n        ArraySplice$1.call(set, pos, 1);\n      }\n\n      listeners.length = 0;\n    }\n  } // friend methods\n\n\n  notify() {\n    this.callback.call(undefined, this);\n  }\n\n  link(reactiveObservers) {\n    ArrayPush$1.call(reactiveObservers, this); // we keep track of observing records where the observing record was added to so we can do some clean up later on\n\n    ArrayPush$1.call(this.listeners, reactiveObservers);\n  }\n\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction componentValueMutated(vm, key) {\n  valueMutated(vm.component, key);\n}\nfunction componentValueObserved(vm, key) {\n  valueObserved(vm.component, key);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This function builds a Web Component class from a LWC constructor so it can be\n * registered as a new element via customElements.define() at any given time.\n *\n * @deprecated since version 1.3.11\n *\n * @example\n * ```\n * import { buildCustomElementConstructor } from 'lwc';\n * import Foo from 'ns/foo';\n * const WC = buildCustomElementConstructor(Foo);\n * customElements.define('x-foo', WC);\n * const elm = document.createElement('x-foo');\n * ```\n */\n\nfunction deprecatedBuildCustomElementConstructor(Ctor) {\n  if (process.env.NODE_ENV !== 'production') {\n    /* eslint-disable-next-line no-console */\n    console.warn('Deprecated function called: \"buildCustomElementConstructor\" function is deprecated and it will be removed.' + `Use \"${Ctor.name}.CustomElementConstructor\" static property of the component constructor to access the corresponding custom element constructor instead.`);\n  }\n\n  return Ctor.CustomElementConstructor;\n}\nfunction buildCustomElementConstructor(Ctor) {\n  var _a;\n\n  const def = getComponentInternalDef(Ctor); // generating the hash table for attributes to avoid duplicate fields\n  // and facilitate validation and false positives in case of inheritance.\n\n  const attributeToPropMap = {};\n\n  for (const propName in def.props) {\n    attributeToPropMap[getAttrNameFromPropName(propName)] = propName;\n  }\n\n  return _a = class extends def.bridge {\n    constructor() {\n      super();\n      createVM(this, def, {\n        mode: 'open',\n        isRoot: true,\n        owner: null\n      });\n    }\n\n    connectedCallback() {\n      connectRootElement(this);\n    }\n\n    disconnectedCallback() {\n      disconnectedRootElement(this);\n    }\n\n    attributeChangedCallback(attrName, oldValue, newValue) {\n      if (oldValue === newValue) {\n        // ignoring similar values for better perf\n        return;\n      }\n\n      const propName = attributeToPropMap[attrName];\n\n      if (isUndefined(propName)) {\n        // ignoring unknown attributes\n        return;\n      }\n\n      if (!isAttributeLocked(this, attrName)) {\n        // ignoring changes triggered by the engine itself during:\n        // * diffing when public props are attempting to reflect to the DOM\n        // * component via `this.setAttribute()`, should never update the prop.\n        // Both cases, the the setAttribute call is always wrap by the unlocking\n        // of the attribute to be changed\n        return;\n      } // reflect attribute change to the corresponding props when changed\n      // from outside.\n\n\n      this[propName] = newValue;\n    }\n\n  }, // collecting all attribute names from all public props to apply\n  // the reflection from attributes to props via attributeChangedCallback.\n  _a.observedAttributes = keys(attributeToPropMap), _a;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This operation is called with a descriptor of an standard html property\n * that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors\n * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.\n */\n\nfunction createBridgeToElementDescriptor(propName, descriptor) {\n  const {\n    get,\n    set,\n    enumerable,\n    configurable\n  } = descriptor;\n\n  if (!isFunction(get)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);\n    }\n\n    throw new TypeError();\n  }\n\n  if (!isFunction(set)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);\n    }\n\n    throw new TypeError();\n  }\n\n  return {\n    enumerable,\n    configurable,\n\n    get() {\n      const vm = getAssociatedVM(this);\n\n      if (isBeingConstructed(vm)) {\n        if (process.env.NODE_ENV !== 'production') {\n          const name = vm.elm.constructor.name;\n          logError(`\\`${name}\\` constructor can't read the value of property \\`${propName}\\` because the owner component hasn't set the value yet. Instead, use the \\`${name}\\` constructor to set a default value for the property.`, vm);\n        }\n\n        return;\n      }\n\n      componentValueObserved(vm, propName);\n      return get.call(vm.elm);\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n        assert.invariant(!isUpdatingTemplate, `When updating the template of ${vmBeingRendered}, one of the accessors used by the template has side effects on the state of ${vm}.${propName}`);\n        assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n        assert.invariant(!isObject$1(newValue) || isNull(newValue), `Invalid value \"${newValue}\" for \"${propName}\" of ${vm}. Value cannot be an object, must be a primitive value.`);\n      }\n\n      if (newValue !== vm.cmpProps[propName]) {\n        vm.cmpProps[propName] = newValue;\n        componentValueMutated(vm, propName);\n      }\n\n      return set.call(vm.elm, newValue);\n    }\n\n  };\n}\n\nfunction getLinkedElement(cmp) {\n  return getAssociatedVM(cmp).elm;\n}\n/**\n * This class is the base class for any LWC element.\n * Some elements directly extends this class, others implement it via inheritance.\n **/\n\n\nfunction BaseLightningElementConstructor() {\n  // This should be as performant as possible, while any initialization should be done lazily\n  if (isNull(vmBeingConstructed)) {\n    throw new ReferenceError('Illegal constructor');\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(vmBeingConstructed.elm instanceof HTMLElement, `Component creation requires a DOM element to be associated to ${vmBeingConstructed}.`);\n  }\n\n  const vm = vmBeingConstructed;\n  const {\n    elm,\n    mode,\n    def: {\n      ctor\n    }\n  } = vm;\n  const component = this;\n  vm.component = component;\n  vm.tro = getTemplateReactiveObserver(vm);\n  vm.oar = create(null); // interaction hooks\n  // We are intentionally hiding this argument from the formal API of LWCElement because\n  // we don't want folks to know about it just yet.\n\n  if (arguments.length === 1) {\n    const {\n      callHook,\n      setHook,\n      getHook\n    } = arguments[0];\n    vm.callHook = callHook;\n    vm.setHook = setHook;\n    vm.getHook = getHook;\n  } // attaching the shadowRoot\n\n\n  const shadowRootOptions = {\n    mode,\n    delegatesFocus: !!ctor.delegatesFocus,\n    '$$lwc-synthetic-mode$$': true\n  };\n  const cmpRoot = elm.attachShadow(shadowRootOptions); // linking elm, shadow root and component with the VM\n\n  associateVM(component, vm);\n  associateVM(cmpRoot, vm);\n  associateVM(elm, vm); // VM is now initialized\n\n  vm.cmpRoot = cmpRoot;\n\n  if (process.env.NODE_ENV !== 'production') {\n    patchCustomElementWithRestrictions(elm);\n    patchComponentWithRestrictions(component);\n    patchShadowRootWithRestrictions(cmpRoot);\n  }\n\n  return this;\n}\n\nBaseLightningElementConstructor.prototype = {\n  constructor: BaseLightningElementConstructor,\n\n  dispatchEvent() {\n    const elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch;\n\n    return elm.dispatchEvent.apply(elm, arguments);\n  },\n\n  addEventListener(type, listener, options) {\n    const vm = getAssociatedVM(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vmBeingRendered = getVMBeingRendered();\n      assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n      assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n      assert.invariant(isFunction(listener), `Invalid second argument for this.addEventListener() in ${vm} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n    }\n\n    const wrappedListener = getWrappedComponentsListener(vm, listener);\n    vm.elm.addEventListener(type, wrappedListener, options);\n  },\n\n  removeEventListener(type, listener, options) {\n    const vm = getAssociatedVM(this);\n    const wrappedListener = getWrappedComponentsListener(vm, listener);\n    vm.elm.removeEventListener(type, wrappedListener, options);\n  },\n\n  hasAttribute() {\n    const elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    return elm.hasAttribute.apply(elm, arguments);\n  },\n\n  hasAttributeNS() {\n    const elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    return elm.hasAttributeNS.apply(elm, arguments);\n  },\n\n  removeAttribute(attrName) {\n    const elm = getLinkedElement(this);\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    elm.removeAttribute.apply(elm, arguments);\n    lockAttribute();\n  },\n\n  removeAttributeNS(_namespace, attrName) {\n    const elm = getLinkedElement(this);\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    elm.removeAttributeNS.apply(elm, arguments);\n    lockAttribute();\n  },\n\n  getAttribute() {\n    const elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    return elm.getAttribute.apply(elm, arguments);\n  },\n\n  getAttributeNS() {\n    const elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    return elm.getAttributeNS.apply(elm, arguments);\n  },\n\n  setAttribute(attrName) {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n    }\n\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    elm.setAttribute.apply(elm, arguments);\n    lockAttribute();\n  },\n\n  setAttributeNS(_namespace, attrName) {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n    }\n\n    unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n    elm.setAttributeNS.apply(elm, arguments);\n    lockAttribute();\n  },\n\n  getBoundingClientRect() {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `this.getBoundingClientRect() should not be called during the construction of the custom element for ${getComponentTag(vm)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`);\n    } // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n\n    return elm.getBoundingClientRect.apply(elm, arguments);\n  },\n\n  /**\n   * Returns the first element that is a descendant of node that\n   * matches selectors.\n   */\n  // querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;\n  // querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;\n  querySelector() {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `this.querySelector() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    } // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n\n    return elm.querySelector.apply(elm, arguments);\n  },\n\n  /**\n   * Returns all element descendants of node that\n   * match selectors.\n   */\n  // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,\n  // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,\n  querySelectorAll() {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `this.querySelectorAll() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    } // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n\n    return elm.querySelectorAll.apply(elm, arguments);\n  },\n\n  /**\n   * Returns all element descendants of node that\n   * match the provided tagName.\n   */\n  getElementsByTagName() {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `this.getElementsByTagName() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    } // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n\n    return elm.getElementsByTagName.apply(elm, arguments);\n  },\n\n  /**\n   * Returns all element descendants of node that\n   * match the provide classnames.\n   */\n  getElementsByClassName() {\n    const elm = getLinkedElement(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this);\n      assert.isFalse(isBeingConstructed(vm), `this.getElementsByClassName() cannot be called during the construction of the custom element for ${getComponentTag(vm)} because no children has been added to this element yet.`);\n    } // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n\n\n    return elm.getElementsByClassName.apply(elm, arguments);\n  },\n\n  get isConnected() {\n    return getLinkedElement(this).isConnected;\n  },\n\n  get classList() {\n    if (process.env.NODE_ENV !== 'production') {\n      const vm = getAssociatedVM(this); // TODO [#1290]: this still fails in dev but works in production, eventually, we should just throw in all modes\n\n      assert.isFalse(isBeingConstructed(vm), `Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);\n    }\n\n    return getLinkedElement(this).classList;\n  },\n\n  get template() {\n    const vm = getAssociatedVM(this);\n    return vm.cmpRoot;\n  },\n\n  get shadowRoot() {\n    // From within the component instance, the shadowRoot is always\n    // reported as \"closed\". Authors should rely on this.template instead.\n    return null;\n  },\n\n  render() {\n    const vm = getAssociatedVM(this);\n    return vm.def.template;\n  },\n\n  toString() {\n    const vm = getAssociatedVM(this);\n    return `[object ${vm.def.name}]`;\n  }\n\n};\nconst lightningBasedDescriptors = create(null);\n\nfor (const propName in HTMLElementOriginalDescriptors) {\n  lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);\n}\n\ndefineProperties(BaseLightningElementConstructor.prototype, lightningBasedDescriptors);\nconst ComponentConstructorAsCustomElementConstructorMap = new Map();\n\nfunction getCustomElementConstructor(Ctor) {\n  if (Ctor === BaseLightningElement) {\n    throw new TypeError(`Invalid Constructor. LightningElement base class can't be claimed as a custom element.`);\n  }\n\n  let ce = ComponentConstructorAsCustomElementConstructorMap.get(Ctor);\n\n  if (isUndefined(ce)) {\n    ce = buildCustomElementConstructor(Ctor);\n    ComponentConstructorAsCustomElementConstructorMap.set(Ctor, ce);\n  }\n\n  return ce;\n}\n/**\n * This static getter builds a Web Component class from a LWC constructor\n * so it can be registered as a new element via customElements.define()\n * at any given time. E.g.:\n *\n *      import Foo from 'ns/foo';\n *      customElements.define('x-foo', Foo.CustomElementConstructor);\n *      const elm = document.createElement('x-foo');\n *\n */\n\n\ndefineProperty(BaseLightningElementConstructor, 'CustomElementConstructor', {\n  get() {\n    return getCustomElementConstructor(this);\n  }\n\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  patchLightningElementPrototypeWithRestrictions(BaseLightningElementConstructor.prototype);\n}\n\nfreeze(BaseLightningElementConstructor);\nseal(BaseLightningElementConstructor.prototype); // @ts-ignore\n\nconst BaseLightningElement = BaseLightningElementConstructor;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * @wire decorator to wire fields and methods to a wire adapter in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\n\nfunction wire(_adapter, _config) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.fail('@wire(adapter, config?) may only be used as a decorator.');\n  }\n\n  throw new Error();\n}\nfunction internalWireFieldDecorator(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n      componentValueObserved(vm, key);\n      return vm.cmpFields[key];\n    },\n\n    set(value) {\n      const vm = getAssociatedVM(this);\n      /**\n       * Reactivity for wired fields is provided in wiring.\n       * We intentionally add reactivity here since this is just\n       * letting the author to do the wrong thing, but it will keep our\n       * system to be backward compatible.\n       */\n\n      if (value !== vm.cmpFields[key]) {\n        vm.cmpFields[key] = value;\n        componentValueMutated(vm, key);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\n\n/**\n * Copyright (C) 2017 salesforce.com, inc.\n */\nconst {\n  isArray: isArray$2\n} = Array;\nconst {\n  getPrototypeOf: getPrototypeOf$1,\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  defineProperties: ObjectDefineProperties,\n  isExtensible,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor$1,\n  getOwnPropertyNames: getOwnPropertyNames$1,\n  getOwnPropertySymbols,\n  preventExtensions,\n  hasOwnProperty: hasOwnProperty$2\n} = Object;\nconst {\n  push: ArrayPush$2,\n  concat: ArrayConcat,\n  map: ArrayMap$1\n} = Array.prototype;\nconst OtS$1 = {}.toString;\n\nfunction toString$1(obj) {\n  if (obj && obj.toString) {\n    return obj.toString();\n  } else if (typeof obj === 'object') {\n    return OtS$1.call(obj);\n  } else {\n    return obj + '';\n  }\n}\n\nfunction isUndefined$2(obj) {\n  return obj === undefined;\n}\n\nfunction isFunction$1(obj) {\n  return typeof obj === 'function';\n}\n\nfunction isObject$2(obj) {\n  return typeof obj === 'object';\n}\n\nconst proxyToValueMap = new WeakMap();\n\nfunction registerProxy(proxy, value) {\n  proxyToValueMap.set(proxy, value);\n}\n\nconst unwrap = replicaOrAny => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\nfunction wrapValue(membrane, value) {\n  return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;\n}\n/**\n * Unwrap property descriptors will set value on original descriptor\n * We only need to unwrap if value is specified\n * @param descriptor external descrpitor provided to define new property on original value\n */\n\n\nfunction unwrapDescriptor(descriptor) {\n  if (hasOwnProperty$2.call(descriptor, 'value')) {\n    descriptor.value = unwrap(descriptor.value);\n  }\n\n  return descriptor;\n}\n\nfunction lockShadowTarget(membrane, shadowTarget, originalTarget) {\n  const targetKeys = ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));\n  targetKeys.forEach(key => {\n    let descriptor = getOwnPropertyDescriptor$1(originalTarget, key); // We do not need to wrap the descriptor if configurable\n    // Because we can deal with wrapping it when user goes through\n    // Get own property descriptor. There is also a chance that this descriptor\n    // could change sometime in the future, so we can defer wrapping\n    // until we need to\n\n    if (!descriptor.configurable) {\n      descriptor = wrapDescriptor(membrane, descriptor, wrapValue);\n    }\n\n    ObjectDefineProperty(shadowTarget, key, descriptor);\n  });\n  preventExtensions(shadowTarget);\n}\n\nclass ReactiveProxyHandler {\n  constructor(membrane, value) {\n    this.originalTarget = value;\n    this.membrane = membrane;\n  }\n\n  get(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const value = originalTarget[key];\n    const {\n      valueObserved\n    } = membrane;\n    valueObserved(originalTarget, key);\n    return membrane.getProxy(value);\n  }\n\n  set(shadowTarget, key, value) {\n    const {\n      originalTarget,\n      membrane: {\n        valueMutated\n      }\n    } = this;\n    const oldValue = originalTarget[key];\n\n    if (oldValue !== value) {\n      originalTarget[key] = value;\n      valueMutated(originalTarget, key);\n    } else if (key === 'length' && isArray$2(originalTarget)) {\n      // fix for issue #236: push will add the new index, and by the time length\n      // is updated, the internal length is already equal to the new length value\n      // therefore, the oldValue is equal to the value. This is the forking logic\n      // to support this use case.\n      valueMutated(originalTarget, key);\n    }\n\n    return true;\n  }\n\n  deleteProperty(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueMutated\n      }\n    } = this;\n    delete originalTarget[key];\n    valueMutated(originalTarget, key);\n    return true;\n  }\n\n  apply(shadowTarget, thisArg, argArray) {\n    /* No op */\n  }\n\n  construct(target, argArray, newTarget) {\n    /* No op */\n  }\n\n  has(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueObserved\n      }\n    } = this;\n    valueObserved(originalTarget, key);\n    return key in originalTarget;\n  }\n\n  ownKeys(shadowTarget) {\n    const {\n      originalTarget\n    } = this;\n    return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));\n  }\n\n  isExtensible(shadowTarget) {\n    const shadowIsExtensible = isExtensible(shadowTarget);\n\n    if (!shadowIsExtensible) {\n      return shadowIsExtensible;\n    }\n\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const targetIsExtensible = isExtensible(originalTarget);\n\n    if (!targetIsExtensible) {\n      lockShadowTarget(membrane, shadowTarget, originalTarget);\n    }\n\n    return targetIsExtensible;\n  }\n\n  setPrototypeOf(shadowTarget, prototype) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString$1(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);\n    }\n  }\n\n  getPrototypeOf(shadowTarget) {\n    const {\n      originalTarget\n    } = this;\n    return getPrototypeOf$1(originalTarget);\n  }\n\n  getOwnPropertyDescriptor(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const {\n      valueObserved\n    } = this.membrane; // keys looked up via hasOwnProperty need to be reactive\n\n    valueObserved(originalTarget, key);\n    let desc = getOwnPropertyDescriptor$1(originalTarget, key);\n\n    if (isUndefined$2(desc)) {\n      return desc;\n    }\n\n    const shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);\n\n    if (!isUndefined$2(shadowDescriptor)) {\n      return shadowDescriptor;\n    } // Note: by accessing the descriptor, the key is marked as observed\n    // but access to the value, setter or getter (if available) cannot observe\n    // mutations, just like regular methods, in which case we just do nothing.\n\n\n    desc = wrapDescriptor(membrane, desc, wrapValue);\n\n    if (!desc.configurable) {\n      // If descriptor from original target is not configurable,\n      // We must copy the wrapped descriptor over to the shadow target.\n      // Otherwise, proxy will throw an invariant error.\n      // This is our last chance to lock the value.\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n      ObjectDefineProperty(shadowTarget, key, desc);\n    }\n\n    return desc;\n  }\n\n  preventExtensions(shadowTarget) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    lockShadowTarget(membrane, shadowTarget, originalTarget);\n    preventExtensions(originalTarget);\n    return true;\n  }\n\n  defineProperty(shadowTarget, key, descriptor) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const {\n      valueMutated\n    } = membrane;\n    const {\n      configurable\n    } = descriptor; // We have to check for value in descriptor\n    // because Object.freeze(proxy) calls this method\n    // with only { configurable: false, writeable: false }\n    // Additionally, method will only be called with writeable:false\n    // if the descriptor has a value, as opposed to getter/setter\n    // So we can just check if writable is present and then see if\n    // value is present. This eliminates getter and setter descriptors\n\n    if (hasOwnProperty$2.call(descriptor, 'writable') && !hasOwnProperty$2.call(descriptor, 'value')) {\n      const originalDescriptor = getOwnPropertyDescriptor$1(originalTarget, key);\n      descriptor.value = originalDescriptor.value;\n    }\n\n    ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));\n\n    if (configurable === false) {\n      ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));\n    }\n\n    valueMutated(originalTarget, key);\n    return true;\n  }\n\n}\n\nfunction wrapReadOnlyValue(membrane, value) {\n  return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;\n}\n\nclass ReadOnlyHandler {\n  constructor(membrane, value) {\n    this.originalTarget = value;\n    this.membrane = membrane;\n  }\n\n  get(shadowTarget, key) {\n    const {\n      membrane,\n      originalTarget\n    } = this;\n    const value = originalTarget[key];\n    const {\n      valueObserved\n    } = membrane;\n    valueObserved(originalTarget, key);\n    return membrane.getReadOnlyProxy(value);\n  }\n\n  set(shadowTarget, key, value) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot set \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n  deleteProperty(shadowTarget, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot delete \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n  apply(shadowTarget, thisArg, argArray) {\n    /* No op */\n  }\n\n  construct(target, argArray, newTarget) {\n    /* No op */\n  }\n\n  has(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane: {\n        valueObserved\n      }\n    } = this;\n    valueObserved(originalTarget, key);\n    return key in originalTarget;\n  }\n\n  ownKeys(shadowTarget) {\n    const {\n      originalTarget\n    } = this;\n    return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));\n  }\n\n  setPrototypeOf(shadowTarget, prototype) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid prototype mutation: Cannot set prototype on \"${originalTarget}\". \"${originalTarget}\" prototype is read-only.`);\n    }\n  }\n\n  getOwnPropertyDescriptor(shadowTarget, key) {\n    const {\n      originalTarget,\n      membrane\n    } = this;\n    const {\n      valueObserved\n    } = membrane; // keys looked up via hasOwnProperty need to be reactive\n\n    valueObserved(originalTarget, key);\n    let desc = getOwnPropertyDescriptor$1(originalTarget, key);\n\n    if (isUndefined$2(desc)) {\n      return desc;\n    }\n\n    const shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);\n\n    if (!isUndefined$2(shadowDescriptor)) {\n      return shadowDescriptor;\n    } // Note: by accessing the descriptor, the key is marked as observed\n    // but access to the value or getter (if available) cannot be observed,\n    // just like regular methods, in which case we just do nothing.\n\n\n    desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);\n\n    if (hasOwnProperty$2.call(desc, 'set')) {\n      desc.set = undefined; // readOnly membrane does not allow setters\n    }\n\n    if (!desc.configurable) {\n      // If descriptor from original target is not configurable,\n      // We must copy the wrapped descriptor over to the shadow target.\n      // Otherwise, proxy will throw an invariant error.\n      // This is our last chance to lock the value.\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n      ObjectDefineProperty(shadowTarget, key, desc);\n    }\n\n    return desc;\n  }\n\n  preventExtensions(shadowTarget) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}\". \"${originalTarget} is read-only.`);\n    }\n\n    return false;\n  }\n\n  defineProperty(shadowTarget, key, descriptor) {\n    if (process.env.NODE_ENV !== 'production') {\n      const {\n        originalTarget\n      } = this;\n      throw new Error(`Invalid mutation: Cannot defineProperty \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n    }\n\n    return false;\n  }\n\n}\n\nfunction extract(objectOrArray) {\n  if (isArray$2(objectOrArray)) {\n    return objectOrArray.map(item => {\n      const original = unwrap(item);\n\n      if (original !== item) {\n        return extract(original);\n      }\n\n      return item;\n    });\n  }\n\n  const obj = ObjectCreate(getPrototypeOf$1(objectOrArray));\n  const names = getOwnPropertyNames$1(objectOrArray);\n  return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce((seed, key) => {\n    const item = objectOrArray[key];\n    const original = unwrap(item);\n\n    if (original !== item) {\n      seed[key] = extract(original);\n    } else {\n      seed[key] = item;\n    }\n\n    return seed;\n  }, obj);\n}\n\nconst formatter = {\n  header: plainOrProxy => {\n    const originalTarget = unwrap(plainOrProxy); // if originalTarget is falsy or not unwrappable, exit\n\n    if (!originalTarget || originalTarget === plainOrProxy) {\n      return null;\n    }\n\n    const obj = extract(plainOrProxy);\n    return ['object', {\n      object: obj\n    }];\n  },\n  hasBody: () => {\n    return false;\n  },\n  body: () => {\n    return null;\n  }\n}; // Inspired from paulmillr/es6-shim\n// https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185\n\nfunction getGlobal() {\n  // the only reliable means to get the global object is `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  } // Gracefully degrade if not able to locate the global object\n\n\n  return {};\n}\n\nfunction init() {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const global = getGlobal(); // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools\n  //  - Go to Settings,\n  //  - Under console, select \"Enable custom formatters\"\n  // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview\n\n  const devtoolsFormatters = global.devtoolsFormatters || [];\n  ArrayPush$2.call(devtoolsFormatters, formatter);\n  global.devtoolsFormatters = devtoolsFormatters;\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  init();\n}\n\nfunction createShadowTarget(value) {\n  let shadowTarget = undefined;\n\n  if (isArray$2(value)) {\n    shadowTarget = [];\n  } else if (isObject$2(value)) {\n    shadowTarget = {};\n  }\n\n  return shadowTarget;\n}\n\nconst ObjectDotPrototype = Object.prototype;\n\nfunction defaultValueIsObservable(value) {\n  // intentionally checking for null\n  if (value === null) {\n    return false;\n  } // treat all non-object types, including undefined, as non-observable values\n\n\n  if (typeof value !== 'object') {\n    return false;\n  }\n\n  if (isArray$2(value)) {\n    return true;\n  }\n\n  const proto = getPrototypeOf$1(value);\n  return proto === ObjectDotPrototype || proto === null || getPrototypeOf$1(proto) === null;\n}\n\nconst defaultValueObserved = (obj, key) => {\n  /* do nothing */\n};\n\nconst defaultValueMutated = (obj, key) => {\n  /* do nothing */\n};\n\nconst defaultValueDistortion = value => value;\n\nfunction wrapDescriptor(membrane, descriptor, getValue) {\n  const {\n    set,\n    get\n  } = descriptor;\n\n  if (hasOwnProperty$2.call(descriptor, 'value')) {\n    descriptor.value = getValue(membrane, descriptor.value);\n  } else {\n    if (!isUndefined$2(get)) {\n      descriptor.get = function () {\n        // invoking the original getter with the original target\n        return getValue(membrane, get.call(unwrap(this)));\n      };\n    }\n\n    if (!isUndefined$2(set)) {\n      descriptor.set = function (value) {\n        // At this point we don't have a clear indication of whether\n        // or not a valid mutation will occur, we don't have the key,\n        // and we are not sure why and how they are invoking this setter.\n        // Nevertheless we preserve the original semantics by invoking the\n        // original setter with the original target and the unwrapped value\n        set.call(unwrap(this), membrane.unwrapProxy(value));\n      };\n    }\n  }\n\n  return descriptor;\n}\n\nclass ReactiveMembrane {\n  constructor(options) {\n    this.valueDistortion = defaultValueDistortion;\n    this.valueMutated = defaultValueMutated;\n    this.valueObserved = defaultValueObserved;\n    this.valueIsObservable = defaultValueIsObservable;\n    this.objectGraph = new WeakMap();\n\n    if (!isUndefined$2(options)) {\n      const {\n        valueDistortion,\n        valueMutated,\n        valueObserved,\n        valueIsObservable\n      } = options;\n      this.valueDistortion = isFunction$1(valueDistortion) ? valueDistortion : defaultValueDistortion;\n      this.valueMutated = isFunction$1(valueMutated) ? valueMutated : defaultValueMutated;\n      this.valueObserved = isFunction$1(valueObserved) ? valueObserved : defaultValueObserved;\n      this.valueIsObservable = isFunction$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;\n    }\n  }\n\n  getProxy(value) {\n    const unwrappedValue = unwrap(value);\n    const distorted = this.valueDistortion(unwrappedValue);\n\n    if (this.valueIsObservable(distorted)) {\n      const o = this.getReactiveState(unwrappedValue, distorted); // when trying to extract the writable version of a readonly\n      // we return the readonly.\n\n      return o.readOnly === value ? value : o.reactive;\n    }\n\n    return distorted;\n  }\n\n  getReadOnlyProxy(value) {\n    value = unwrap(value);\n    const distorted = this.valueDistortion(value);\n\n    if (this.valueIsObservable(distorted)) {\n      return this.getReactiveState(value, distorted).readOnly;\n    }\n\n    return distorted;\n  }\n\n  unwrapProxy(p) {\n    return unwrap(p);\n  }\n\n  getReactiveState(value, distortedValue) {\n    const {\n      objectGraph\n    } = this;\n    let reactiveState = objectGraph.get(distortedValue);\n\n    if (reactiveState) {\n      return reactiveState;\n    }\n\n    const membrane = this;\n    reactiveState = {\n      get reactive() {\n        const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue); // caching the reactive proxy after the first time it is accessed\n\n        const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);\n        registerProxy(proxy, value);\n        ObjectDefineProperty(this, 'reactive', {\n          value: proxy\n        });\n        return proxy;\n      },\n\n      get readOnly() {\n        const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue); // caching the readOnly proxy after the first time it is accessed\n\n        const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);\n        registerProxy(proxy, value);\n        ObjectDefineProperty(this, 'readOnly', {\n          value: proxy\n        });\n        return proxy;\n      }\n\n    };\n    objectGraph.set(distortedValue, reactiveState);\n    return reactiveState;\n  }\n\n}\n/** version: 0.26.0 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction valueDistortion(value) {\n  return value;\n}\n\nconst reactiveMembrane = new ReactiveMembrane({\n  valueObserved,\n  valueMutated,\n  valueDistortion\n});\n/**\n * EXPERIMENTAL: This function implements an unwrap mechanism that\n * works for observable membrane objects. This API is subject to\n * change or being removed.\n */\n\nconst unwrap$1 = function (value) {\n  const unwrapped = reactiveMembrane.unwrapProxy(value);\n\n  if (unwrapped !== value) {\n    // if value is a proxy, unwrap to access original value and apply distortion\n    return valueDistortion(unwrapped);\n  }\n\n  return value;\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction track(target) {\n  if (arguments.length === 1) {\n    return reactiveMembrane.getProxy(target);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);\n  }\n\n  throw new Error();\n}\nfunction internalTrackDecorator(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n      componentValueObserved(vm, key);\n      return vm.cmpFields[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString(key)}`);\n      }\n\n      const reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);\n\n      if (reactiveOrAnyValue !== vm.cmpFields[key]) {\n        vm.cmpFields[key] = reactiveOrAnyValue;\n        componentValueMutated(vm, key);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst {\n  assign: assign$1,\n  create: create$2,\n  defineProperties: defineProperties$1,\n  defineProperty: defineProperty$1,\n  freeze: freeze$1,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor$2,\n  getOwnPropertyNames: getOwnPropertyNames$2,\n  getPrototypeOf: getPrototypeOf$2,\n  hasOwnProperty: hasOwnProperty$3,\n  keys: keys$1,\n  seal: seal$1,\n  setPrototypeOf: setPrototypeOf$1\n} = Object;\n\nfunction isUndefined$3(obj) {\n  return obj === undefined;\n}\n\nfunction isTrue$1$1(obj) {\n  return obj === true;\n}\n\nfunction isFalse$1$1(obj) {\n  return obj === false;\n}\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/*\n * In IE11, symbols are expensive.\n * Due to the nature of the symbol polyfill. This method abstract the\n * creation of symbols, so we can fallback to string when native symbols\n * are not supported. Note that we can't use typeof since it will fail when transpiling.\n */\n\n\nconst hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';\n/** version: 1.6.2 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Cached reference to globalThis\n\nlet _globalThis;\n\nif (typeof globalThis === 'object') {\n  _globalThis = globalThis;\n}\n\nfunction getGlobalThis() {\n  if (typeof _globalThis === 'object') {\n    return _globalThis;\n  }\n\n  try {\n    // eslint-disable-next-line no-extend-native\n    Object.defineProperty(Object.prototype, '__magic__', {\n      get: function () {\n        return this;\n      },\n      configurable: true\n    }); // @ts-ignore\n    // __magic__ is undefined in Safari 10 and IE10 and older.\n    // eslint-disable-next-line no-undef\n\n    _globalThis = __magic__; // @ts-ignore\n\n    delete Object.prototype.__magic__;\n  } catch (ex) {// In IE8, Object.defineProperty only works on DOM objects.\n  } finally {\n    // If the magic above fails for some reason we assume that we are in a\n    // legacy browser. Assume `window` exists in this case.\n    if (typeof _globalThis === 'undefined') {\n      _globalThis = window;\n    }\n  }\n\n  return _globalThis;\n}\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n\nconst _globalThis$1 = getGlobalThis();\n\nif (!_globalThis$1.lwcRuntimeFlags) {\n  Object.defineProperty(_globalThis$1, 'lwcRuntimeFlags', {\n    value: create$2(null)\n  });\n}\n\nconst runtimeFlags = _globalThis$1.lwcRuntimeFlags; // This function is not supported for use within components and is meant for\n// configuring runtime feature flags during app initialization.\n\nfunction setFeatureFlag(name, value) {\n  const isBoolean = isTrue$1$1(value) || isFalse$1$1(value);\n\n  if (!isBoolean) {\n    const message = `Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". Runtime feature flags can only be set to a boolean value.`;\n\n    if (process.env.NODE_ENV !== 'production') {\n      throw new TypeError(message);\n    } else {\n      // eslint-disable-next-line no-console\n      console.error(message);\n      return;\n    }\n  }\n\n  if (isUndefined$3(featureFlagLookup[name])) {\n    // eslint-disable-next-line no-console\n    console.warn(`Failed to set the value \"${value}\" for the runtime feature flag \"${name}\" because it is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`);\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Allow the same flag to be set more than once outside of production to enable testing\n    runtimeFlags[name] = value;\n  } else {\n    // Disallow the same flag to be set more than once in production\n    const runtimeValue = runtimeFlags[name];\n\n    if (!isUndefined$3(runtimeValue)) {\n      // eslint-disable-next-line no-console\n      console.error(`Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". \"${name}\" has already been set with the value \"${runtimeValue}\".`);\n      return;\n    }\n\n    Object.defineProperty(runtimeFlags, name, {\n      value\n    });\n  }\n} // This function is exposed to components to facilitate testing so we add a\n// check to make sure it is not invoked in production.\n\n\nfunction setFeatureFlagForTest(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    return setFeatureFlag(name, value);\n  }\n}\n\nconst featureFlagLookup = {\n  ENABLE_REACTIVE_SETTER: null,\n  // Flags to toggle on/off the enforcement of shadow dom semantic in element/node outside lwc boundary when using synthetic shadow.\n  ENABLE_ELEMENT_PATCH: null,\n  ENABLE_NODE_LIST_PATCH: null,\n  ENABLE_HTML_COLLECTIONS_PATCH: null,\n  ENABLE_NODE_PATCH: null\n};\n/** version: 1.6.2 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction api() {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.fail(`@api decorator can only be used as a decorator function.`);\n  }\n\n  throw new Error();\n}\nfunction createPublicPropertyDescriptor(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n\n      if (isBeingConstructed(vm)) {\n        if (process.env.NODE_ENV !== 'production') {\n          const name = vm.elm.constructor.name;\n          logError(`\\`${name}\\` constructor cant read the value of property \\`${toString(key)}\\` because the owner component hasnt set the value yet. Instead, use the \\`${name}\\` constructor to set a default value for the property.`, vm);\n        }\n\n        return;\n      }\n\n      componentValueObserved(vm, key);\n      return vm.cmpProps[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString(key)}`);\n      }\n\n      vm.cmpProps[key] = newValue;\n      componentValueMutated(vm, key);\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\n\nclass AccessorReactiveObserver extends ReactiveObserver {\n  constructor(vm, set) {\n    super(() => {\n      if (isFalse$1(this.debouncing)) {\n        this.debouncing = true;\n        addCallbackToNextTick(() => {\n          if (isTrue$1(this.debouncing)) {\n            const {\n              value\n            } = this;\n            const {\n              isDirty: dirtyStateBeforeSetterCall,\n              component,\n              idx\n            } = vm;\n            set.call(component, value); // de-bouncing after the call to the original setter to prevent\n            // infinity loop if the setter itself is mutating things that\n            // were accessed during the previous invocation.\n\n            this.debouncing = false;\n\n            if (isTrue$1(vm.isDirty) && isFalse$1(dirtyStateBeforeSetterCall) && idx > 0) {\n              // immediate rehydration due to a setter driven mutation, otherwise\n              // the component will get rendered on the second tick, which it is not\n              // desirable.\n              rerenderVM(vm);\n            }\n          }\n        });\n      }\n    });\n    this.debouncing = false;\n  }\n\n  reset(value) {\n    super.reset();\n    this.debouncing = false;\n\n    if (arguments.length > 0) {\n      this.value = value;\n    }\n  }\n\n}\n\nfunction createPublicAccessorDescriptor(key, descriptor) {\n  const {\n    get,\n    set,\n    enumerable,\n    configurable\n  } = descriptor;\n\n  if (!isFunction(get)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.invariant(isFunction(get), `Invalid compiler output for public accessor ${toString(key)} decorated with @api`);\n    }\n\n    throw new Error();\n  }\n\n  return {\n    get() {\n      if (process.env.NODE_ENV !== 'production') {\n        // Assert that the this value is an actual Component with an associated VM.\n        getAssociatedVM(this);\n      }\n\n      return get.call(this);\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n        assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString(key)}`);\n      }\n\n      if (set) {\n        if (runtimeFlags.ENABLE_REACTIVE_SETTER) {\n          let ro = vm.oar[key];\n\n          if (isUndefined(ro)) {\n            ro = vm.oar[key] = new AccessorReactiveObserver(vm, set);\n          } // every time we invoke this setter from outside (through this wrapper setter)\n          // we should reset the value and then debounce just in case there is a pending\n          // invocation the next tick that is not longer relevant since the value is changing\n          // from outside.\n\n\n          ro.reset(newValue);\n          ro.observe(() => {\n            set.call(this, newValue);\n          });\n        } else {\n          set.call(this, newValue);\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        assert.fail(`Invalid attempt to set a new value for property ${toString(key)} of ${vm} that does not has a setter decorated with @api.`);\n      }\n    },\n\n    enumerable,\n    configurable\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ShadowRootInnerHTMLSetter = getOwnPropertyDescriptor(ShadowRoot.prototype, 'innerHTML').set;\nconst dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent; // IE11\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';\nconst WireMetaMap = new Map();\n\nfunction noop() {}\n\nfunction createFieldDataCallback(vm, name) {\n  const {\n    cmpFields\n  } = vm;\n  return value => {\n    if (value !== vm.cmpFields[name]) {\n      // storing the value in the underlying storage\n      cmpFields[name] = value;\n      componentValueMutated(vm, name);\n    }\n  };\n}\n\nfunction createMethodDataCallback(vm, method) {\n  return value => {\n    // dispatching new value into the wired method\n    invokeComponentCallback(vm, method, [value]);\n  };\n}\n\nfunction createConfigWatcher(vm, wireDef, callbackWhenConfigIsReady) {\n  const {\n    component\n  } = vm;\n  const {\n    configCallback\n  } = wireDef;\n  let hasPendingConfig = false; // creating the reactive observer for reactive params when needed\n\n  const ro = new ReactiveObserver(() => {\n    if (hasPendingConfig === false) {\n      hasPendingConfig = true; // collect new config in the micro-task\n\n      Promise.resolve().then(() => {\n        hasPendingConfig = false; // resetting current reactive params\n\n        ro.reset(); // dispatching a new config due to a change in the configuration\n\n        callback();\n      });\n    }\n  });\n\n  const callback = () => {\n    let config;\n    ro.observe(() => config = configCallback(component)); // eslint-disable-next-line lwc-internal/no-invalid-todo\n    // TODO: dev-mode validation of config based on the adapter.configSchema\n    // @ts-ignore it is assigned in the observe() callback\n\n    callbackWhenConfigIsReady(config);\n  };\n\n  return callback;\n}\n\nfunction createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {\n  const {\n    adapter\n  } = wireDef;\n  const adapterContextToken = getAdapterToken(adapter);\n\n  if (isUndefined(adapterContextToken)) {\n    return; // no provider found, nothing to be done\n  }\n\n  const {\n    elm,\n    context: {\n      wiredConnecting,\n      wiredDisconnecting\n    }\n  } = vm; // waiting for the component to be connected to formally request the context via the token\n\n  ArrayPush.call(wiredConnecting, () => {\n    // This event is responsible for connecting the host element with another\n    // element in the composed path that is providing contextual data. The provider\n    // must be listening for a special dom event with the name corresponding to the value of\n    // `adapterContextToken`, which will remain secret and internal to this file only to\n    // guarantee that the linkage can be forged.\n    const internalDomEvent = new CustomEvent(adapterContextToken, {\n      bubbles: true,\n      composed: true,\n\n      detail(newContext, disconnectCallback) {\n        // adds this callback into the disconnect bucket so it gets disconnected from parent\n        // the the element hosting the wire is disconnected\n        ArrayPush.call(wiredDisconnecting, disconnectCallback); // eslint-disable-next-line lwc-internal/no-invalid-todo\n        // TODO: dev-mode validation of config based on the adapter.contextSchema\n\n        callbackWhenContextIsReady(newContext);\n      }\n\n    });\n    dispatchEvent.call(elm, internalDomEvent);\n  });\n}\n\nfunction createConnector(vm, name, wireDef) {\n  const {\n    method,\n    adapter,\n    configCallback,\n    hasParams\n  } = wireDef;\n  const {\n    component\n  } = vm;\n  const dataCallback = isUndefined(method) ? createFieldDataCallback(vm, name) : createMethodDataCallback(vm, method);\n  let context;\n  let connector; // Workaround to pass the component element associated to this wire adapter instance.\n\n  defineProperty(dataCallback, DeprecatedWiredElementHost, {\n    value: vm.elm\n  });\n  runWithBoundaryProtection(vm, vm, noop, () => {\n    // job\n    connector = new adapter(dataCallback);\n  }, noop);\n\n  const updateConnectorConfig = config => {\n    // every time the config is recomputed due to tracking,\n    // this callback will be invoked with the new computed config\n    runWithBoundaryProtection(vm, vm, noop, () => {\n      // job\n      connector.update(config, context);\n    }, noop);\n  }; // Computes the current wire config and calls the update method on the wire adapter.\n  // This initial implementation may change depending on the specific wire instance, if it has params, we will need\n  // to observe changes in the next tick.\n\n\n  let computeConfigAndUpdate = () => {\n    updateConnectorConfig(configCallback(component));\n  };\n\n  if (hasParams) {\n    // This wire has dynamic parameters: we wait for the component instance is created and its values set\n    // in order to call the update(config) method.\n    Promise.resolve().then(() => {\n      computeConfigAndUpdate = createConfigWatcher(vm, wireDef, updateConnectorConfig);\n      computeConfigAndUpdate();\n    });\n  } else {\n    computeConfigAndUpdate();\n  } // if the adapter needs contextualization, we need to watch for new context and push it alongside the config\n\n\n  if (!isUndefined(adapter.contextSchema)) {\n    createContextWatcher(vm, wireDef, newContext => {\n      // every time the context is pushed into this component,\n      // this callback will be invoked with the new computed context\n      if (context !== newContext) {\n        context = newContext; // Note: when new context arrives, the config will be recomputed and pushed along side the new\n        // context, this is to preserve the identity characteristics, config should not have identity\n        // (ever), while context can have identity\n\n        computeConfigAndUpdate();\n      }\n    });\n  } // @ts-ignore the boundary protection executes sync, connector is always defined\n\n\n  return connector;\n}\n\nconst AdapterToTokenMap = new Map();\nfunction getAdapterToken(adapter) {\n  return AdapterToTokenMap.get(adapter);\n}\nfunction setAdapterToken(adapter, token) {\n  AdapterToTokenMap.set(adapter, token);\n}\nfunction storeWiredMethodMeta(descriptor, adapter, configCallback, hasParams) {\n  // support for callable adapters\n  if (adapter.adapter) {\n    adapter = adapter.adapter;\n  }\n\n  const method = descriptor.value;\n  const def = {\n    adapter,\n    method,\n    configCallback,\n    hasParams\n  };\n  WireMetaMap.set(descriptor, def);\n}\nfunction storeWiredFieldMeta(descriptor, adapter, configCallback, hasParams) {\n  // support for callable adapters\n  if (adapter.adapter) {\n    adapter = adapter.adapter;\n  }\n\n  const def = {\n    adapter,\n    configCallback,\n    hasParams\n  };\n  WireMetaMap.set(descriptor, def);\n}\nfunction installWireAdapters(vm) {\n  const {\n    def: {\n      wire\n    }\n  } = vm;\n\n  if (getOwnPropertyNames(wire).length === 0) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail(`Internal Error: wire adapters should only be installed in instances with at least one wire declaration.`);\n    }\n  } else {\n    const connect = vm.context.wiredConnecting = [];\n    const disconnect = vm.context.wiredDisconnecting = [];\n\n    for (const fieldNameOrMethod in wire) {\n      const descriptor = wire[fieldNameOrMethod];\n      const wireDef = WireMetaMap.get(descriptor);\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(wireDef, `Internal Error: invalid wire definition found.`);\n      }\n\n      if (!isUndefined(wireDef)) {\n        const adapterInstance = createConnector(vm, fieldNameOrMethod, wireDef);\n        ArrayPush.call(connect, () => adapterInstance.connect());\n        ArrayPush.call(disconnect, () => adapterInstance.disconnect());\n      }\n    }\n  }\n}\nfunction connectWireAdapters(vm) {\n  const {\n    context: {\n      wiredConnecting\n    }\n  } = vm;\n\n  if (isUndefined(wiredConnecting)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail(`Internal Error: wire adapters must be installed in instances with at least one wire declaration.`);\n    }\n  }\n\n  for (let i = 0, len = wiredConnecting.length; i < len; i += 1) {\n    wiredConnecting[i]();\n  }\n}\nfunction disconnectWireAdapters(vm) {\n  const {\n    context: {\n      wiredDisconnecting\n    }\n  } = vm;\n\n  if (isUndefined(wiredDisconnecting)) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.fail(`Internal Error: wire adapters must be installed in instances with at least one wire declaration.`);\n    }\n  }\n\n  runWithBoundaryProtection(vm, vm, noop, () => {\n    // job\n    for (let i = 0, len = wiredDisconnecting.length; i < len; i += 1) {\n      wiredDisconnecting[i]();\n    }\n  }, noop);\n}\n\nfunction createObservedFieldPropertyDescriptor(key) {\n  return {\n    get() {\n      const vm = getAssociatedVM(this);\n      componentValueObserved(vm, key);\n      return vm.cmpFields[key];\n    },\n\n    set(newValue) {\n      const vm = getAssociatedVM(this);\n\n      if (newValue !== vm.cmpFields[key]) {\n        vm.cmpFields[key] = newValue;\n        componentValueMutated(vm, key);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar PropType;\n\n(function (PropType) {\n  PropType[PropType[\"Field\"] = 0] = \"Field\";\n  PropType[PropType[\"Set\"] = 1] = \"Set\";\n  PropType[PropType[\"Get\"] = 2] = \"Get\";\n  PropType[PropType[\"GetSet\"] = 3] = \"GetSet\";\n})(PropType || (PropType = {}));\n\nfunction validateObservedField(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(descriptor)) {\n      assert.fail(`Compiler Error: Invalid field ${fieldName} declaration.`);\n    }\n  }\n}\n\nfunction validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(descriptor)) {\n      assert.fail(`Compiler Error: Invalid @track ${fieldName} declaration.`);\n    }\n  }\n}\n\nfunction validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(descriptor)) {\n      assert.fail(`Compiler Error: Invalid @wire(...) ${fieldName} field declaration.`);\n    }\n  }\n}\n\nfunction validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(descriptor) || !isFunction(descriptor.value) || isFalse$1(descriptor.writable)) {\n      assert.fail(`Compiler Error: Invalid @wire(...) ${methodName} method declaration.`);\n    }\n  }\n}\n\nfunction validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(descriptor)) {\n      assert.fail(`Compiler Error: Invalid @api ${fieldName} field declaration.`);\n    }\n  }\n}\n\nfunction validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(descriptor)) {\n      assert.fail(`Compiler Error: Invalid @api get ${fieldName} accessor declaration.`);\n    } else if (isFunction(descriptor.set)) {\n      assert.isTrue(isFunction(descriptor.get), `Compiler Error: Missing getter for property ${toString(fieldName)} decorated with @api in ${Ctor}. You cannot have a setter without the corresponding getter.`);\n    } else if (!isFunction(descriptor.get)) {\n      assert.fail(`Compiler Error: Missing @api get ${fieldName} accessor declaration.`);\n    }\n  }\n}\n\nfunction validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(descriptor) || !isFunction(descriptor.value) || isFalse$1(descriptor.writable)) {\n      assert.fail(`Compiler Error: Invalid @api ${methodName} method declaration.`);\n    }\n  }\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by user-land code.\n */\n\n\nfunction registerDecorators(Ctor, meta) {\n  const proto = Ctor.prototype;\n  const {\n    publicProps,\n    publicMethods,\n    wire,\n    track,\n    fields\n  } = meta;\n  const apiMethods = create(null);\n  const apiFields = create(null);\n  const wiredMethods = create(null);\n  const wiredFields = create(null);\n  const observedFields = create(null);\n  const apiFieldsConfig = create(null);\n  let descriptor;\n\n  if (!isUndefined(publicProps)) {\n    for (const fieldName in publicProps) {\n      const propConfig = publicProps[fieldName];\n      apiFieldsConfig[fieldName] = propConfig.config;\n      descriptor = getOwnPropertyDescriptor(proto, fieldName);\n\n      if (propConfig.config > 0) {\n        // accessor declaration\n        if (process.env.NODE_ENV !== 'production') {\n          validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);\n        }\n\n        if (isUndefined(descriptor)) {\n          throw new Error();\n        }\n\n        descriptor = createPublicAccessorDescriptor(fieldName, descriptor);\n      } else {\n        // field declaration\n        if (process.env.NODE_ENV !== 'production') {\n          validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);\n        }\n\n        descriptor = createPublicPropertyDescriptor(fieldName);\n      }\n\n      apiFields[fieldName] = descriptor;\n      defineProperty(proto, fieldName, descriptor);\n    }\n  }\n\n  if (!isUndefined(publicMethods)) {\n    forEach.call(publicMethods, methodName => {\n      descriptor = getOwnPropertyDescriptor(proto, methodName);\n\n      if (process.env.NODE_ENV !== 'production') {\n        validateMethodDecoratedWithApi(Ctor, methodName, descriptor);\n      }\n\n      if (isUndefined(descriptor)) {\n        throw new Error();\n      }\n\n      apiMethods[methodName] = descriptor;\n    });\n  }\n\n  if (!isUndefined(wire)) {\n    for (const fieldOrMethodName in wire) {\n      const {\n        adapter,\n        method,\n        config: configCallback,\n        hasParams\n      } = wire[fieldOrMethodName];\n      descriptor = getOwnPropertyDescriptor(proto, fieldOrMethodName);\n\n      if (method === 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert.isTrue(adapter, `@wire on method \"${fieldOrMethodName}\": adapter id must be truthy.`);\n          validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n        }\n\n        if (isUndefined(descriptor)) {\n          throw new Error();\n        }\n\n        wiredMethods[fieldOrMethodName] = descriptor;\n        storeWiredMethodMeta(descriptor, adapter, configCallback, hasParams);\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          assert.isTrue(adapter, `@wire on field \"${fieldOrMethodName}\": adapter id must be truthy.`);\n          validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n        }\n\n        descriptor = internalWireFieldDecorator(fieldOrMethodName);\n        wiredFields[fieldOrMethodName] = descriptor;\n        storeWiredFieldMeta(descriptor, adapter, configCallback, hasParams);\n        defineProperty(proto, fieldOrMethodName, descriptor);\n      }\n    }\n  }\n\n  if (!isUndefined(track)) {\n    for (const fieldName in track) {\n      descriptor = getOwnPropertyDescriptor(proto, fieldName);\n\n      if (process.env.NODE_ENV !== 'production') {\n        validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor);\n      }\n\n      descriptor = internalTrackDecorator(fieldName);\n      defineProperty(proto, fieldName, descriptor);\n    }\n  }\n\n  if (!isUndefined(fields)) {\n    for (let i = 0, n = fields.length; i < n; i++) {\n      const fieldName = fields[i];\n      descriptor = getOwnPropertyDescriptor(proto, fieldName);\n\n      if (process.env.NODE_ENV !== 'production') {\n        validateObservedField(Ctor, fieldName, descriptor);\n      }\n\n      observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);\n    }\n  }\n\n  setDecoratorsMeta(Ctor, {\n    apiMethods,\n    apiFields,\n    apiFieldsConfig,\n    wiredMethods,\n    wiredFields,\n    observedFields\n  });\n  return Ctor;\n}\nconst signedDecoratorToMetaMap = new Map();\n\nfunction setDecoratorsMeta(Ctor, meta) {\n  signedDecoratorToMetaMap.set(Ctor, meta);\n}\n\nconst defaultMeta = {\n  apiMethods: EmptyObject,\n  apiFields: EmptyObject,\n  apiFieldsConfig: EmptyObject,\n  wiredMethods: EmptyObject,\n  wiredFields: EmptyObject,\n  observedFields: EmptyObject\n};\nfunction getDecoratorsMeta(Ctor) {\n  const meta = signedDecoratorToMetaMap.get(Ctor);\n  return isUndefined(meta) ? defaultMeta : meta;\n}\n\nconst signedTemplateSet = new Set();\nfunction defaultEmptyTemplate() {\n  return [];\n}\nsignedTemplateSet.add(defaultEmptyTemplate);\nfunction isTemplateRegistered(tpl) {\n  return signedTemplateSet.has(tpl);\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\n\nfunction registerTemplate(tpl) {\n  signedTemplateSet.add(tpl); // chaining this method as a way to wrap existing\n  // assignment of templates easily, without too much transformation\n\n  return tpl;\n}\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker\n * Service and other similar libraries to sanitize vulnerable attributes.\n * This API is subject to change or being removed.\n */\n\nfunction sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {\n  // locker-service patches this function during runtime to sanitize vulnerable attributes.\n  // when ran off-core this function becomes a noop and returns the user authored value.\n  return attrValue;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// from the element instance, and get the value or set a new value on the component.\n// This means that across different elements, similar names can get the exact same\n// descriptor, so we can cache them:\n\nconst cachedGetterByKey = create(null);\nconst cachedSetterByKey = create(null);\n\nfunction createGetter(key) {\n  let fn = cachedGetterByKey[key];\n\n  if (isUndefined(fn)) {\n    fn = cachedGetterByKey[key] = function () {\n      const vm = getAssociatedVM(this);\n      const {\n        getHook\n      } = vm;\n      return getHook(vm.component, key);\n    };\n  }\n\n  return fn;\n}\n\nfunction createSetter(key) {\n  let fn = cachedSetterByKey[key];\n\n  if (isUndefined(fn)) {\n    fn = cachedSetterByKey[key] = function (newValue) {\n      const vm = getAssociatedVM(this);\n      const {\n        setHook\n      } = vm;\n      newValue = reactiveMembrane.getReadOnlyProxy(newValue);\n      setHook(vm.component, key, newValue);\n    };\n  }\n\n  return fn;\n}\n\nfunction createMethodCaller(methodName) {\n  return function () {\n    const vm = getAssociatedVM(this);\n    const {\n      callHook,\n      component\n    } = vm;\n    const fn = component[methodName];\n    return callHook(vm.component, fn, ArraySlice$1.call(arguments));\n  };\n}\n\nfunction HTMLBridgeElementFactory(SuperClass, props, methods) {\n  let HTMLBridgeElement;\n  /**\n   * Modern browsers will have all Native Constructors as regular Classes\n   * and must be instantiated with the new keyword. In older browsers,\n   * specifically IE11, those are objects with a prototype property defined,\n   * since they are not supposed to be extended or instantiated with the\n   * new keyword. This forking logic supports both cases, specifically because\n   * wc.ts relies on the construction path of the bridges to create new\n   * fully qualifying web components.\n   */\n\n  if (isFunction(SuperClass)) {\n    HTMLBridgeElement = class extends SuperClass {};\n  } else {\n    HTMLBridgeElement = function () {\n      // Bridge classes are not supposed to be instantiated directly in\n      // browsers that do not support web components.\n      throw new TypeError('Illegal constructor');\n    }; // prototype inheritance dance\n\n\n    setPrototypeOf(HTMLBridgeElement, SuperClass);\n    setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);\n    defineProperty(HTMLBridgeElement.prototype, 'constructor', {\n      writable: true,\n      configurable: true,\n      value: HTMLBridgeElement\n    });\n  }\n\n  const descriptors = create(null); // expose getters and setters for each public props on the new Element Bridge\n\n  for (let i = 0, len = props.length; i < len; i += 1) {\n    const propName = props[i];\n    descriptors[propName] = {\n      get: createGetter(propName),\n      set: createSetter(propName),\n      enumerable: true,\n      configurable: true\n    };\n  } // expose public methods as props on the new Element Bridge\n\n\n  for (let i = 0, len = methods.length; i < len; i += 1) {\n    const methodName = methods[i];\n    descriptors[methodName] = {\n      value: createMethodCaller(methodName),\n      writable: true,\n      configurable: true\n    };\n  }\n\n  defineProperties(HTMLBridgeElement.prototype, descriptors);\n  return HTMLBridgeElement;\n}\nconst BaseBridgeElement = HTMLBridgeElementFactory(HTMLElement, getOwnPropertyNames(HTMLElementOriginalDescriptors), []);\nfreeze(BaseBridgeElement);\nseal(BaseBridgeElement.prototype);\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction resolveCircularModuleDependency(fn) {\n  return fn();\n}\nfunction isCircularModuleDependency(obj) {\n  return isFunction(obj) && hasOwnProperty$1.call(obj, '__circular__');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CtorToDefMap = new WeakMap();\n\nfunction getCtorProto(Ctor, subclassComponentName) {\n  let proto = getPrototypeOf(Ctor);\n\n  if (isNull(proto)) {\n    throw new ReferenceError(`Invalid prototype chain for ${subclassComponentName}, you must extend LightningElement.`);\n  } // covering the cases where the ref is circular in AMD\n\n\n  if (isCircularModuleDependency(proto)) {\n    const p = resolveCircularModuleDependency(proto);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isNull(p)) {\n        throw new ReferenceError(`Circular module dependency for ${subclassComponentName}, must resolve to a constructor that extends LightningElement.`);\n      }\n    } // escape hatch for Locker and other abstractions to provide their own base class instead\n    // of our Base class without having to leak it to user-land. If the circular function returns\n    // itself, that's the signal that we have hit the end of the proto chain, which must always\n    // be base.\n\n\n    proto = p === proto ? BaseLightningElement : p;\n  }\n\n  return proto;\n}\n\nfunction createComponentDef(Ctor, meta, subclassComponentName) {\n  if (process.env.NODE_ENV !== 'production') {\n    // local to dev block\n    const ctorName = Ctor.name; // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.\n    // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a \"name\" property with string value, but found ${ctorName}.`);\n\n    assert.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a \"constructor\" property.`);\n  }\n\n  const {\n    name\n  } = meta;\n  let {\n    template\n  } = meta;\n  const decoratorsMeta = getDecoratorsMeta(Ctor);\n  const {\n    apiFields,\n    apiFieldsConfig,\n    apiMethods,\n    wiredFields,\n    wiredMethods,\n    observedFields\n  } = decoratorsMeta;\n  const proto = Ctor.prototype;\n  let {\n    connectedCallback,\n    disconnectedCallback,\n    renderedCallback,\n    errorCallback,\n    render\n  } = proto;\n  const superProto = getCtorProto(Ctor, subclassComponentName);\n  const superDef = superProto !== BaseLightningElement ? getComponentInternalDef(superProto, subclassComponentName) : lightingElementDef;\n  const SuperBridge = isNull(superDef) ? BaseBridgeElement : superDef.bridge;\n  const bridge = HTMLBridgeElementFactory(SuperBridge, keys(apiFields), keys(apiMethods));\n  const props = assign(create(null), superDef.props, apiFields);\n  const propsConfig = assign(create(null), superDef.propsConfig, apiFieldsConfig);\n  const methods = assign(create(null), superDef.methods, apiMethods);\n  const wire = assign(create(null), superDef.wire, wiredFields, wiredMethods);\n  connectedCallback = connectedCallback || superDef.connectedCallback;\n  disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;\n  renderedCallback = renderedCallback || superDef.renderedCallback;\n  errorCallback = errorCallback || superDef.errorCallback;\n  render = render || superDef.render;\n  template = template || superDef.template; // installing observed fields into the prototype.\n\n  defineProperties(proto, observedFields);\n  const def = {\n    ctor: Ctor,\n    name,\n    wire,\n    props,\n    propsConfig,\n    methods,\n    bridge,\n    template,\n    connectedCallback,\n    disconnectedCallback,\n    renderedCallback,\n    errorCallback,\n    render\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    freeze(Ctor.prototype);\n  }\n\n  return def;\n}\n/**\n * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is\n * subject to change or being removed.\n */\n\n\nfunction isComponentConstructor(ctor) {\n  if (!isFunction(ctor)) {\n    return false;\n  } // Fast path: LightningElement is part of the prototype chain of the constructor.\n\n\n  if (ctor.prototype instanceof BaseLightningElement) {\n    return true;\n  } // Slow path: LightningElement is not part of the prototype chain of the constructor, we need\n  // climb up the constructor prototype chain to check in case there are circular dependencies\n  // to resolve.\n\n\n  let current = ctor;\n\n  do {\n    if (isCircularModuleDependency(current)) {\n      const circularResolved = resolveCircularModuleDependency(current); // If the circular function returns itself, that's the signal that we have hit the end\n      // of the proto chain, which must always be a valid base constructor.\n\n      if (circularResolved === current) {\n        return true;\n      }\n\n      current = circularResolved;\n    }\n\n    if (current === BaseLightningElement) {\n      return true;\n    }\n  } while (!isNull(current) && (current = getPrototypeOf(current))); // Finally return false if the LightningElement is not part of the prototype chain.\n\n\n  return false;\n}\nfunction getComponentInternalDef(Ctor, name) {\n  let def = CtorToDefMap.get(Ctor);\n\n  if (isUndefined(def)) {\n    if (isCircularModuleDependency(Ctor)) {\n      const resolvedCtor = resolveCircularModuleDependency(Ctor);\n      def = getComponentInternalDef(resolvedCtor); // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,\n      // look up the definition in cache instead of re-resolving and recreating the def.\n\n      CtorToDefMap.set(Ctor, def);\n      return def;\n    }\n\n    if (!isComponentConstructor(Ctor)) {\n      throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.`);\n    }\n\n    let meta = getComponentRegisteredMeta(Ctor);\n\n    if (isUndefined(meta)) {\n      // TODO [#1295]: remove this workaround after refactoring tests\n      meta = {\n        template: undefined,\n        name: Ctor.name\n      };\n    }\n\n    def = createComponentDef(Ctor, meta, name || Ctor.name);\n    CtorToDefMap.set(Ctor, def);\n  }\n\n  return def;\n}\n/**\n * EXPERIMENTAL: This function provides access to the component constructor,\n * given an HTMLElement. This API is subject to change or being removed.\n */\n\nfunction getComponentConstructor(elm) {\n  let ctor = null;\n\n  if (elm instanceof HTMLElement) {\n    const vm = getAssociatedVMIfPresent(elm);\n\n    if (!isUndefined(vm)) {\n      ctor = vm.def.ctor;\n    }\n  }\n\n  return ctor;\n} // Only set prototype for public methods and properties\n// No DOM Patching occurs here\n\nfunction setElementProto(elm, def) {\n  setPrototypeOf(elm, def.bridge.prototype);\n}\nconst lightingElementDef = {\n  ctor: BaseLightningElement,\n  name: BaseLightningElement.name,\n  props: lightningBasedDescriptors,\n  propsConfig: EmptyObject,\n  methods: EmptyObject,\n  wire: EmptyObject,\n  bridge: BaseBridgeElement,\n  template: defaultEmptyTemplate,\n  render: BaseLightningElement.prototype.render\n};\n/**\n * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is\n * subject to change or being removed.\n */\n\nfunction getComponentDef(Ctor, subclassComponentName) {\n  const def = getComponentInternalDef(Ctor, subclassComponentName); // From the internal def object, we need to extract the info that is useful\n  // for some external services, e.g.: Locker Service, usually, all they care\n  // is about the shape of the constructor, the internals of it are not relevant\n  // because they don't have a way to mess with that.\n\n  const {\n    ctor,\n    name,\n    props,\n    propsConfig,\n    methods\n  } = def;\n  const publicProps = {};\n\n  for (const key in props) {\n    // avoid leaking the reference to the public props descriptors\n    publicProps[key] = {\n      config: propsConfig[key] || 0,\n      type: 'any',\n      attr: getAttrNameFromPropName(key)\n    };\n  }\n\n  const publicMethods = {};\n\n  for (const key in methods) {\n    // avoid leaking the reference to the public method descriptors\n    publicMethods[key] = methods[key].value;\n  }\n\n  return {\n    ctor,\n    name,\n    props: publicProps,\n    methods: publicMethods\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nconst noop$1 = () => void 0;\n\nfunction observeElementChildNodes(elm) {\n  elm.$domManual$ = true;\n}\n\nfunction setElementShadowToken(elm, token) {\n  elm.$shadowToken$ = token;\n}\n\nfunction updateNodeHook(oldVnode, vnode) {\n  const {\n    text\n  } = vnode;\n\n  if (oldVnode.text !== text) {\n    if (process.env.NODE_ENV !== 'production') {\n      unlockDomMutation();\n    }\n    /**\n     * Compiler will never produce a text property that is not string\n     */\n\n\n    vnode.elm.nodeValue = text;\n\n    if (process.env.NODE_ENV !== 'production') {\n      lockDomMutation();\n    }\n  }\n}\nfunction insertNodeHook(vnode, parentNode, referenceNode) {\n  if (process.env.NODE_ENV !== 'production') {\n    unlockDomMutation();\n  }\n\n  parentNode.insertBefore(vnode.elm, referenceNode);\n\n  if (process.env.NODE_ENV !== 'production') {\n    lockDomMutation();\n  }\n}\nfunction removeNodeHook(vnode, parentNode) {\n  if (process.env.NODE_ENV !== 'production') {\n    unlockDomMutation();\n  }\n\n  parentNode.removeChild(vnode.elm);\n\n  if (process.env.NODE_ENV !== 'production') {\n    lockDomMutation();\n  }\n}\nfunction createElmHook(vnode) {\n  modEvents.create(vnode); // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n\n  modAttrs.create(vnode);\n  modProps.create(vnode);\n  modStaticClassName.create(vnode);\n  modStaticStyle.create(vnode);\n  modComputedClassName.create(vnode);\n  modComputedStyle.create(vnode);\n}\nvar LWCDOMMode;\n\n(function (LWCDOMMode) {\n  LWCDOMMode[\"manual\"] = \"manual\";\n})(LWCDOMMode || (LWCDOMMode = {}));\n\nfunction fallbackElmHook(vnode) {\n  const {\n    owner\n  } = vnode;\n  const elm = vnode.elm;\n\n  if (isTrue$1(useSyntheticShadow)) {\n    const {\n      data: {\n        context\n      }\n    } = vnode;\n    const {\n      shadowAttribute\n    } = owner.context;\n\n    if (!isUndefined(context) && !isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual) {\n      // this element will now accept any manual content inserted into it\n      observeElementChildNodes(elm);\n    } // when running in synthetic shadow mode, we need to set the shadowToken value\n    // into each element from the template, so they can be styled accordingly.\n\n\n    setElementShadowToken(elm, shadowAttribute);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    const {\n      data: {\n        context\n      }\n    } = vnode;\n    const isPortal = !isUndefined(context) && !isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual;\n    patchElementWithRestrictions(elm, {\n      isPortal\n    });\n  }\n}\nfunction updateElmHook(oldVnode, vnode) {\n  // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n  modAttrs.update(oldVnode, vnode);\n  modProps.update(oldVnode, vnode);\n  modComputedClassName.update(oldVnode, vnode);\n  modComputedStyle.update(oldVnode, vnode);\n}\nfunction insertCustomElmHook(vnode) {\n  const vm = getAssociatedVM(vnode.elm);\n  appendVM(vm);\n}\nfunction updateChildrenHook(oldVnode, vnode) {\n  const {\n    children,\n    owner\n  } = vnode;\n  const fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;\n  runWithBoundaryProtection(owner, owner.owner, noop$1, () => {\n    fn(vnode.elm, oldVnode.children, children);\n  }, noop$1);\n}\nfunction allocateChildrenHook(vnode) {\n  const vm = getAssociatedVM(vnode.elm); // A component with slots will re-render because:\n  // 1- There is a change of the internal state.\n  // 2- There is a change on the external api (ex: slots)\n  //\n  // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the\n  // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children\n  // in a reused VCustomElement, there won't be any slotted children.\n  // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.\n  //\n  // In case #2, we will always get a fresh VCustomElement.\n\n  const children = vnode.aChildren || vnode.children;\n  vm.aChildren = children;\n\n  if (isTrue$1(useSyntheticShadow)) {\n    // slow path\n    allocateInSlot(vm, children); // save the allocated children in case this vnode is reused.\n\n    vnode.aChildren = children; // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!\n\n    vnode.children = EmptyArray;\n  }\n}\nfunction createViewModelHook(vnode) {\n  const elm = vnode.elm;\n\n  if (!isUndefined(getAssociatedVMIfPresent(elm))) {\n    // There is a possibility that a custom element is registered under tagName,\n    // in which case, the initialization is already carry on, and there is nothing else\n    // to do here since this hook is called right after invoking `document.createElement`.\n    return;\n  }\n\n  const {\n    mode,\n    ctor,\n    owner\n  } = vnode;\n  const def = getComponentInternalDef(ctor);\n  setElementProto(elm, def);\n\n  if (isTrue$1(useSyntheticShadow)) {\n    const {\n      shadowAttribute\n    } = owner.context; // when running in synthetic shadow mode, we need to set the shadowToken value\n    // into each element from the template, so they can be styled accordingly.\n\n    setElementShadowToken(elm, shadowAttribute);\n  }\n\n  createVM(elm, def, {\n    mode,\n    owner,\n    isRoot: false\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n  }\n}\nfunction createCustomElmHook(vnode) {\n  modEvents.create(vnode); // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n\n  modAttrs.create(vnode);\n  modProps.create(vnode);\n  modStaticClassName.create(vnode);\n  modStaticStyle.create(vnode);\n  modComputedClassName.create(vnode);\n  modComputedStyle.create(vnode);\n}\nfunction createChildrenHook(vnode) {\n  const {\n    elm,\n    children\n  } = vnode;\n\n  for (let j = 0; j < children.length; ++j) {\n    const ch = children[j];\n\n    if (ch != null) {\n      ch.hook.create(ch);\n      ch.hook.insert(ch, elm, null);\n    }\n  }\n}\nfunction rerenderCustomElmHook(vnode) {\n  const vm = getAssociatedVM(vnode.elm);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n  }\n\n  rerenderVM(vm);\n}\nfunction updateCustomElmHook(oldVnode, vnode) {\n  // Attrs need to be applied to element before props\n  // IE11 will wipe out value on radio inputs if value\n  // is set before type=radio.\n  modAttrs.update(oldVnode, vnode);\n  modProps.update(oldVnode, vnode);\n  modComputedClassName.update(oldVnode, vnode);\n  modComputedStyle.update(oldVnode, vnode);\n}\nfunction removeElmHook(vnode) {\n  // this method only needs to search on child vnodes from template\n  // to trigger the remove hook just in case some of those children\n  // are custom elements.\n  const {\n    children,\n    elm\n  } = vnode;\n\n  for (let j = 0, len = children.length; j < len; ++j) {\n    const ch = children[j];\n\n    if (!isNull(ch)) {\n      ch.hook.remove(ch, elm);\n    }\n  }\n}\nfunction removeCustomElmHook(vnode) {\n  // for custom elements we don't have to go recursively because the removeVM routine\n  // will take care of disconnecting any child VM attached to its shadow as well.\n  removeVM(getAssociatedVM(vnode.elm));\n} // Using a WeakMap instead of a WeakSet because this one works in IE11 :(\n\nconst FromIteration = new WeakMap(); // dynamic children means it was generated by an iteration\n// in a template, and will require a more complex diffing algo.\n\nfunction markAsDynamicChildren(children) {\n  FromIteration.set(children, 1);\n}\nfunction hasDynamicChildren(children) {\n  return FromIteration.has(children);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CHAR_S = 115;\nconst CHAR_V = 118;\nconst CHAR_G = 103;\nconst NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';\nconst SymbolIterator = Symbol.iterator;\nconst TextHook = {\n  create: vnode => {\n    vnode.elm = document.createTextNode(vnode.text);\n    linkNodeToShadow(vnode);\n  },\n  update: updateNodeHook,\n  insert: insertNodeHook,\n  move: insertNodeHook,\n  remove: removeNodeHook\n}; // insert is called after update, which is used somewhere else (via a module)\n// to mark the vm as inserted, that means we cannot use update as the main channel\n// to rehydrate when dirty, because sometimes the element is not inserted just yet,\n// which breaks some invariants. For that reason, we have the following for any\n// Custom Element that is inserted via a template.\n\nconst ElementHook = {\n  create: vnode => {\n    const {\n      data,\n      sel,\n      clonedElement\n    } = vnode;\n    const {\n      ns\n    } = data; // TODO [#1364]: supporting the ability to inject a cloned StyleElement via a vnode this is\n    // used for style tags for native shadow\n\n    if (isUndefined(clonedElement)) {\n      vnode.elm = isUndefined(ns) ? document.createElement(sel) : document.createElementNS(ns, sel);\n    } else {\n      vnode.elm = clonedElement;\n    }\n\n    linkNodeToShadow(vnode);\n    fallbackElmHook(vnode);\n    createElmHook(vnode);\n  },\n  update: (oldVnode, vnode) => {\n    updateElmHook(oldVnode, vnode);\n    updateChildrenHook(oldVnode, vnode);\n  },\n  insert: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n    createChildrenHook(vnode);\n  },\n  move: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n  },\n  remove: (vnode, parentNode) => {\n    removeNodeHook(vnode, parentNode);\n    removeElmHook(vnode);\n  }\n};\nconst CustomElementHook = {\n  create: vnode => {\n    const {\n      sel\n    } = vnode;\n    vnode.elm = document.createElement(sel);\n    linkNodeToShadow(vnode);\n    createViewModelHook(vnode);\n    allocateChildrenHook(vnode);\n    createCustomElmHook(vnode);\n  },\n  update: (oldVnode, vnode) => {\n    updateCustomElmHook(oldVnode, vnode); // in fallback mode, the allocation will always set children to\n    // empty and delegate the real allocation to the slot elements\n\n    allocateChildrenHook(vnode); // in fallback mode, the children will be always empty, so, nothing\n    // will happen, but in native, it does allocate the light dom\n\n    updateChildrenHook(oldVnode, vnode); // this will update the shadowRoot\n\n    rerenderCustomElmHook(vnode);\n  },\n  insert: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n    const vm = getAssociatedVM(vnode.elm);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isTrue(vm.state === VMState.created, `${vm} cannot be recycled.`);\n    }\n\n    runConnectedCallback(vm);\n    createChildrenHook(vnode);\n    insertCustomElmHook(vnode);\n  },\n  move: (vnode, parentNode, referenceNode) => {\n    insertNodeHook(vnode, parentNode, referenceNode);\n  },\n  remove: (vnode, parentNode) => {\n    removeNodeHook(vnode, parentNode);\n    removeCustomElmHook(vnode);\n  }\n};\n\nfunction linkNodeToShadow(vnode) {\n  // TODO [#1164]: this should eventually be done by the polyfill directly\n  vnode.elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;\n} // TODO [#1136]: this should be done by the compiler, adding ns to every sub-element\n\n\nfunction addNS(vnode) {\n  const {\n    data,\n    children,\n    sel\n  } = vnode;\n  data.ns = NamespaceAttributeForSVG; // TODO [#1275]: review why `sel` equal `foreignObject` should get this `ns`\n\n  if (isArray$1(children) && sel !== 'foreignObject') {\n    for (let j = 0, n = children.length; j < n; ++j) {\n      const childNode = children[j];\n\n      if (childNode != null && childNode.hook === ElementHook) {\n        addNS(childNode);\n      }\n    }\n  }\n}\n\nfunction addVNodeToChildLWC(vnode) {\n  ArrayPush.call(getVMBeingRendered().velements, vnode);\n} // [h]tml node\n\n\nfunction h(sel, data, children) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);\n    assert.isTrue(isObject$1(data), `h() 2nd argument data must be an object.`);\n    assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n    assert.isTrue('key' in data, ` <${sel}> \"key\" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`); // checking reserved internal data properties\n\n    assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n    assert.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n\n    if (data.style && !isString(data.style)) {\n      logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n    }\n\n    forEach.call(children, childVnode => {\n      if (childVnode != null) {\n        assert.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, `${childVnode} is not a vnode.`);\n      }\n    });\n  }\n\n  const {\n    key\n  } = data;\n  let text, elm;\n  const vnode = {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: ElementHook,\n    owner: vmBeingRendered\n  };\n\n  if (sel.length === 3 && StringCharCodeAt.call(sel, 0) === CHAR_S && StringCharCodeAt.call(sel, 1) === CHAR_V && StringCharCodeAt.call(sel, 2) === CHAR_G) {\n    addNS(vnode);\n  }\n\n  return vnode;\n} // [t]ab[i]ndex function\n\nfunction ti(value) {\n  // if value is greater than 0, we normalize to 0\n  // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through\n  // If value is less than -1, we don't care\n  const shouldNormalize = value > 0 && !(isTrue$1(value) || isFalse$1(value));\n\n  if (process.env.NODE_ENV !== 'production') {\n    const vmBeingRendered = getVMBeingRendered();\n\n    if (shouldNormalize) {\n      logError(`Invalid tabindex value \\`${toString(value)}\\` in template for ${vmBeingRendered}. This attribute must be set to 0 or -1.`, vmBeingRendered);\n    }\n  }\n\n  return shouldNormalize ? 0 : value;\n} // [s]lot element node\n\nfunction s(slotName, data, children, slotset) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isString(slotName), `s() 1st argument slotName must be a string.`);\n    assert.isTrue(isObject$1(data), `s() 2nd argument data must be an object.`);\n    assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n  }\n\n  if (!isUndefined(slotset) && !isUndefined(slotset[slotName]) && slotset[slotName].length !== 0) {\n    children = slotset[slotName];\n  }\n\n  const vnode = h('slot', data, children);\n\n  if (useSyntheticShadow) {\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(children);\n  }\n\n  return vnode;\n} // [c]ustom element node\n\nfunction c(sel, Ctor, data, children = EmptyArray) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);\n    assert.isTrue(isFunction(Ctor), `c() 2nd argument Ctor must be a function.`);\n    assert.isTrue(isObject$1(data), `c() 3nd argument data must be an object.`);\n    assert.isTrue(arguments.length === 3 || isArray$1(children), `c() 4nd argument data must be an array.`); // checking reserved internal data properties\n\n    assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n    assert.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n\n    if (data.style && !isString(data.style)) {\n      logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n    }\n\n    if (arguments.length === 4) {\n      forEach.call(children, childVnode => {\n        if (childVnode != null) {\n          assert.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, `${childVnode} is not a vnode.`);\n        }\n      });\n    }\n  }\n\n  const {\n    key\n  } = data;\n  let text, elm;\n  const vnode = {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: CustomElementHook,\n    ctor: Ctor,\n    owner: vmBeingRendered,\n    mode: 'open'\n  };\n  addVNodeToChildLWC(vnode);\n  return vnode;\n} // [i]terable node\n\nfunction i(iterable, factory) {\n  const list = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n\n  sc(list);\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined(iterable) || iterable === null) {\n    if (process.env.NODE_ENV !== 'production') {\n      logError(`Invalid template iteration for value \"${toString(iterable)}\" in ${vmBeingRendered}. It must be an Array or an iterable Object.`, vmBeingRendered);\n    }\n\n    return list;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isFalse(isUndefined(iterable[SymbolIterator]), `Invalid template iteration for value \\`${toString(iterable)}\\` in ${vmBeingRendered}. It must be an array-like object and not \\`null\\` nor \\`undefined\\`.`);\n  }\n\n  const iterator = iterable[SymbolIterator]();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(iterator && isFunction(iterator.next), `Invalid iterator function for \"${toString(iterable)}\" in ${vmBeingRendered}.`);\n  }\n\n  let next = iterator.next();\n  let j = 0;\n  let {\n    value,\n    done: last\n  } = next;\n  let keyMap;\n  let iterationError;\n\n  if (process.env.NODE_ENV !== 'production') {\n    keyMap = create(null);\n  }\n\n  while (last === false) {\n    // implementing a look-back-approach because we need to know if the element is the last\n    next = iterator.next();\n    last = next.done; // template factory logic based on the previous collected value\n\n    const vnode = factory(value, j, j === 0, last);\n\n    if (isArray$1(vnode)) {\n      ArrayPush.apply(list, vnode);\n    } else {\n      ArrayPush.call(list, vnode);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const vnodes = isArray$1(vnode) ? vnode : [vnode];\n      forEach.call(vnodes, childVnode => {\n        if (!isNull(childVnode) && isObject$1(childVnode) && !isUndefined(childVnode.sel)) {\n          const {\n            key\n          } = childVnode;\n\n          if (isString(key) || isNumber(key)) {\n            if (keyMap[key] === 1 && isUndefined(iterationError)) {\n              iterationError = `Duplicated \"key\" attribute value for \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. A key with value \"${childVnode.key}\" appears more than once in the iteration. Key values must be unique numbers or strings.`;\n            }\n\n            keyMap[key] = 1;\n          } else if (isUndefined(iterationError)) {\n            iterationError = `Invalid \"key\" attribute value in \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. Set a unique \"key\" value on all iterated child elements.`;\n          }\n        }\n      });\n    } // preparing next value\n\n\n    j += 1;\n    value = next.value;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(iterationError)) {\n      logError(iterationError, vmBeingRendered);\n    }\n  }\n\n  return list;\n}\n/**\n * [f]lattening\n */\n\nfunction f(items) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(items), 'flattening api can only work with arrays.');\n  }\n\n  const len = items.length;\n  const flattened = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n\n  sc(flattened);\n\n  for (let j = 0; j < len; j += 1) {\n    const item = items[j];\n\n    if (isArray$1(item)) {\n      ArrayPush.apply(flattened, item);\n    } else {\n      ArrayPush.call(flattened, item);\n    }\n  }\n\n  return flattened;\n} // [t]ext node\n\nfunction t(text) {\n  const data = EmptyObject;\n  let sel, children, key, elm;\n  return {\n    sel,\n    data,\n    children,\n    text,\n    elm,\n    key,\n    hook: TextHook,\n    owner: getVMBeingRendered()\n  };\n} // [d]ynamic value to produce a text vnode\n\nfunction d(value) {\n  if (value == null) {\n    return null;\n  }\n\n  return t(value);\n} // [b]ind function\n\nfunction b(fn) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isNull(vmBeingRendered)) {\n    throw new Error();\n  }\n\n  const vm = vmBeingRendered;\n  return function (event) {\n    invokeEventListener(vm, fn, vm.component, event);\n  };\n} // [k]ey function\n\nfunction k(compilerKey, obj) {\n  switch (typeof obj) {\n    case 'number':\n    case 'string':\n      return compilerKey + ':' + obj;\n\n    case 'object':\n      if (process.env.NODE_ENV !== 'production') {\n        assert.fail(`Invalid key value \"${obj}\" in ${getVMBeingRendered()}. Key must be a string or number.`);\n      }\n\n  }\n} // [g]lobal [id] function\n\nfunction gid(id) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined(id) || id === '') {\n    if (process.env.NODE_ENV !== 'production') {\n      logError(`Invalid id value \"${id}\". The id attribute must contain a non-empty string.`, vmBeingRendered);\n    }\n\n    return id;\n  } // We remove attributes when they are assigned a value of null\n\n\n  if (isNull(id)) {\n    return null;\n  }\n\n  return `${id}-${vmBeingRendered.idx}`;\n} // [f]ragment [id] function\n\nfunction fid(url) {\n  const vmBeingRendered = getVMBeingRendered();\n\n  if (isUndefined(url) || url === '') {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(url)) {\n        logError(`Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.`, vmBeingRendered);\n      }\n    }\n\n    return url;\n  } // We remove attributes when they are assigned a value of null\n\n\n  if (isNull(url)) {\n    return null;\n  } // Apply transformation only for fragment-only-urls\n\n\n  if (/^#/.test(url)) {\n    return `${url}-${vmBeingRendered.idx}`;\n  }\n\n  return url;\n}\n/**\n * Map to store an index value assigned to any dynamic component reference ingested\n * by dc() api. This allows us to generate a unique unique per template per dynamic\n * component reference to avoid diffing algo mismatches.\n */\n\nconst DynamicImportedComponentMap = new Map();\nlet dynamicImportedComponentCounter = 0;\n/**\n * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`\n */\n\nfunction dc(sel, Ctor, data, children) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isString(sel), `dc() 1st argument sel must be a string.`);\n    assert.isTrue(isObject$1(data), `dc() 3nd argument data must be an object.`);\n    assert.isTrue(arguments.length === 3 || isArray$1(children), `dc() 4nd argument data must be an array.`);\n  } // null or undefined values should produce a null value in the VNodes\n\n\n  if (Ctor == null) {\n    return null;\n  }\n\n  if (!isComponentConstructor(Ctor)) {\n    throw new Error(`Invalid LWC Constructor ${toString(Ctor)} for custom element <${sel}>.`);\n  }\n\n  let idx = DynamicImportedComponentMap.get(Ctor);\n\n  if (isUndefined(idx)) {\n    idx = dynamicImportedComponentCounter++;\n    DynamicImportedComponentMap.set(Ctor, idx);\n  } // the new vnode key is a mix of idx and compiler key, this is required by the diffing algo\n  // to identify different constructors as vnodes with different keys to avoid reusing the\n  // element used for previous constructors.\n\n\n  data.key = `dc:${idx}:${data.key}`;\n  return c(sel, Ctor, data, children);\n}\n/**\n * slow children collection marking mechanism. this API allows the compiler to signal\n * to the engine that a particular collection of children must be diffed using the slow\n * algo based on keys due to the nature of the list. E.g.:\n *\n *   - slot element's children: the content of the slot has to be dynamic when in synthetic\n *                              shadow mode because the `vnode.children` might be the slotted\n *                              content vs default content, in which case the size and the\n *                              keys are not matching.\n *   - children that contain dynamic components\n *   - children that are produced by iteration\n *\n */\n\nfunction sc(vnodes) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(vnodes), 'sc() api can only work with arrays.');\n  } // We have to mark the vnodes collection as dynamic so we can later on\n  // choose to use the snabbdom virtual dom diffing algo instead of our\n  // static dummy algo.\n\n\n  markAsDynamicChildren(vnodes);\n  return vnodes;\n}\n\nvar api$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    h: h,\n    ti: ti,\n    s: s,\n    c: c,\n    i: i,\n    f: f,\n    t: t,\n    d: d,\n    b: b,\n    k: k,\n    gid: gid,\n    fid: fid,\n    dc: dc,\n    sc: sc\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CachedStyleFragments = create(null);\n\nfunction createStyleElement(styleContent) {\n  const elm = document.createElement('style');\n  elm.type = 'text/css';\n  elm.textContent = styleContent;\n  return elm;\n}\n\nfunction getCachedStyleElement(styleContent) {\n  let fragment = CachedStyleFragments[styleContent];\n\n  if (isUndefined(fragment)) {\n    fragment = document.createDocumentFragment();\n    const styleElm = createStyleElement(styleContent);\n    fragment.appendChild(styleElm);\n    CachedStyleFragments[styleContent] = fragment;\n  }\n\n  return fragment.cloneNode(true).firstChild;\n}\n\nconst globalStyleParent = document.head || document.body || document;\nconst InsertedGlobalStyleContent = create(null);\n\nfunction insertGlobalStyle(styleContent) {\n  // inserts the global style when needed, otherwise does nothing\n  if (isUndefined(InsertedGlobalStyleContent[styleContent])) {\n    InsertedGlobalStyleContent[styleContent] = true;\n    const elm = createStyleElement(styleContent);\n    globalStyleParent.appendChild(elm);\n  }\n}\n\nfunction createStyleVNode(elm) {\n  const vnode = h('style', {\n    key: 'style'\n  }, EmptyArray); // TODO [#1364]: supporting the ability to inject a cloned StyleElement\n  // forcing the diffing algo to use the cloned style for native shadow\n\n  vnode.clonedElement = elm;\n  return vnode;\n}\n/**\n * Reset the styling token applied to the host element.\n */\n\n\nfunction resetStyleAttributes(vm) {\n  const {\n    context,\n    elm\n  } = vm; // Remove the style attribute currently applied to the host element.\n\n  const oldHostAttribute = context.hostAttribute;\n\n  if (!isUndefined(oldHostAttribute)) {\n    removeAttribute.call(elm, oldHostAttribute);\n  } // Reset the scoping attributes associated to the context.\n\n\n  context.hostAttribute = context.shadowAttribute = undefined;\n}\n/**\n * Apply/Update the styling token applied to the host element.\n */\n\nfunction applyStyleAttributes(vm, hostAttribute, shadowAttribute) {\n  const {\n    context,\n    elm\n  } = vm; // Remove the style attribute currently applied to the host element.\n\n  setAttribute.call(elm, hostAttribute, '');\n  context.hostAttribute = hostAttribute;\n  context.shadowAttribute = shadowAttribute;\n}\n\nfunction collectStylesheets(stylesheets, hostSelector, shadowSelector, isNative, aggregatorFn) {\n  forEach.call(stylesheets, sheet => {\n    if (isArray$1(sheet)) {\n      collectStylesheets(sheet, hostSelector, shadowSelector, isNative, aggregatorFn);\n    } else {\n      aggregatorFn(sheet(hostSelector, shadowSelector, isNative));\n    }\n  });\n}\n\nfunction evaluateCSS(stylesheets, hostAttribute, shadowAttribute) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(stylesheets), `Invalid stylesheets.`);\n  }\n\n  if (useSyntheticShadow) {\n    const hostSelector = `[${hostAttribute}]`;\n    const shadowSelector = `[${shadowAttribute}]`;\n    collectStylesheets(stylesheets, hostSelector, shadowSelector, false, textContent => {\n      insertGlobalStyle(textContent);\n    });\n    return null;\n  } else {\n    // Native shadow in place, we need to act accordingly by using the `:host` selector, and an\n    // empty shadow selector since it is not really needed.\n    let buffer = '';\n    collectStylesheets(stylesheets, emptyString, emptyString, true, textContent => {\n      buffer += textContent;\n    });\n    return createStyleVNode(getCachedStyleElement(buffer));\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar GlobalMeasurementPhase;\n\n(function (GlobalMeasurementPhase) {\n  GlobalMeasurementPhase[\"REHYDRATE\"] = \"lwc-rehydrate\";\n  GlobalMeasurementPhase[\"HYDRATE\"] = \"lwc-hydrate\";\n})(GlobalMeasurementPhase || (GlobalMeasurementPhase = {})); // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.\n// JSDom (used in Jest) for example doesn't implement the UserTiming APIs.\n\n\nconst isUserTimingSupported = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\nfunction getMarkName(phase, vm) {\n  // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce\n  // the right measures for components that are recursive.\n  return `${getComponentTag(vm)} - ${phase} - ${vm.idx}`;\n}\n\nfunction getMeasureName(phase, vm) {\n  return `${getComponentTag(vm)} - ${phase}`;\n}\n\nfunction start(markName) {\n  performance.mark(markName);\n}\n\nfunction end(measureName, markName) {\n  performance.measure(measureName, markName); // Clear the created marks and measure to avoid filling the performance entries buffer.\n  // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.\n\n  performance.clearMarks(markName);\n  performance.clearMarks(measureName);\n}\n\nfunction noop$2() {\n  /* do nothing */\n}\n\nconst startMeasure = !isUserTimingSupported ? noop$2 : function (phase, vm) {\n  const markName = getMarkName(phase, vm);\n  start(markName);\n};\nconst endMeasure = !isUserTimingSupported ? noop$2 : function (phase, vm) {\n  const markName = getMarkName(phase, vm);\n  const measureName = getMeasureName(phase, vm);\n  end(measureName, markName);\n};\nconst startGlobalMeasure = !isUserTimingSupported ? noop$2 : function (phase, vm) {\n  const markName = isUndefined(vm) ? phase : getMarkName(phase, vm);\n  start(markName);\n};\nconst endGlobalMeasure = !isUserTimingSupported ? noop$2 : function (phase, vm) {\n  const markName = isUndefined(vm) ? phase : getMarkName(phase, vm);\n  end(phase, markName);\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isUpdatingTemplate = false;\nlet vmBeingRendered = null;\nfunction getVMBeingRendered() {\n  return vmBeingRendered;\n}\nfunction setVMBeingRendered(vm) {\n  vmBeingRendered = vm;\n}\nfunction isVMBeingRendered(vm) {\n  return vm === vmBeingRendered;\n}\nconst EmptySlots = create(null);\n\nfunction validateSlots(vm, html) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const {\n    cmpSlots = EmptySlots\n  } = vm;\n  const {\n    slots = EmptyArray\n  } = html;\n\n  for (const slotName in cmpSlots) {\n    // eslint-disable-next-line lwc-internal/no-production-assert\n    assert.isTrue(isArray$1(cmpSlots[slotName]), `Slots can only be set to an array, instead received ${toString(cmpSlots[slotName])} for slot \"${slotName}\" in ${vm}.`);\n\n    if (slotName !== '' && ArrayIndexOf.call(slots, slotName) === -1) {\n      // TODO [#1297]: this should never really happen because the compiler should always validate\n      // eslint-disable-next-line lwc-internal/no-production-assert\n      logError(`Ignoring unknown provided slot name \"${slotName}\" in ${vm}. Check for a typo on the slot attribute.`, vm);\n    }\n  }\n}\n\nfunction validateFields(vm, html) {\n  if (process.env.NODE_ENV === 'production') {\n    // this method should never leak to prod\n    throw new ReferenceError();\n  }\n\n  const {\n    component\n  } = vm; // validating identifiers used by template that should be provided by the component\n\n  const {\n    ids = []\n  } = html;\n  forEach.call(ids, propName => {\n    if (!(propName in component)) {\n      // eslint-disable-next-line lwc-internal/no-production-assert\n      logError(`The template rendered by ${vm} references \\`this.${propName}\\`, which is not declared. Check for a typo in the template.`, vm);\n    }\n  });\n}\n\nfunction evaluateTemplate(vm, html) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isFunction(html), `evaluateTemplate() second argument must be an imported template instead of ${toString(html)}`);\n  }\n\n  const isUpdatingTemplateInception = isUpdatingTemplate;\n  const vmOfTemplateBeingUpdatedInception = vmBeingRendered;\n  let vnodes = [];\n  runWithBoundaryProtection(vm, vm.owner, () => {\n    // pre\n    vmBeingRendered = vm;\n\n    if (process.env.NODE_ENV !== 'production') {\n      startMeasure('render', vm);\n    }\n  }, () => {\n    // job\n    const {\n      component,\n      context,\n      cmpSlots,\n      cmpTemplate,\n      tro\n    } = vm;\n    tro.observe(() => {\n      // reset the cache memoizer for template when needed\n      if (html !== cmpTemplate) {\n        // perf opt: do not reset the shadow root during the first rendering (there is nothing to reset)\n        if (!isUndefined(cmpTemplate)) {\n          // It is important to reset the content to avoid reusing similar elements generated from a different\n          // template, because they could have similar IDs, and snabbdom just rely on the IDs.\n          resetShadowRoot(vm);\n        } // Check that the template was built by the compiler\n\n\n        if (isUndefined(html) || !isTemplateRegistered(html)) {\n          throw new TypeError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \\`import html from \"./${vm.def.name}.html\"\\`), instead, it has returned: ${toString(html)}.`);\n        }\n\n        vm.cmpTemplate = html; // Populate context with template information\n\n        context.tplCache = create(null);\n        resetStyleAttributes(vm);\n        const {\n          stylesheets,\n          stylesheetTokens\n        } = html;\n\n        if (isUndefined(stylesheets) || stylesheets.length === 0) {\n          context.styleVNode = null;\n        } else if (!isUndefined(stylesheetTokens)) {\n          const {\n            hostAttribute,\n            shadowAttribute\n          } = stylesheetTokens;\n          applyStyleAttributes(vm, hostAttribute, shadowAttribute); // Caching style vnode so it can be reused on every render\n\n          context.styleVNode = evaluateCSS(stylesheets, hostAttribute, shadowAttribute);\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          // one time operation for any new template returned by render()\n          // so we can warn if the template is attempting to use a binding\n          // that is not provided by the component instance.\n          validateFields(vm, html);\n        }\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isObject$1(context.tplCache), `vm.context.tplCache must be an object associated to ${cmpTemplate}.`); // validating slots in every rendering since the allocated content might change over time\n\n        validateSlots(vm, html);\n      } // right before producing the vnodes, we clear up all internal references\n      // to custom elements from the template.\n\n\n      vm.velements = []; // Set the global flag that template is being updated\n\n      isUpdatingTemplate = true;\n      vnodes = html.call(undefined, api$1, component, cmpSlots, context.tplCache);\n      const {\n        styleVNode\n      } = context;\n\n      if (!isNull(styleVNode)) {\n        ArrayUnshift$1.call(vnodes, styleVNode);\n      }\n    });\n  }, () => {\n    // post\n    isUpdatingTemplate = isUpdatingTemplateInception;\n    vmBeingRendered = vmOfTemplateBeingUpdatedInception;\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('render', vm);\n    }\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isArray$1(vnodes), `Compiler should produce html functions that always return an array.`);\n  }\n\n  return vnodes;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isInvokingRender = false;\nlet vmBeingConstructed = null;\nfunction isBeingConstructed(vm) {\n  return vmBeingConstructed === vm;\n}\nlet vmInvokingRenderedCallback = null;\nfunction isInvokingRenderedCallback(vm) {\n  return vmInvokingRenderedCallback === vm;\n}\n\nconst noop$3 = () => void 0;\n\nfunction invokeComponentCallback(vm, fn, args) {\n  const {\n    component,\n    callHook,\n    owner\n  } = vm;\n  let result;\n  runWithBoundaryProtection(vm, owner, noop$3, () => {\n    // job\n    result = callHook(component, fn, args);\n  }, noop$3);\n  return result;\n}\nfunction invokeComponentConstructor(vm, Ctor) {\n  const vmBeingConstructedInception = vmBeingConstructed;\n  let error;\n\n  if (process.env.NODE_ENV !== 'production') {\n    startMeasure('constructor', vm);\n  }\n\n  vmBeingConstructed = vm;\n  /**\n   * Constructors don't need to be wrapped with a boundary because for root elements\n   * it should throw, while elements from template are already wrapped by a boundary\n   * associated to the diffing algo.\n   */\n\n  try {\n    // job\n    const result = new Ctor(); // Check indirectly if the constructor result is an instance of LightningElement. Using\n    // the \"instanceof\" operator would not work here since Locker Service provides its own\n    // implementation of LightningElement, so we indirectly check if the base constructor is\n    // invoked by accessing the component on the vm.\n\n    if (vmBeingConstructed.component !== result) {\n      throw new TypeError('Invalid component constructor, the class should extend LightningElement.');\n    }\n  } catch (e) {\n    error = Object(e);\n  } finally {\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('constructor', vm);\n    }\n\n    vmBeingConstructed = vmBeingConstructedInception;\n\n    if (!isUndefined(error)) {\n      error.wcStack = getErrorComponentStack(vm); // re-throwing the original error annotated after restoring the context\n\n      throw error; // eslint-disable-line no-unsafe-finally\n    }\n  }\n}\nfunction invokeComponentRenderMethod(vm) {\n  const {\n    def: {\n      render\n    },\n    callHook,\n    component,\n    owner\n  } = vm;\n  const isRenderBeingInvokedInception = isInvokingRender;\n  const vmBeingRenderedInception = getVMBeingRendered();\n  let html;\n  let renderInvocationSuccessful = false;\n  runWithBoundaryProtection(vm, owner, () => {\n    // pre\n    isInvokingRender = true;\n    setVMBeingRendered(vm);\n  }, () => {\n    // job\n    vm.tro.observe(() => {\n      html = callHook(component, render);\n      renderInvocationSuccessful = true;\n    });\n  }, () => {\n    // post\n    isInvokingRender = isRenderBeingInvokedInception;\n    setVMBeingRendered(vmBeingRenderedInception);\n  }); // If render() invocation failed, process errorCallback in boundary and return an empty template\n\n  return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];\n}\nfunction invokeComponentRenderedCallback(vm) {\n  const {\n    def: {\n      renderedCallback\n    },\n    component,\n    callHook,\n    owner\n  } = vm;\n\n  if (!isUndefined(renderedCallback)) {\n    const vmInvokingRenderedCallbackInception = vmInvokingRenderedCallback;\n    runWithBoundaryProtection(vm, owner, () => {\n      vmInvokingRenderedCallback = vm; // pre\n\n      if (process.env.NODE_ENV !== 'production') {\n        startMeasure('renderedCallback', vm);\n      }\n    }, () => {\n      // job\n      callHook(component, renderedCallback);\n    }, () => {\n      // post\n      if (process.env.NODE_ENV !== 'production') {\n        endMeasure('renderedCallback', vm);\n      }\n\n      vmInvokingRenderedCallback = vmInvokingRenderedCallbackInception;\n    });\n  }\n}\nfunction invokeEventListener(vm, fn, thisValue, event) {\n  const {\n    callHook,\n    owner\n  } = vm;\n  runWithBoundaryProtection(vm, owner, noop$3, () => {\n    // job\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isTrue(isFunction(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);\n    }\n\n    callHook(thisValue, fn, [event]);\n  }, noop$3);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedComponentToMetaMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\n\nfunction registerComponent(Ctor, {\n  name,\n  tmpl: template\n}) {\n  signedComponentToMetaMap.set(Ctor, {\n    name,\n    template\n  }); // chaining this method as a way to wrap existing\n  // assignment of component constructor easily, without too much transformation\n\n  return Ctor;\n}\nfunction getComponentRegisteredMeta(Ctor) {\n  return signedComponentToMetaMap.get(Ctor);\n}\nfunction createComponent(uninitializedVm, Ctor) {\n  // create the component instance\n  invokeComponentConstructor(uninitializedVm, Ctor);\n  const initializedVm = uninitializedVm;\n\n  if (isUndefined(initializedVm.component)) {\n    throw new ReferenceError(`Invalid construction for ${Ctor}, you must extend LightningElement.`);\n  }\n}\nfunction getTemplateReactiveObserver(vm) {\n  return new ReactiveObserver(() => {\n    const {\n      isDirty\n    } = vm;\n\n    if (isFalse$1(isDirty)) {\n      markComponentAsDirty(vm);\n      scheduleRehydration(vm);\n    }\n  });\n}\nfunction renderComponent(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(vm.isDirty, `${vm} is not dirty.`);\n  }\n\n  vm.tro.reset();\n  const vnodes = invokeComponentRenderMethod(vm);\n  vm.isDirty = false;\n  vm.isScheduled = false;\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isArray$1(vnodes), `${vm}.render() should always return an array of vnodes instead of ${vnodes}`);\n  }\n\n  return vnodes;\n}\nfunction markComponentAsDirty(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    const vmBeingRendered = getVMBeingRendered();\n    assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);\n    assert.isFalse(isInvokingRender, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);\n    assert.isFalse(isUpdatingTemplate, `markComponentAsDirty() for ${vm} cannot be called while updating template of ${vmBeingRendered}.`);\n  }\n\n  vm.isDirty = true;\n}\nconst cmpEventListenerMap = new WeakMap();\nfunction getWrappedComponentsListener(vm, listener) {\n  if (!isFunction(listener)) {\n    throw new TypeError(); // avoiding problems with non-valid listeners\n  }\n\n  let wrappedListener = cmpEventListenerMap.get(listener);\n\n  if (isUndefined(wrappedListener)) {\n    wrappedListener = function (event) {\n      invokeEventListener(vm, listener, undefined, event);\n    };\n\n    cmpEventListenerMap.set(listener, wrappedListener);\n  }\n\n  return wrappedListener;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Services = create(null);\nconst hooks = ['rendered', 'connected', 'disconnected'];\n/**\n * EXPERIMENTAL: This function allows for the registration of \"services\"\n * in LWC by exposing hooks into the component life-cycle. This API is\n * subject to change or being removed.\n */\n\nfunction register(service) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isObject$1(service), `Invalid service declaration, ${service}: service must be an object`);\n  }\n\n  for (let i = 0; i < hooks.length; ++i) {\n    const hookName = hooks[i];\n\n    if (hookName in service) {\n      let l = Services[hookName];\n\n      if (isUndefined(l)) {\n        Services[hookName] = l = [];\n      }\n\n      ArrayPush.call(l, service[hookName]);\n    }\n  }\n}\nfunction invokeServiceHook(vm, cbs) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(isArray$1(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);\n  }\n\n  const {\n    component,\n    data,\n    def,\n    context\n  } = vm;\n\n  for (let i = 0, len = cbs.length; i < len; ++i) {\n    cbs[i].call(undefined, component, data, def, context);\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar VMState;\n\n(function (VMState) {\n  VMState[VMState[\"created\"] = 0] = \"created\";\n  VMState[VMState[\"connected\"] = 1] = \"connected\";\n  VMState[VMState[\"disconnected\"] = 2] = \"disconnected\";\n})(VMState || (VMState = {}));\n\nlet idx = 0;\n/** The internal slot used to associate different objects the engine manipulates with the VM */\n\nconst ViewModelReflection = createHiddenField('ViewModel', 'engine');\n\nfunction callHook(cmp, fn, args = []) {\n  return fn.apply(cmp, args);\n}\n\nfunction setHook(cmp, prop, newValue) {\n  cmp[prop] = newValue;\n}\n\nfunction getHook(cmp, prop) {\n  return cmp[prop];\n}\n\nfunction rerenderVM(vm) {\n  rehydrate(vm);\n}\nfunction connectRootElement(elm) {\n  const vm = getAssociatedVM(elm);\n  startGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm); // Usually means moving the element from one place to another, which is observable via\n  // life-cycle hooks.\n\n  if (vm.state === VMState.connected) {\n    disconnectedRootElement(elm);\n  }\n\n  runConnectedCallback(vm);\n  rehydrate(vm);\n  endGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);\n}\nfunction disconnectedRootElement(elm) {\n  const vm = getAssociatedVM(elm);\n  resetComponentStateWhenRemoved(vm);\n}\nfunction appendVM(vm) {\n  rehydrate(vm);\n} // just in case the component comes back, with this we guarantee re-rendering it\n// while preventing any attempt to rehydration until after reinsertion.\n\nfunction resetComponentStateWhenRemoved(vm) {\n  const {\n    state\n  } = vm;\n\n  if (state !== VMState.disconnected) {\n    const {\n      oar,\n      tro\n    } = vm; // Making sure that any observing record will not trigger the rehydrated on this vm\n\n    tro.reset(); // Making sure that any observing accessor record will not trigger the setter to be reinvoked\n\n    for (const key in oar) {\n      oar[key].reset();\n    }\n\n    runDisconnectedCallback(vm); // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)\n\n    runShadowChildNodesDisconnectedCallback(vm);\n    runLightChildNodesDisconnectedCallback(vm);\n  }\n} // this method is triggered by the diffing algo only when a vnode from the\n// old vnode.children is removed from the DOM.\n\n\nfunction removeVM(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(vm.state === VMState.connected || vm.state === VMState.disconnected, `${vm} must have been connected.`);\n  }\n\n  resetComponentStateWhenRemoved(vm);\n}\nfunction createVM(elm, def, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(elm instanceof HTMLElement, `VM creation requires a DOM element instead of ${elm}.`);\n  }\n\n  const {\n    isRoot,\n    mode,\n    owner\n  } = options;\n  idx += 1;\n  const uninitializedVm = {\n    // component creation index is defined once, and never reset, it can\n    // be preserved from one insertion to another without any issue\n    idx,\n    state: VMState.created,\n    isScheduled: false,\n    isDirty: true,\n    isRoot: isTrue$1(isRoot),\n    mode,\n    def,\n    owner,\n    elm,\n    data: EmptyObject,\n    context: create(null),\n    cmpProps: create(null),\n    cmpFields: create(null),\n    cmpSlots: useSyntheticShadow ? create(null) : undefined,\n    callHook,\n    setHook,\n    getHook,\n    children: EmptyArray,\n    aChildren: EmptyArray,\n    velements: EmptyArray,\n    // Perf optimization to preserve the shape of this obj\n    cmpTemplate: undefined,\n    component: undefined,\n    cmpRoot: undefined,\n    tro: undefined,\n    oar: undefined\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    uninitializedVm.toString = () => {\n      return `[object:vm ${def.name} (${uninitializedVm.idx})]`;\n    };\n  } // create component instance associated to the vm and the element\n\n\n  createComponent(uninitializedVm, def.ctor); // link component to the wire service\n\n  const initializedVm = uninitializedVm; // initializing the wire decorator per instance only when really needed\n\n  if (hasWireAdapters(initializedVm)) {\n    installWireAdapters(initializedVm);\n  }\n\n  return initializedVm;\n}\n\nfunction assertIsVM(obj) {\n  if (isNull(obj) || !isObject$1(obj) || !('cmpRoot' in obj)) {\n    throw new TypeError(`${obj} is not a VM.`);\n  }\n}\n\nfunction associateVM(obj, vm) {\n  setHiddenField(obj, ViewModelReflection, vm);\n}\nfunction getAssociatedVM(obj) {\n  const vm = getHiddenField(obj, ViewModelReflection);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertIsVM(vm);\n  }\n\n  return vm;\n}\nfunction getAssociatedVMIfPresent(obj) {\n  const maybeVm = getHiddenField(obj, ViewModelReflection);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!isUndefined(maybeVm)) {\n      assertIsVM(maybeVm);\n    }\n  }\n\n  return maybeVm;\n}\n\nfunction rehydrate(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(vm.elm instanceof HTMLElement, `rehydration can only happen after ${vm} was patched the first time.`);\n  }\n\n  if (isTrue$1(vm.isDirty)) {\n    const children = renderComponent(vm);\n    patchShadowRoot(vm, children);\n  }\n}\n\nfunction patchShadowRoot(vm, newCh) {\n  const {\n    cmpRoot,\n    children: oldCh\n  } = vm;\n  vm.children = newCh; // caching the new children collection\n\n  if (newCh.length > 0 || oldCh.length > 0) {\n    // patch function mutates vnodes by adding the element reference,\n    // however, if patching fails it contains partial changes.\n    if (oldCh !== newCh) {\n      const fn = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;\n      runWithBoundaryProtection(vm, vm, () => {\n        // pre\n        if (process.env.NODE_ENV !== 'production') {\n          startMeasure('patch', vm);\n        }\n      }, () => {\n        // job\n        fn(cmpRoot, oldCh, newCh);\n      }, () => {\n        // post\n        if (process.env.NODE_ENV !== 'production') {\n          endMeasure('patch', vm);\n        }\n      });\n    }\n  }\n\n  if (vm.state === VMState.connected) {\n    // If the element is connected, that means connectedCallback was already issued, and\n    // any successive rendering should finish with the call to renderedCallback, otherwise\n    // the connectedCallback will take care of calling it in the right order at the end of\n    // the current rehydration process.\n    runRenderedCallback(vm);\n  }\n}\n\nfunction runRenderedCallback(vm) {\n  const {\n    rendered\n  } = Services;\n\n  if (rendered) {\n    invokeServiceHook(vm, rendered);\n  }\n\n  invokeComponentRenderedCallback(vm);\n}\n\nlet rehydrateQueue = [];\n\nfunction flushRehydrationQueue() {\n  startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n  }\n\n  const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);\n  rehydrateQueue = []; // reset to a new queue\n\n  for (let i = 0, len = vms.length; i < len; i += 1) {\n    const vm = vms[i];\n\n    try {\n      rehydrate(vm);\n    } catch (error) {\n      if (i + 1 < len) {\n        // pieces of the queue are still pending to be rehydrated, those should have priority\n        if (rehydrateQueue.length === 0) {\n          addCallbackToNextTick(flushRehydrationQueue);\n        }\n\n        ArrayUnshift$1.apply(rehydrateQueue, ArraySlice$1.call(vms, i + 1));\n      } // we need to end the measure before throwing.\n\n\n      endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE); // re-throwing the original error will break the current tick, but since the next tick is\n      // already scheduled, it should continue patching the rest.\n\n      throw error; // eslint-disable-line no-unsafe-finally\n    }\n  }\n\n  endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n}\n\nfunction runConnectedCallback(vm) {\n  const {\n    state\n  } = vm;\n\n  if (state === VMState.connected) {\n    return; // nothing to do since it was already connected\n  }\n\n  vm.state = VMState.connected; // reporting connection\n\n  const {\n    connected\n  } = Services;\n\n  if (connected) {\n    invokeServiceHook(vm, connected);\n  }\n\n  if (hasWireAdapters(vm)) {\n    connectWireAdapters(vm);\n  }\n\n  const {\n    connectedCallback\n  } = vm.def;\n\n  if (!isUndefined(connectedCallback)) {\n    if (process.env.NODE_ENV !== 'production') {\n      startMeasure('connectedCallback', vm);\n    }\n\n    invokeComponentCallback(vm, connectedCallback);\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('connectedCallback', vm);\n    }\n  }\n}\n\nfunction hasWireAdapters(vm) {\n  return getOwnPropertyNames(vm.def.wire).length > 0;\n}\n\nfunction runDisconnectedCallback(vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(vm.state !== VMState.disconnected, `${vm} must be inserted.`);\n  }\n\n  if (isFalse$1(vm.isDirty)) {\n    // this guarantees that if the component is reused/reinserted,\n    // it will be re-rendered because we are disconnecting the reactivity\n    // linking, so mutations are not automatically reflected on the state\n    // of disconnected components.\n    vm.isDirty = true;\n  }\n\n  vm.state = VMState.disconnected; // reporting disconnection\n\n  const {\n    disconnected\n  } = Services;\n\n  if (disconnected) {\n    invokeServiceHook(vm, disconnected);\n  }\n\n  if (hasWireAdapters(vm)) {\n    disconnectWireAdapters(vm);\n  }\n\n  const {\n    disconnectedCallback\n  } = vm.def;\n\n  if (!isUndefined(disconnectedCallback)) {\n    if (process.env.NODE_ENV !== 'production') {\n      startMeasure('disconnectedCallback', vm);\n    }\n\n    invokeComponentCallback(vm, disconnectedCallback);\n\n    if (process.env.NODE_ENV !== 'production') {\n      endMeasure('disconnectedCallback', vm);\n    }\n  }\n}\n\nfunction runShadowChildNodesDisconnectedCallback(vm) {\n  const {\n    velements: vCustomElementCollection\n  } = vm; // reporting disconnection for every child in inverse order since they are inserted in reserved order\n\n  for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {\n    const elm = vCustomElementCollection[i].elm; // There are two cases where the element could be undefined:\n    // * when there is an error during the construction phase, and an\n    //   error boundary picks it, there is a possibility that the VCustomElement\n    //   is not properly initialized, and therefore is should be ignored.\n    // * when slotted custom element is not used by the element where it is slotted\n    //   into it, as a result, the custom element was never initialized.\n\n    if (!isUndefined(elm)) {\n      const childVM = getAssociatedVM(elm);\n      resetComponentStateWhenRemoved(childVM);\n    }\n  }\n}\n\nfunction runLightChildNodesDisconnectedCallback(vm) {\n  const {\n    aChildren: adoptedChildren\n  } = vm;\n  recursivelyDisconnectChildren(adoptedChildren);\n}\n/**\n * The recursion doesn't need to be a complete traversal of the vnode graph,\n * instead it can be partial, when a custom element vnode is found, we don't\n * need to continue into its children because by attempting to disconnect the\n * custom element itself will trigger the removal of anything slotted or anything\n * defined on its shadow.\n */\n\n\nfunction recursivelyDisconnectChildren(vnodes) {\n  for (let i = 0, len = vnodes.length; i < len; i += 1) {\n    const vnode = vnodes[i];\n\n    if (!isNull(vnode) && isArray$1(vnode.children) && !isUndefined(vnode.elm)) {\n      // vnode is a VElement with children\n      if (isUndefined(vnode.ctor)) {\n        // it is a VElement, just keep looking (recursively)\n        recursivelyDisconnectChildren(vnode.children);\n      } else {\n        // it is a VCustomElement, disconnect it and ignore its children\n        resetComponentStateWhenRemoved(getAssociatedVM(vnode.elm));\n      }\n    }\n  }\n} // This is a super optimized mechanism to remove the content of the shadowRoot\n// without having to go into snabbdom. Especially useful when the reset is a consequence\n// of an error, in which case the children VNodes might not be representing the current\n// state of the DOM\n\n\nfunction resetShadowRoot(vm) {\n  vm.children = EmptyArray;\n  ShadowRootInnerHTMLSetter.call(vm.cmpRoot, ''); // disconnecting any known custom element inside the shadow of the this vm\n\n  runShadowChildNodesDisconnectedCallback(vm);\n}\nfunction scheduleRehydration(vm) {\n  if (!vm.isScheduled) {\n    vm.isScheduled = true;\n\n    if (rehydrateQueue.length === 0) {\n      addCallbackToNextTick(flushRehydrationQueue);\n    }\n\n    ArrayPush.call(rehydrateQueue, vm);\n  }\n}\n\nfunction getErrorBoundaryVM(vm) {\n  let currentVm = vm;\n\n  while (!isNull(currentVm)) {\n    if (!isUndefined(currentVm.def.errorCallback)) {\n      return currentVm;\n    }\n\n    currentVm = currentVm.owner;\n  }\n}\n/**\n * EXPERIMENTAL: This function detects whether or not a Node is\n * controlled by a LWC template. This API is subject to\n * change or being removed.\n */\n\n\nfunction isNodeFromTemplate(node) {\n  if (isFalse$1(node instanceof Node)) {\n    return false;\n  } // TODO [#1250]: skipping the shadowRoot instances itself makes no sense, we need to revisit this with locker\n\n\n  if (node instanceof ShadowRoot) {\n    return false;\n  }\n\n  if (useSyntheticShadow) {\n    // TODO [#1252]: old behavior that is still used by some pieces of the platform, specifically, nodes inserted\n    // manually on places where `lwc:dom=\"manual\"` directive is not used, will be considered global elements.\n    if (isUndefined(node.$shadowResolver$)) {\n      return false;\n    }\n  }\n\n  const root = node.getRootNode();\n  return root instanceof ShadowRoot;\n} // slow path routine\n// NOTE: we should probably more this routine to the synthetic shadow folder\n// and get the allocation to be cached by in the elm instead of in the VM\n\nfunction allocateInSlot(vm, children) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.invariant(isObject$1(vm.cmpSlots), `When doing manual allocation, there must be a cmpSlots object available.`);\n  }\n\n  const {\n    cmpSlots: oldSlots\n  } = vm;\n  const cmpSlots = vm.cmpSlots = create(null);\n\n  for (let i = 0, len = children.length; i < len; i += 1) {\n    const vnode = children[i];\n\n    if (isNull(vnode)) {\n      continue;\n    }\n\n    const {\n      data\n    } = vnode;\n    const slotName = data.attrs && data.attrs.slot || '';\n    const vnodes = cmpSlots[slotName] = cmpSlots[slotName] || []; // re-keying the vnodes is necessary to avoid conflicts with default content for the slot\n    // which might have similar keys. Each vnode will always have a key that\n    // starts with a numeric character from compiler. In this case, we add a unique\n    // notation for slotted vnodes keys, e.g.: `@foo:1:1`\n\n    vnode.key = `@${slotName}:${vnode.key}`;\n    ArrayPush.call(vnodes, vnode);\n  }\n\n  if (isFalse$1(vm.isDirty)) {\n    // We need to determine if the old allocation is really different from the new one\n    // and mark the vm as dirty\n    const oldKeys = keys(oldSlots);\n\n    if (oldKeys.length !== keys(cmpSlots).length) {\n      markComponentAsDirty(vm);\n      return;\n    }\n\n    for (let i = 0, len = oldKeys.length; i < len; i += 1) {\n      const key = oldKeys[i];\n\n      if (isUndefined(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {\n        markComponentAsDirty(vm);\n        return;\n      }\n\n      const oldVNodes = oldSlots[key];\n      const vnodes = cmpSlots[key];\n\n      for (let j = 0, a = cmpSlots[key].length; j < a; j += 1) {\n        if (oldVNodes[j] !== vnodes[j]) {\n          markComponentAsDirty(vm);\n          return;\n        }\n      }\n    }\n  }\n}\nfunction runWithBoundaryProtection(vm, owner, pre, job, post) {\n  let error;\n  pre();\n\n  try {\n    job();\n  } catch (e) {\n    error = Object(e);\n  } finally {\n    post();\n\n    if (!isUndefined(error)) {\n      error.wcStack = error.wcStack || getErrorComponentStack(vm);\n      const errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);\n\n      if (isUndefined(errorBoundaryVm)) {\n        throw error; // eslint-disable-line no-unsafe-finally\n      }\n\n      resetShadowRoot(vm); // remove offenders\n\n      if (process.env.NODE_ENV !== 'production') {\n        startMeasure('errorCallback', errorBoundaryVm);\n      } // error boundaries must have an ErrorCallback\n\n\n      const errorCallback = errorBoundaryVm.def.errorCallback;\n      invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);\n\n      if (process.env.NODE_ENV !== 'production') {\n        endMeasure('errorCallback', errorBoundaryVm);\n      }\n    }\n  }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ConnectingSlot = createHiddenField('connecting', 'engine');\nconst DisconnectingSlot = createHiddenField('disconnecting', 'engine');\n\nfunction callNodeSlot(node, slot) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);\n  }\n\n  const fn = getHiddenField(node, slot);\n\n  if (!isUndefined(fn)) {\n    fn(node);\n  }\n\n  return node; // for convenience\n} // Monkey patching Node methods to be able to detect the insertions and removal of root elements\n// created via createElement.\n\n\nassign(Node.prototype, {\n  appendChild(newChild) {\n    const appendedNode = appendChild.call(this, newChild);\n    return callNodeSlot(appendedNode, ConnectingSlot);\n  },\n\n  insertBefore(newChild, referenceNode) {\n    const insertedNode = insertBefore.call(this, newChild, referenceNode);\n    return callNodeSlot(insertedNode, ConnectingSlot);\n  },\n\n  removeChild(oldChild) {\n    const removedNode = removeChild.call(this, oldChild);\n    return callNodeSlot(removedNode, DisconnectingSlot);\n  },\n\n  replaceChild(newChild, oldChild) {\n    const replacedNode = replaceChild.call(this, newChild, oldChild);\n    callNodeSlot(replacedNode, DisconnectingSlot);\n    callNodeSlot(newChild, ConnectingSlot);\n    return replacedNode;\n  }\n\n});\n/**\n * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly\n * difference that in the options, you can pass the `is` property set to a Constructor instead of\n * just a string value. The intent is to allow the creation of an element controlled by LWC without\n * having to register the element as a custom element.\n *\n * @example\n * ```\n * const el = createElement('x-foo', { is: FooCtor });\n * ```\n */\n\nfunction createElement(sel, options) {\n  if (!isObject$1(options) || isNull(options)) {\n    throw new TypeError(`\"createElement\" function expects an object as second parameter but received \"${toString(options)}\".`);\n  }\n\n  const Ctor = options.is;\n\n  if (!isFunction(Ctor)) {\n    throw new TypeError(`\"createElement\" function expects a \"is\" option with a valid component constructor.`);\n  }\n\n  const element = document.createElement(sel); // There is a possibility that a custom element is registered under tagName, in which case, the\n  // initialization is already carry on, and there is nothing else to do here.\n\n  if (!isUndefined(getAssociatedVMIfPresent(element))) {\n    return element;\n  }\n\n  const def = getComponentInternalDef(Ctor);\n  setElementProto(element, def);\n  createVM(element, def, {\n    mode: options.mode !== 'closed' ? 'open' : 'closed',\n    owner: null,\n    isRoot: true\n  });\n  setHiddenField(element, ConnectingSlot, connectRootElement);\n  setHiddenField(element, DisconnectingSlot, disconnectedRootElement);\n  return element;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\nfunction createContextProvider(adapter) {\n  let adapterContextToken = getAdapterToken(adapter);\n\n  if (!isUndefined(adapterContextToken)) {\n    throw new Error(`Adapter already have a context provider.`);\n  }\n\n  adapterContextToken = guid();\n  setAdapterToken(adapter, adapterContextToken);\n  const providers = [];\n  return (elm, options) => {\n    if (ArrayIndexOf.call(providers, elm) !== -1) {\n      throw new Error(`Adapter was already installed on ${elm}.`);\n    }\n\n    providers.push(elm);\n    const {\n      consumerConnectedCallback,\n      consumerDisconnectedCallback\n    } = options;\n    elm.addEventListener(adapterContextToken, evt => {\n      const {\n        detail\n      } = evt;\n      const consumer = {\n        provide(newContext) {\n          detail(newContext, disconnectCallback);\n        }\n\n      };\n\n      const disconnectCallback = () => {\n        if (!isUndefined(consumerDisconnectedCallback)) {\n          consumerDisconnectedCallback(consumer);\n        }\n      };\n\n      consumerConnectedCallback(consumer);\n      evt.stopImmediatePropagation();\n    });\n  };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function allows you to create a reactive readonly\n * membrane around any object value. This API is subject to change or\n * being removed.\n */\n\nfunction readonly(obj) {\n  if (process.env.NODE_ENV !== 'production') {\n    // TODO [#1292]: Remove the readonly decorator\n    if (arguments.length !== 1) {\n      assert.fail('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');\n    }\n  }\n\n  return reactiveMembrane.getReadOnlyProxy(obj);\n}\n\nexports.LightningElement = BaseLightningElement;\nexports.api = api;\nexports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;\nexports.createContextProvider = createContextProvider;\nexports.createElement = createElement;\nexports.getComponentConstructor = getComponentConstructor;\nexports.getComponentDef = getComponentDef;\nexports.isComponentConstructor = isComponentConstructor;\nexports.isNodeFromTemplate = isNodeFromTemplate;\nexports.readonly = readonly;\nexports.register = register;\nexports.registerComponent = registerComponent;\nexports.registerDecorators = registerDecorators;\nexports.registerTemplate = registerTemplate;\nexports.sanitizeAttribute = sanitizeAttribute;\nexports.setFeatureFlag = setFeatureFlag;\nexports.setFeatureFlagForTest = setFeatureFlagForTest;\nexports.track = track;\nexports.unwrap = unwrap$1;\nexports.wire = wire;\n/* version: 1.6.2 */\n"],"sourceRoot":""}